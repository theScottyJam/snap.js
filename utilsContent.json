[{"categoryHeading":"Hidden","entries":[{"name":"mapKeys","manifest":{"fnSignature":"mapKeys(obj, fn)","summaryHtml":"<p>Constructs a new object where each key in <code>obj</code> has been mapped by <code>fn</code> to a new key.</p>"},"descriptionHtml":"<h2>Parameters</h2>\n<ul>\n<li><p><code>obj</code></p>\n<p>The object to be processed</p></li>\n<li><p><code>fn</code></p>\n<p>A callback that will be called with each key in the object. This function should return a transformed key that will be used to construct the new object. The callback accepts the following parameters:</p></li>\n<li><p><code>key</code>: The current key to transform.</p></li>\n</ul>\n<h2>Examples</h2>\n<pre><code class=\"javascript language-javascript\">mapKeys({ key1: 2, key2: 3 }, k =&gt; `prefix_${k}`)\n// =&gt; { prefix_key1: 2, prefix_key2: 3 }\n</code></pre>\n<h2>Additional Information</h2>\n<p>Any attributes in <code>obj</code>'s prototype will be ignored.</p>","src":"function mapKeys(obj, fn) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    newObj[fn(key)] = value;\n  }\n  return newObj;\n}","test":"function mapKeys(obj, fn) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    newObj[fn(key)] = value;\n  }\n  return newObj;\n}\n\ndescribe('mapKeys()', () => {\n  it('maps keys in objects', () => {\n    const oldObj = { a: 2, b: 3 };\n    const newObj = mapKeys(oldObj, k => k + k);\n    expect(newObj).toEqual({ aa: 2, bb: 3 });\n  });\n\n  it('only maps own (non-inherited) values', () => {\n    class MyClass {\n      x = 2;\n      f() {}\n    }\n\n    const oldObj = new MyClass();\n    const newObj = mapKeys(oldObj, k => k + k);\n    expect(newObj).toEqual({ xx: 2 });\n  });\n});\n"},{"name":"mapValues","manifest":{"fnSignature":"mapValues(obj, fn)","summaryHtml":"<p>Constructs a new object where each value in <code>obj</code> has been mapped by <code>fn</code> to a new value.</p>"},"descriptionHtml":"<h2>Parameters</h2>\n<ul>\n<li><p><code>obj</code></p>\n<p>The object to be processed</p></li>\n<li><p><code>fn</code></p>\n<p>A callback that will be called with each value in the object. This function should return a transformed value that will be used to construct the new object. The callback accepts the following parameters:</p></li>\n<li><p><code>value</code>: The current value to transform.</p></li>\n</ul>\n<h2>Examples</h2>\n<pre><code class=\"javascript language-javascript\">mapValues({ a: 2, b: 3 }, x =&gt; x ** 2)\n// =&gt; { a: 4, b: 9 }\n</code></pre>\n<h2>Additional Information</h2>\n<p>Any attributes in <code>obj</code>'s prototype will be ignored.</p>","src":"function mapValues(obj, fn) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    newObj[key] = fn(value);\n  }\n  return newObj;\n}","test":"function mapValues(obj, fn) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    newObj[key] = fn(value);\n  }\n  return newObj;\n}\n\ndescribe('mapValues()', () => {\n  it('maps values in objects', () => {\n    const oldObj = { a: 2, b: 3 };\n    const newObj = mapValues(oldObj, x => x + 1);\n    expect(newObj).toEqual({ a: 3, b: 4 });\n  });\n\n  it('only maps own (non-inherited) values', () => {\n    class MyClass {\n      x = 2;\n      f() {}\n    }\n\n    const oldObj = new MyClass();\n    const newObj = mapValues(oldObj, x => x + 1);\n    expect(newObj).toEqual({ x: 3 });\n  });\n});\n"},{"name":"invert","manifest":{"fnSignature":"invert(obj)","summaryHtml":"<p>Constructs a new object that maps <code>obj</code>'s values to its keys.</p>"},"descriptionHtml":"<h2>Parameters</h2>\n<ul>\n<li><p><code>obj</code></p>\n<p>The object to invert.</p></li>\n</ul>\n<h2>Examples</h2>\n<pre><code class=\"javascript language-javascript\">invert({ five: '5', six: '6' })\n// =&gt; { 5: \"five\", 6: \"six\" }\n</code></pre>\n<h2>Additional Information</h2>\n<p>Any attributes in <code>obj</code>'s prototype will be ignored.</p>","src":"function invert(obj) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    newObj[value] = key;\n  }\n  return newObj;\n}","test":"function invert(obj) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    newObj[value] = key;\n  }\n  return newObj;\n}\n\ndescribe('invert()', () => {\n  it('inverts keys and values of an object', () => {\n    const oldObj = { a: 2, b: 3 };\n    const newObj = invert(oldObj);\n    expect(newObj).toEqual({ 2: 'a', 3: 'b' });\n  });\n\n  it('only maps own (non-inherited) values', () => {\n    class MyClass {\n      x = 2;\n      f() {}\n    }\n\n    const oldObj = new MyClass();\n    const newObj = invert(oldObj);\n    expect(newObj).toEqual({ 2: 'x' });\n  });\n});\n"},{"name":"intersection","manifest":{"fnSignature":"intersection(array1, array2)","summaryHtml":"<p>Returns an array of elements that exist in both <code>array1</code> and <code>array2</code></p>"},"descriptionHtml":"","src":"function intersection(array1, array2) {\n  return array1.filter(x => array2.includes(x));\n}","test":"function intersection(array1, array2) {\n  return array1.filter(x => array2.includes(x));\n}\n\ndescribe('intersection()', () => {\n  it('finds common elements in the arrays', () => {\n    expect(intersection(['a', 'b', 'c'], ['b', 'c', 'd'])).toEqual([\n      'b',\n      'c',\n    ]);\n  });\n\n  it('returns an empty array when no common elements exist', () => {\n    expect(intersection(['x'], ['y'])).toEqual([]);\n  });\n\n  it('returns an empty array when input arrays are empty', () => {\n    expect(intersection([], [])).toEqual([]);\n  });\n});\n"},{"name":"difference","manifest":{"fnSignature":"difference(array1, array2)","summaryHtml":"<p>Returns an array of elements that are in <code>array1</code> but not in <code>array2</code>.</p>"},"descriptionHtml":"","src":"function difference(array1, array2) {\n  return array1.filter(x => !array2.includes(x));\n}","test":"function difference(array1, array2) {\n  return array1.filter(x => !array2.includes(x));\n}\n\ndescribe('difference()', () => {\n  it('calculates the difference of two arrays', () => {\n    expect(difference(['a', 'b', 'c'], ['c', 'd'])).toEqual(['a', 'b']);\n  });\n\n  it('returns an empty array when all elements are removed', () => {\n    expect(difference(['x'], ['x', 'y'])).toEqual([]);\n  });\n\n  it('returns an empty array when input arrays are empty', () => {\n    expect(difference([], [])).toEqual([]);\n  });\n});\n"},{"name":"zip","manifest":{"fnSignature":"zip(...arrays)","summaryHtml":"<p>Allows iterating over multiple arrays at the same time.</p>"},"descriptionHtml":"","src":"function* zip(...arrays) {\n  if (arrays.length === 0) return;\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  for (let i = 0; i < minLength; ++i) {\n    yield arrays.map(arr => arr[i]);\n  }\n}","test":"function* zip(...arrays) {\n  if (arrays.length === 0) return;\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  for (let i = 0; i < minLength; ++i) {\n    yield arrays.map(arr => arr[i]);\n  }\n}\n\ndescribe('zip()', () => {\n  const range = (start, stop) =>\n    Array.from({ length: stop - start }, (_, i) => i + start);\n\n  it('zips up arrays', () => {\n    const zipped = [...zip(range(0, 3), range(3, 6))];\n    expect(zipped).toEqual([\n      [0, 3],\n      [1, 4],\n      [2, 5],\n    ]);\n  });\n\n  it('discards elements from longer arrays', () => {\n    const zipped = [...zip(range(0, 3), range(3, 9))];\n    expect(zipped).toEqual([\n      [0, 3],\n      [1, 4],\n      [2, 5],\n    ]);\n  });\n\n  it('zips up three arrays', () => {\n    const zipped = [...zip([1, 4], [2, 5], [3, 6])];\n    expect(zipped).toEqual([\n      [1, 2, 3],\n      [4, 5, 6],\n    ]);\n  });\n\n  it('zips up a single arrays', () => {\n    const zipped = [...zip([1, 2, 3])];\n    expect(zipped).toEqual([[1], [2], [3]]);\n  });\n\n  it('zips up no arrays', () => {\n    const zipped = [...zip()];\n    expect(zipped).toEqual([]);\n  });\n\n  it('zips up empty arrays', () => {\n    const zipped = [...zip([], [])];\n    expect(zipped).toEqual([]);\n  });\n});\n"},{"name":"truncate","manifest":{"fnSignature":"truncate(str, maxSize, options?)","summaryHtml":"<p>Truncates <code>str</code> and append an ellipse when it's length exceeds <code>maxSize</code></p>"},"descriptionHtml":"","src":"function truncate(str, maxSize, { truncIndicator = '…' } = {}) {\n  if (str.length <= maxSize) return str;\n  return str.slice(0, maxSize) + truncIndicator;\n}","test":"function truncate(str, maxSize, { truncIndicator = '…' } = {}) {\n  if (str.length <= maxSize) return str;\n  return str.slice(0, maxSize) + truncIndicator;\n}\n\ndescribe('truncate()', () => {\n  it('does not modify a string within the size limit', () => {\n    const res = truncate('abcde', 5);\n    expect(res).toBe('abcde');\n  });\n\n  it('truncates strings that are too large', () => {\n    const res = truncate('abcdef', 5);\n    expect(res).toBe('abcde…');\n  });\n\n  it('allows truncate indicator to be customized', () => {\n    const res = truncate('abcdef', 5, { truncIndicator: '...' });\n    expect(res).toBe('abcde...');\n  });\n});\n"},{"name":"trim","manifest":{"fnSignature":"trim(str, toRemove?)","summaryHtml":"<p>Trims characters from both ends of the string <code>str</code> that are found in the string <code>toRemove</code>.</p>"},"descriptionHtml":"","src":"function trim(str, toRemove = ' \\t\\n') {\n  const chars = str.split('');\n  while (chars.length && toRemove.includes(chars[0])) chars.shift();\n  while (chars.length && toRemove.includes(chars.at(-1))) chars.pop();\n  return chars.join('');\n}","test":"function trim(str, toRemove = ' \\t\\n') {\n  const chars = str.split('');\n  while (chars.length && toRemove.includes(chars[0])) chars.shift();\n  while (chars.length && toRemove.includes(chars.at(-1))) chars.pop();\n  return chars.join('');\n}\n\ndescribe('trim()', () => {\n  it('trims characters from both sides', () => {\n    const res = trim(' \\t\\n abc  ');\n    expect(res).toEqual('abc');\n  });\n\n  it('can trim down to an empty string', () => {\n    const res = trim('  \\n\\t ');\n    expect(res).toEqual('');\n  });\n\n  it(\"does not trim when there's nothing to trim\", () => {\n    const res = trim('abc');\n    expect(res).toEqual('abc');\n  });\n\n  it('can use custom trim characters', () => {\n    const res = trim('XYabcXYX', 'XY');\n    expect(res).toEqual('abc');\n  });\n\n  it(\"won't trim anything if an empty string is provided for the trim characters\", () => {\n    const res = trim(' abc ', '');\n    expect(res).toEqual(' abc ');\n  });\n});\n"},{"name":"trimLeft","manifest":{"fnSignature":"trimLeft(str, toRemove?)","summaryHtml":"<p>Trims characters from the left end of the string <code>str</code> that are found in the string <code>toRemove</code>.</p>"},"descriptionHtml":"","src":"function trimLeft(str, toRemove = ' \\t\\n') {\n  const leftBound = str.split('').findIndex(c => !toRemove.includes(c));\n  return leftBound === -1 ? '' : str.slice(leftBound);\n}","test":"function trimLeft(str, toRemove = ' \\t\\n') {\n  const leftBound = str.split('').findIndex(c => !toRemove.includes(c));\n  return leftBound === -1 ? '' : str.slice(leftBound);\n}\n\ndescribe('trimLeft()', () => {\n  it('trims characters from the left', () => {\n    const res = trimLeft(' \\t\\n abc  ');\n    expect(res).toEqual('abc  ');\n  });\n\n  it('can trim down to an empty string', () => {\n    const res = trimLeft('  \\n\\t ');\n    expect(res).toEqual('');\n  });\n\n  it(\"does not trim when there's nothing to trim\", () => {\n    const res = trimLeft('abc ');\n    expect(res).toEqual('abc ');\n  });\n\n  it('can use custom trim characters', () => {\n    const res = trimLeft('YXabcXYX', 'XY');\n    expect(res).toEqual('abcXYX');\n  });\n\n  it(\"won't trim anything if an empty string is provided for the trim characters\", () => {\n    const res = trimLeft(' abc ', '');\n    expect(res).toEqual(' abc ');\n  });\n});\n"},{"name":"trimRight","manifest":{"fnSignature":"trimRight(str, toRemove?)","summaryHtml":"<p>Trims characters from the right end of the string <code>str</code> that are found in the string <code>toRemove</code>.</p>"},"descriptionHtml":"","src":"function trimRight(str, toRemove = ' \\t\\n') {\n  const chars = str.split('');\n  while (chars.length && toRemove.includes(chars[chars.length - 1])) {\n    chars.pop();\n  }\n  return chars.join('');\n}","test":"function trimRight(str, toRemove = ' \\t\\n') {\n  const chars = str.split('');\n  while (chars.length && toRemove.includes(chars[chars.length - 1])) {\n    chars.pop();\n  }\n  return chars.join('');\n}\n\ndescribe('trimRight()', () => {\n  it('trims characters from the right', () => {\n    const res = trimRight(' \\t\\n abc  ');\n    expect(res).toEqual(' \\t\\n abc');\n  });\n\n  it('can trim down to an empty string', () => {\n    const res = trimRight('  \\n\\t ');\n    expect(res).toEqual('');\n  });\n\n  it(\"does not trim when there's nothing to trim\", () => {\n    const res = trimRight(' abc');\n    expect(res).toEqual(' abc');\n  });\n\n  it('can use custom trim characters', () => {\n    const res = trimRight('YXabcXYX', 'XY');\n    expect(res).toEqual('YXabc');\n  });\n\n  it(\"won't trim anything if an empty string is provided for the trim characters\", () => {\n    const res = trimRight(' abc ', '');\n    expect(res).toEqual(' abc ');\n  });\n});\n"},{"name":"memoize","manifest":{"fnSignature":"memoize(fn, options?)","summaryHtml":"<p>Returns a memoized version of <code>fn</code>. The results of calling the returned function gets cached, so when it's called again with the same arguments, the cached result will be returned.</p>"},"descriptionHtml":"","src":"function memoize(fn, { argsToKey = null } = {}) {\n  argsToKey = argsToKey ?? ((...args) => {\n    if (args.length !== 1) {\n      throw new Error(\n        'Exactly one argument must be passed in to this memoized function ' +\n        '(unless a custom args-to-key mapper is provided)',\n      );\n    }\n    return args[0];\n  });\n\n  const cache = new Map();\n  return (...args) => {\n    const key = argsToKey(...args);\n    if (cache.has(key)) return cache.get(key);\n\n    const res = fn(...args);\n    cache.set(key, res);\n    return res;\n  };\n}","test":"function memoize(fn, { argsToKey = null } = {}) {\n  argsToKey = argsToKey ?? ((...args) => {\n    if (args.length !== 1) {\n      throw new Error(\n        'Exactly one argument must be passed in to this memoized function ' +\n        '(unless a custom args-to-key mapper is provided)',\n      );\n    }\n    return args[0];\n  });\n\n  const cache = new Map();\n  return (...args) => {\n    const key = argsToKey(...args);\n    if (cache.has(key)) return cache.get(key);\n\n    const res = fn(...args);\n    cache.set(key, res);\n    return res;\n  };\n}\n\ndescribe('memoize()', () => {\n  it('caches the result of the function call', () => {\n    const originalFn = jest.fn(x => x + 1);\n    const memoizedFn = memoize(originalFn);\n\n    expect(memoizedFn(5)).toBe(6);\n    originalFn.mockReturnValue(null);\n    expect(memoizedFn(5)).toBe(6);\n  });\n\n  it('caches the promise when the callback is async', async () => {\n    const originalFn = jest.fn(async x => x + 1);\n    const memoizedFn = memoize(originalFn);\n\n    const promise1 = memoizedFn(5).then(x => expect(x).toBe(6));\n    originalFn.mockReturnValue(43);\n    const promise2 = memoizedFn(5).then(x => expect(x).toBe(6));\n\n    await Promise.all([promise1, promise2]);\n  });\n\n  it('can cache multiple items', () => {\n    const originalFn = jest.fn(x => x + 1);\n    const memoizedFn = memoize(originalFn);\n\n    expect(memoizedFn(5)).toBe(6);\n    expect(memoizedFn(6)).toBe(7);\n    originalFn.mockReturnValue(null);\n    expect(memoizedFn(5)).toBe(6);\n    expect(memoizedFn(6)).toBe(7);\n  });\n\n  it('does not allow 0 arguments when the default comparison function is used', () => {\n    const memoizedFn = memoize(() => {});\n    expect(() => memoizedFn()).toThrow();\n  });\n\n  it('does not allow multiple arguments when the default comparison function is used', () => {\n    const memoizedFn = memoize(() => {});\n    expect(() => memoizedFn(1, 2)).toThrow();\n  });\n\n  it('accepts a custom comparison function', () => {\n    const originalFn = jest.fn((x, y) => x * y);\n    const memoizedFn = memoize(originalFn, { argsToKey: (x, y) => x + y });\n\n    expect(memoizedFn(2, 3)).toBe(6);\n    originalFn.mockReturnValue(null);\n    expect(memoizedFn(4, 1)).toBe(6);\n  });\n});\n"},{"name":"randomInt","manifest":{"fnSignature":"randomInt(min, max)","summaryHtml":"<p>Returns a random integer between <code>min</code> and <code>max</code> (but not including <code>max</code>).</p>"},"descriptionHtml":"","src":"function randomInt(min, max) {\n  return min + Math.floor(Math.random() * (max - min));\n}","test":"function randomInt(min, max) {\n  return min + Math.floor(Math.random() * (max - min));\n}\n\ndescribe('randomInt()', () => {\n  const TEST_REPETITIONS = 50;\n\n  it('returns a number within the bounds', () => {\n    for (let i = 0; i < TEST_REPETITIONS; ++i) {\n      const result = randomInt(5, 10);\n      expect(result).toBeGreaterThanOrEqual(5);\n      expect(result).toBeLessThan(10);\n    }\n  });\n\n  it('returns a whole number', () => {\n    for (let i = 0; i < TEST_REPETITIONS; ++i) {\n      const result = randomInt(5, 10);\n      expect(Math.round(result)).toBe(result);\n    }\n  });\n});\n"},{"name":"randomChoice","manifest":{"fnSignature":"randomChoice(array)","summaryHtml":"<p>Returns a random element from <code>array</code>.</p>"},"descriptionHtml":"","src":"function randomChoice(array) {\n  return array[Math.floor(Math.random() * array.length)];\n}","test":"function randomChoice(array) {\n  return array[Math.floor(Math.random() * array.length)];\n}\n\ndescribe('randomChoice()', () => {\n  const TEST_REPETITIONS = 10;\n\n  it('returns an element from the original array', () => {\n    for (let i = 0; i < TEST_REPETITIONS; ++i) {\n      const array = ['a', 'b', 'c', 'd', 'e'];\n      expect(array).toContain(randomChoice(array));\n    }\n  });\n});\n"},{"name":"shuffle","manifest":{"fnSignature":"shuffle(array)","summaryHtml":"<p>Returns a copy of <code>array</code> that has been shuffled.</p>"},"descriptionHtml":"","src":"function shuffle(array) {\n  return array\n    .map(value => ({ value, sortKey: Math.random() }))\n    .sort((a, b) => a.sortKey - b.sortKey)\n    .map(({ value }) => value);\n}","test":"function shuffle(array) {\n  return array\n    .map(value => ({ value, sortKey: Math.random() }))\n    .sort((a, b) => a.sortKey - b.sortKey)\n    .map(({ value }) => value);\n}\n\ndescribe('shuffle()', () => {\n  const TEST_REPETITIONS = 10;\n\n  it('returns an array with entries that are all in the original array', () => {\n    for (let i = 0; i < TEST_REPETITIONS; ++i) {\n      const originalArray = ['a', 'b', 'c', 'd', 'e'];\n      const result = shuffle(originalArray);\n      for (const entry of result) {\n        expect(originalArray).toContain(entry);\n      }\n    }\n  });\n\n  it('returns an array where all entries of the original array are found in the returned one', () => {\n    for (let i = 0; i < TEST_REPETITIONS; ++i) {\n      const originalArray = ['a', 'b', 'c', 'd', 'e'];\n      const result = shuffle(originalArray);\n      for (const entry of originalArray) {\n        expect(result).toContain(entry);\n      }\n    }\n  });\n});\n"}],"hidden":true},{"categoryHeading":"HTML-Building Helpers","entries":[{"name":"el","manifest":{"fnSignature":"el(tagName, attrs?, children?)","summaryHtml":"<p>Creates an HTML element.</p>"},"descriptionHtml":"<h2>Parameters</h2>\n<ul>\n<li><p><code>tagName</code></p>\n<p>The new element's tag</p></li>\n<li><p><code>attrs</code></p>\n<p>A mapping of attribute names to values</p></li>\n<li><p><code>children</code></p>\n<p>A list of child nodes. A child can either be a string or an HTML element (e.g. one generated by el()).</p></li>\n</ul>\n<h2>Examples</h2>\n<pre><code class=\"javascript language-javascript\">el('div', { id: 'my-div' }, [\n  el('span', {}, ['Hello']),\n  'World!',\n])\n\n/* The above results in the following HTML structure\n&lt;div id=\"my-div\"&gt;\n  &lt;span&gt;Hello&lt;/span&gt;\n  World!\n&lt;/div&gt;\n*/\n</code></pre>\n<h2>Additional Information</h2>\n<p><code>el()</code> can be useful for quick-and-dirty HTML-building, but it won't help you write code that automatically reacts to state changes. If you need that level of reactivity, consider reaching for a proper framework instead. If you need something lightweight and transparent, consider using <a href=\"#!/framework\">the Snap Framework</a>, otherwise, there's plenty of other frameworks out there to choose from.</p>","src":"function el(tagName, attrs = {}, children = []) {\n  const newElement = document.createElement(tagName);\n  for (const [key, value] of Object.entries(attrs)) {\n    newElement.setAttribute(key, value);\n  }\n  newElement.append(...children);\n  return newElement;\n}","test":""},{"name":"fragment","manifest":{"fnSignature":"fragment(children?)","summaryHtml":"<p>Creates an HTML fragment.</p>"},"descriptionHtml":"<h2>Parameters</h2>\n<ul>\n<li><p><code>...children</code></p>\n<p>A list of child nodes. A child can either be a string or an HTML element (e.g. one generated by el()).</p></li>\n</ul>\n<h2>Examples</h2>\n<pre><code class=\"javascript language-javascript\">fragment([\n  // Using the el() snap.js function in this example.\n  el('span', {}, ['Hello']),\n  'World!',\n])\n\n/* The above results in the following HTML structure\n&lt;span&gt;Hello&lt;/span&gt;\nWorld!\n*/\n</code></pre>","src":"function fragment(children = []) {\n  const newFragment = new DocumentFragment();\n  newFragment.append(...children);\n  return newFragment;\n}","test":""}]},{"categoryHeading":"Miscellaneous Helpers","entries":[{"name":"addToDate","manifest":{"fnSignature":"addToDate(date, offset)","summaryHtml":"<p>Returns a new date with year/month/day offsets added the <code>date</code></p>"},"descriptionHtml":"","src":"function addToDate(date_, offset) {\n  const {\n    years = 0,\n    months = 0,\n    days = 0,\n    hours = 0,\n    minutes = 0,\n    seconds = 0,\n    ms = 0,\n  } = offset;\n\n  const date = new Date(date_.valueOf());\n  date.setFullYear(date.getFullYear() + years);\n  date.setMonth(date.getMonth() + months);\n  date.setDate(date.getDate() + days);\n  date.setHours(date.getHours() + hours);\n  date.setMinutes(date.getMinutes() + minutes);\n  date.setSeconds(date.getSeconds() + seconds);\n  date.setMilliseconds(date.getMilliseconds() + ms);\n  return date;\n}","test":"function addToDate(date_, offset) {\n  const {\n    years = 0,\n    months = 0,\n    days = 0,\n    hours = 0,\n    minutes = 0,\n    seconds = 0,\n    ms = 0,\n  } = offset;\n\n  const date = new Date(date_.valueOf());\n  date.setFullYear(date.getFullYear() + years);\n  date.setMonth(date.getMonth() + months);\n  date.setDate(date.getDate() + days);\n  date.setHours(date.getHours() + hours);\n  date.setMinutes(date.getMinutes() + minutes);\n  date.setSeconds(date.getSeconds() + seconds);\n  date.setMilliseconds(date.getMilliseconds() + ms);\n  return date;\n}\n\ndescribe('addToDate()', () => {\n  it('should be able to add years to the date', () => {\n    const oldDate = new Date(2000, 5, 3);\n    const newDate = addToDate(oldDate, { years: 2 });\n    expect(newDate.toString()).toBe(new Date(2002, 5, 3).toString());\n  });\n\n  it('should be able to add months to the date, and have it wrap to a new year', () => {\n    const oldDate = new Date(2000, 10, 3);\n    const newDate = addToDate(oldDate, { months: 3 });\n    expect(newDate.toString()).toBe(new Date(2001, 1, 3).toString());\n  });\n\n  it('should be able to add days to the date, and have it wrap to a new year', () => {\n    const oldDate = new Date(2000, 11, 29);\n    const newDate = addToDate(oldDate, { days: 4 });\n    expect(newDate.toString()).toBe(new Date(2001, 0, 2).toString());\n  });\n\n  it('should be able to add hours to the date, and have it wrap to a new year', () => {\n    const oldDate = new Date(2000, 11, 31, 23);\n    const newDate = addToDate(oldDate, { hours: 2 });\n    expect(newDate.toString()).toBe(new Date(2001, 0, 1, 1).toString());\n  });\n\n  it('should be able to add minutes to the date, and have it wrap to a new year', () => {\n    const oldDate = new Date(2000, 11, 31, 24, 59);\n    const newDate = addToDate(oldDate, { minutes: 2 });\n    expect(newDate.toString()).toBe(new Date(2001, 0, 1, 1, 1).toString());\n  });\n\n  it('should be able to add seconds to the date, and have it wrap to a new year', () => {\n    const oldDate = new Date(2000, 11, 31, 24, 59, 59);\n    const newDate = addToDate(oldDate, { seconds: 2 });\n    expect(newDate.toString()).toBe(new Date(2001, 0, 1, 1, 0, 1).toString());\n  });\n\n  it('should be able to add milliseconds to the date, and have it wrap to a new year', () => {\n    const oldDate = new Date(2000, 11, 31, 24, 59, 59, 999);\n    const newDate = addToDate(oldDate, { ms: 2 });\n    expect(newDate.toString()).toBe(\n      new Date(2001, 0, 1, 1, 0, 0, 1).toString(),\n    );\n  });\n\n  it('should be able to update all attributes at the same time.', () => {\n    const oldDate = new Date(2000, 1, 2, 3, 4, 5, 6, 7);\n    const newDate = addToDate(oldDate, {\n      years: 1,\n      months: 2,\n      days: 3,\n      hours: 4,\n      minutes: 5,\n      seconds: 6,\n      ms: 7,\n    });\n    expect(newDate.toString()).toBe(\n      new Date(2001, 3, 5, 7, 9, 11, 13, 15).toString(),\n    );\n  });\n\n  it('should support negative deltas', () => {\n    const oldDate = new Date(2001, 3, 5, 7, 9, 11, 13, 15);\n    const newDate = addToDate(oldDate, {\n      years: -1,\n      months: -2,\n      days: -3,\n      hours: -4,\n      minutes: -5,\n      seconds: -6,\n      ms: -7,\n    });\n    expect(newDate.toString()).toBe(\n      new Date(2000, 1, 2, 3, 4, 5, 6, 7).toString(),\n    );\n  });\n});\n"},{"name":"createEventEmitter","manifest":{"fnSignature":"createEventEmitter()","summaryHtml":"<p>Creates a simple eventEmitter instance to aid with the pub-sub pattern of subscribing to events and notifying subscribers.</p>"},"descriptionHtml":"","src":"function createEventEmitter() {\n  const listeners = [];\n  return {\n    subscribe(fn) {\n      listeners.push(fn);\n      let unsubscribed = false;\n      return function unsubscribe() {\n        if (unsubscribed) return;\n        const index = listeners.indexOf(fn);\n        listeners.splice(index, 1);\n        unsubscribed = true;\n      };\n    },\n    trigger(...args) {\n      return listeners.map(fn => fn(...args));\n    },\n  };\n}","test":"function createEventEmitter() {\n  const listeners = [];\n  return {\n    subscribe(fn) {\n      listeners.push(fn);\n      let unsubscribed = false;\n      return function unsubscribe() {\n        if (unsubscribed) return;\n        const index = listeners.indexOf(fn);\n        listeners.splice(index, 1);\n        unsubscribed = true;\n      };\n    },\n    trigger(...args) {\n      return listeners.map(fn => fn(...args));\n    },\n  };\n}\n\ndescribe('createEventEmitter()', () => {\n  it('triggers subscribed events with arguments', () => {\n    const event = createEventEmitter();\n    const spy1 = jest.fn();\n    event.subscribe(spy1);\n    const spy2 = jest.fn();\n    event.subscribe(spy2);\n\n    event.trigger(1, 2);\n    expect(spy1).toHaveBeenCalledWith(1, 2);\n    expect(spy2).toHaveBeenCalledWith(1, 2);\n  });\n\n  it('returns the results of the subscribed functions', () => {\n    const event = createEventEmitter();\n    event.subscribe(() => 2);\n    event.subscribe(() => 3);\n\n    const res = event.trigger();\n    expect(res).toEqual([2, 3]);\n  });\n\n  it('is capable of having async subscribers', async () => {\n    const event = createEventEmitter();\n    event.subscribe(async () => 2);\n    event.subscribe(async () => 3);\n\n    const res = await Promise.all(event.trigger());\n    expect(res).toEqual([2, 3]);\n  });\n\n  it('is capable of being triggered multiple times, with new subscribers', () => {\n    const event = createEventEmitter();\n    expect(event.trigger()).toEqual([]);\n\n    event.subscribe(() => 1);\n    expect(event.trigger()).toEqual([1]);\n\n    event.subscribe(() => 2);\n    expect(event.trigger()).toEqual([1, 2]);\n  });\n\n  it('allows unsubscribing', () => {\n    const event = createEventEmitter();\n\n    const unsubscribe = event.subscribe(() => 1);\n    event.subscribe(() => 2);\n    unsubscribe();\n    expect(event.trigger()).toEqual([2]);\n  });\n\n  it('allows repeated calls to unsubscribe', () => {\n    const event = createEventEmitter();\n\n    const unsubscribe = event.subscribe(() => 1);\n    event.subscribe(() => 2);\n    unsubscribe();\n    unsubscribe();\n    expect(event.trigger()).toEqual([2]);\n  });\n\n  it('can unsubscribe the correct function, even if the function identity does not change', () => {\n    // Tested by unsubscribing multiple times, but only expecting one unsubscribe to happen\n    const fn = () => 2;\n\n    const event = createEventEmitter();\n    const unsubscribe = event.subscribe(fn);\n    event.subscribe(fn);\n    unsubscribe();\n    unsubscribe();\n    expect(event.trigger()).toEqual([2]);\n  });\n});\n"},{"name":"pipe","manifest":{"fnSignature":"pipe(value, ...fns)","summaryHtml":"<p>Pipes a value through a series of functions.</p>"},"descriptionHtml":"<h1>Examples</h1>\n<pre><code class=\"javascript language-javascript\">// Outputs 22\npipe(\n  42,\n  x =&gt; x / 2,\n  x =&gt; x + 1,\n);\n</code></pre>\n<p>For those who like <a href=\"https://en.wikipedia.org/wiki/Tacit_programming\">point-free programming</a>, the pipe function is an indispensable tool to help achieve it.</p>\n<p>Even if you aren't into point-free programming, a pipe function is still handy to have, as it allows you to interject your own helper functions into the middle of what normally is a fluent API, and still get the nice non-nested benefit of a fluent API. For example:</p>\n<pre><code class=\"javascript language-javascript\">function popped(array) {\n  const newArray = [...array];\n  newArray.pop();\n  return newArray;\n}\n\n// Outputs [2, 4]\npipe(\n  [1, 2, 3],\n  popped,\n  arr =&gt; arr.map(x =&gt; x * 2),\n);\n</code></pre>","src":"function pipe(value, ...fns) {\n  for (const fn of fns) {\n    value = fn(value);\n  }\n  return value;\n}","test":""}]}]