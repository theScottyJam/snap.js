[{"categoryHeading":"Object Helpers","entries":[{"name":"mapKeys","manifest":{"fnSignature":"mapKeys(obj, fn)","summary":"Constructs a new object where each key in `obj` has been mapped by `fn` to a new key."},"description":"# Parameters\n\n- `obj`\n\n  The object to be processed\n\n- `fn`\n\n  A callback that will be called with each key in the object. This function should return a transformed key that will be used to construct the new object. The callback accepts the following parameters:\n\n  - `key`: The current key to transform.\n\n# Examples\n\n```\n> mapKeys({ key1: 2, key2: 3 }, k => `prefix_${k}`)\n{ prefix_key1: 2, prefix_key2: 3 }\n```\n\n# Additional Information\n\nAny attributes in `obj`'s prototype will be ignored.\n","src":"function mapKeys(obj, fn) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    newObj[fn(key)] = value;\n  }\n  return newObj;\n}","test":"describe('mapKeys()', () => {\n  it('maps keys in objects', () => {\n    const oldObj = { a: 2, b: 3 };\n    const newObj = _.mapKeys(oldObj, k => k + k);\n    expect(newObj).toEqual({ aa: 2, bb: 3 });\n  });\n\n  it('only maps own (non-inherited) values', () => {\n    class MyClass {\n      x = 2;\n      f() {}\n    }\n\n    const oldObj = new MyClass();\n    const newObj = _.mapKeys(oldObj, k => k + k);\n    expect(newObj).toEqual({ xx: 2 });\n  });\n});\n"},{"name":"mapValues","manifest":{"fnSignature":"mapValues(obj, fn)","summary":"Constructs a new object where each value in `obj` has been mapped by `fn` to a new value."},"description":"# Parameters\n\n- `obj`\n\n  The object to be processed\n\n- `fn`\n\n  A callback that will be called with each value in the object. This function should return a transformed value that will be used to construct the new object. The callback accepts the following parameters:\n\n  - `value`: The current value to transform.\n\n# Examples\n\n```\n> mapValues({ a: 2, b: 3 }, x => x**2)\n{ a: 4, b: 9 }\n```\n\n# Additional Information\n\nAny attributes in `obj`'s prototype will be ignored.\n","src":"function mapValues(obj, fn) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    newObj[key] = fn(value);\n  }\n  return newObj;\n}","test":"describe('mapValues()', () => {\n  it('maps values in objects', () => {\n    const oldObj = { a: 2, b: 3 };\n    const newObj = _.mapValues(oldObj, x => x + 1);\n    expect(newObj).toEqual({ a: 3, b: 4 });\n  });\n\n  it('only maps own (non-inherited) values', () => {\n    class MyClass {\n      x = 2;\n      f() {}\n    }\n\n    const oldObj = new MyClass();\n    const newObj = _.mapValues(oldObj, x => x + 1);\n    expect(newObj).toEqual({ x: 3 });\n  });\n});\n"},{"name":"invert","manifest":{"fnSignature":"invert(obj)","summary":"Constructs a new object that maps `obj`'s values to its keys."},"description":"# Parameters\n\n- `obj`\n\n  The object to invert.\n\n# Examples\n\n```\n> invert({ five: '5', six: '6' })\n{ 5: \"five\", 6: \"six\" }\n```\n\n# Additional Information\n\nAny attributes in `obj`'s prototype will be ignored.\n","src":"function invert(obj) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    newObj[value] = key;\n  }\n  return newObj;\n}","test":"describe('invert()', () => {\n  it('inverts keys and values of an object', () => {\n    const oldObj = { a: 2, b: 3 };\n    const newObj = _.invert(oldObj);\n    expect(newObj).toEqual({ 2: 'a', 3: 'b' });\n  });\n\n  it('only maps own (non-inherited) values', () => {\n    class MyClass {\n      x = 2;\n      f() {}\n    }\n\n    const oldObj = new MyClass();\n    const newObj = _.invert(oldObj);\n    expect(newObj).toEqual({ 2: 'x' });\n  });\n});\n"}]},{"categoryHeading":"Array Helpers","entries":[{"name":"intersection","manifest":{"fnSignature":"intersection(array1, array2)","summary":"Returns an array of elements that exist in both `array1` and `array2`"},"description":"","src":"function intersection(array1, array2) {\n  return array1.filter(x => array2.includes(x));\n}","test":"describe('intersection()', () => {\n  it('finds common elements in the arrays', () => {\n    expect(_.intersection(['a', 'b', 'c'], ['b', 'c', 'd'])).toEqual([\n      'b',\n      'c',\n    ]);\n  });\n\n  it('returns an empty array when no common elements exist', () => {\n    expect(_.intersection(['x'], ['y'])).toEqual([]);\n  });\n\n  it('returns an empty array when input arrays are empty', () => {\n    expect(_.intersection([], [])).toEqual([]);\n  });\n});\n"},{"name":"difference","manifest":{"fnSignature":"difference(array1, array2)","summary":"Returns an array of elements that are in `array1` but not in `array2`."},"description":"","src":"function difference(array1, array2) {\n  return array1.filter(x => !array2.includes(x));\n}","test":"describe('difference()', () => {\n  it('calculates the difference of two arrays', () => {\n    expect(_.difference(['a', 'b', 'c'], ['c', 'd'])).toEqual(['a', 'b']);\n  });\n\n  it('returns an empty array when all elements are removed', () => {\n    expect(_.difference(['x'], ['x', 'y'])).toEqual([]);\n  });\n\n  it('returns an empty array when input arrays are empty', () => {\n    expect(_.difference([], [])).toEqual([]);\n  });\n});\n"},{"name":"zip","manifest":{"fnSignature":"zip(...arrays)","summary":"Allows iterating over multiple arrays at the same time."},"description":"","src":"function* zip(...arrays) {\n  if (arrays.length === 0) return;\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  for (let i = 0; i < minLength; ++i) {\n    yield arrays.map(arr => arr[i]);\n  }\n}","test":"describe('zip()', () => {\n  const range = (start, stop) =>\n    Array.from({ length: stop - start }, (_, i) => i + start);\n\n  it('zips up arrays', () => {\n    const zipped = [..._.zip(range(0, 3), range(3, 6))];\n    expect(zipped).toEqual([\n      [0, 3],\n      [1, 4],\n      [2, 5],\n    ]);\n  });\n\n  it('discards elements from longer arrays', () => {\n    const zipped = [..._.zip(range(0, 3), range(3, 9))];\n    expect(zipped).toEqual([\n      [0, 3],\n      [1, 4],\n      [2, 5],\n    ]);\n  });\n\n  it('zips up three arrays', () => {\n    const zipped = [..._.zip([1, 4], [2, 5], [3, 6])];\n    expect(zipped).toEqual([\n      [1, 2, 3],\n      [4, 5, 6],\n    ]);\n  });\n\n  it('zips up a single arrays', () => {\n    const zipped = [..._.zip([1, 2, 3])];\n    expect(zipped).toEqual([[1], [2], [3]]);\n  });\n\n  it('zips up no arrays', () => {\n    const zipped = [..._.zip()];\n    expect(zipped).toEqual([]);\n  });\n\n  it('zips up empty arrays', () => {\n    const zipped = [..._.zip([], [])];\n    expect(zipped).toEqual([]);\n  });\n});\n"}]},{"categoryHeading":"String Helpers","entries":[{"name":"truncate","manifest":{"fnSignature":"truncate(str, maxSize, options?)","summary":"Truncates `str` and append an ellipse when it's length exceeds `maxSize`"},"description":"","src":"function truncate(str, maxSize, { truncIndicator = '…' } = {}) {\n  if (str.length <= maxSize) return str;\n  return str.slice(0, maxSize) + truncIndicator;\n}","test":"describe('truncate()', () => {\n  it('does not modify a string within the size limit', () => {\n    const res = _.truncate('abcde', 5);\n    expect(res).toBe('abcde');\n  });\n\n  it('truncates strings that are too large', () => {\n    const res = _.truncate('abcdef', 5);\n    expect(res).toBe('abcde…');\n  });\n\n  it('allows truncate indicator to be customized', () => {\n    const res = _.truncate('abcdef', 5, { truncIndicator: '...' });\n    expect(res).toBe('abcde...');\n  });\n});\n"},{"name":"trim","manifest":{"fnSignature":"trim(str, toRemove?)","summary":"Trims characters from both ends of the string `str` that are found in the string `toRemove`."},"description":"","src":"function trim(str, toRemove = ' \\t\\n') {\n  const chars = str.split('');\n  while (chars.length && toRemove.includes(chars[0])) chars.shift();\n  while (chars.length && toRemove.includes(chars.at(-1))) chars.pop();\n  return chars.join('');\n}","test":"describe('trim()', () => {\n  it('trims characters from both sides', () => {\n    const res = _.trim(' \\t\\n abc  ');\n    expect(res).toEqual('abc');\n  });\n\n  it('can trim down to an empty string', () => {\n    const res = _.trim('  \\n\\t ');\n    expect(res).toEqual('');\n  });\n\n  it(\"does not trim when there's nothing to trim\", () => {\n    const res = _.trim('abc');\n    expect(res).toEqual('abc');\n  });\n\n  it('can use custom trim characters', () => {\n    const res = _.trim('XYabcXYX', 'XY');\n    expect(res).toEqual('abc');\n  });\n\n  it(\"won't trim anything if an empty string is provided for the trim characters\", () => {\n    const res = _.trim(' abc ', '');\n    expect(res).toEqual(' abc ');\n  });\n});\n"},{"name":"trimLeft","manifest":{"fnSignature":"trimLeft(str, toRemove?)","summary":"Trims characters from the left end of the string `str` that are found in the string `toRemove`."},"description":"","src":"function trimLeft(str, toRemove = ' \\t\\n') {\n  const leftBound = str.split('').findIndex(c => !toRemove.includes(c));\n  return leftBound === -1 ? '' : str.slice(leftBound);\n}","test":"describe('trimLeft()', () => {\n  it('trims characters from the left', () => {\n    const res = _.trimLeft(' \\t\\n abc  ');\n    expect(res).toEqual('abc  ');\n  });\n\n  it('can trim down to an empty string', () => {\n    const res = _.trimLeft('  \\n\\t ');\n    expect(res).toEqual('');\n  });\n\n  it(\"does not trim when there's nothing to trim\", () => {\n    const res = _.trimLeft('abc ');\n    expect(res).toEqual('abc ');\n  });\n\n  it('can use custom trim characters', () => {\n    const res = _.trimLeft('YXabcXYX', 'XY');\n    expect(res).toEqual('abcXYX');\n  });\n\n  it(\"won't trim anything if an empty string is provided for the trim characters\", () => {\n    const res = _.trimLeft(' abc ', '');\n    expect(res).toEqual(' abc ');\n  });\n});\n"},{"name":"trimRight","manifest":{"fnSignature":"trimRight(str, toRemove?)","summary":"Trims characters from the right end of the string `str` that are found in the string `toRemove`."},"description":"","src":"function trimRight(str, toRemove = ' \\t\\n') {\n  const chars = str.split('');\n  while (chars.length && toRemove.includes(chars[chars.length - 1])) {\n    chars.pop();\n  }\n  return chars.join('');\n}","test":"describe('trimRight()', () => {\n  it('trims characters from the right', () => {\n    const res = _.trimRight(' \\t\\n abc  ');\n    expect(res).toEqual(' \\t\\n abc');\n  });\n\n  it('can trim down to an empty string', () => {\n    const res = _.trimRight('  \\n\\t ');\n    expect(res).toEqual('');\n  });\n\n  it(\"does not trim when there's nothing to trim\", () => {\n    const res = _.trimRight(' abc');\n    expect(res).toEqual(' abc');\n  });\n\n  it('can use custom trim characters', () => {\n    const res = _.trimRight('YXabcXYX', 'XY');\n    expect(res).toEqual('YXabc');\n  });\n\n  it(\"won't trim anything if an empty string is provided for the trim characters\", () => {\n    const res = _.trimRight(' abc ', '');\n    expect(res).toEqual(' abc ');\n  });\n});\n"}]},{"categoryHeading":"Function Helpers","entries":[{"name":"memoize","manifest":{"fnSignature":"memoize(fn, options?)","summary":"Returns a memoized version of `fn`. The results of calling the returned function gets cached, so when it's called again with the same arguments, the cached result will be returned."},"description":"","src":"function memoize(fn, { argsToKey = null } = {}) {\n  argsToKey =\n    argsToKey ??\n    ((...args) => {\n      if (args.length !== 1) {\n        throw new Error(\n          'Exactly one argument must be passed in to this memoized function ' +\n            '(unless a custom args-to-key mapper is provided)'\n        );\n      }\n      return args[0];\n    });\n\n  const cache = new Map();\n  return (...args) => {\n    const key = argsToKey(...args);\n    if (cache.has(key)) return cache.get(key);\n\n    const res = fn(...args);\n    cache.set(key, res);\n    return res;\n  };\n}","test":"describe('memoize()', () => {\n  it('caches the result of the function call', () => {\n    const originalFn = jest.fn(x => x + 1);\n    const memoizedFn = _.memoize(originalFn);\n\n    expect(memoizedFn(5)).toBe(6);\n    originalFn.mockReturnValue(null);\n    expect(memoizedFn(5)).toBe(6);\n  });\n\n  it('caches the promise when the callback is async', async () => {\n    const originalFn = jest.fn(async x => x + 1);\n    const memoizedFn = _.memoize(originalFn);\n\n    const promise1 = memoizedFn(5).then(x => expect(x).toBe(6));\n    originalFn.mockReturnValue(43);\n    const promise2 = memoizedFn(5).then(x => expect(x).toBe(6));\n\n    await Promise.all([promise1, promise2]);\n  });\n\n  it('can cache multiple items', () => {\n    const originalFn = jest.fn(x => x + 1);\n    const memoizedFn = _.memoize(originalFn);\n\n    expect(memoizedFn(5)).toBe(6);\n    expect(memoizedFn(6)).toBe(7);\n    originalFn.mockReturnValue(null);\n    expect(memoizedFn(5)).toBe(6);\n    expect(memoizedFn(6)).toBe(7);\n  });\n\n  it('does not allow 0 arguments when the default comparison function is used', () => {\n    const memoizedFn = _.memoize(() => {});\n    expect(() => memoizedFn()).toThrow();\n  });\n\n  it('does not allow multiple arguments when the default comparison function is used', () => {\n    const memoizedFn = _.memoize(() => {});\n    expect(() => memoizedFn(1, 2)).toThrow();\n  });\n\n  it('accepts a custom comparison function', () => {\n    const originalFn = jest.fn((x, y) => x * y);\n    const memoizedFn = _.memoize(originalFn, { argsToKey: (x, y) => x + y });\n\n    expect(memoizedFn(2, 3)).toBe(6);\n    originalFn.mockReturnValue(null);\n    expect(memoizedFn(4, 1)).toBe(6);\n  });\n});\n"},{"name":"pipe","manifest":{"fnSignature":"pipe(value, ...fns)","summary":"Pipes a value through a series of functions."},"description":"# Examples\n\n```javascript\n// Outputs 22\npipe(\n  42,\n  x => x / 2,\n  x => x + 1,\n);\n```\n\nFor those who like [point-free programming](https://en.wikipedia.org/wiki/Tacit_programming), the pipe function is an indispensable tool to help achieve it.\n\nEven if you aren't into point-free programming, a pipe function is still handy to have, as it allows you to interject your own helper functions into the middle of what normally is a fluent API, and still get the nice non-nested benefit of a fluent API. For example:\n\n```javascript\nfunction popped(array) {\n  const newArray = [...array];\n  newArray.pop();\n  return newArray;\n}\n\n// Outputs [2, 4]\npipe(\n  [1, 2, 3],\n  popped,\n  arr => arr.map(x => x * 2),\n);\n```","src":"function pipe(value, ...fns) {\n  for (const fn of fns) {\n    value = fn(value);\n  }\n  return value;\n}","test":""}]},{"categoryHeading":"Helper Functions for Randomness","entries":[{"name":"randomInt","manifest":{"fnSignature":"randomInt(min, max)","summary":"Returns a random integer between `min` and `max` (but not including `max`)."},"description":"","src":"function randomInt(min, max) {\n  return min + Math.floor(Math.random() * (max - min));\n}","test":"describe('randomInt()', () => {\n  const TEST_REPETITIONS = 50;\n\n  it('returns a number within the bounds', () => {\n    for (let i = 0; i < TEST_REPETITIONS; ++i) {\n      const result = _.randomInt(5, 10);\n      expect(result).toBeGreaterThanOrEqual(5);\n      expect(result).toBeLessThan(10);\n    }\n  });\n\n  it('returns a whole number', () => {\n    for (let i = 0; i < TEST_REPETITIONS; ++i) {\n      const result = _.randomInt(5, 10);\n      expect(Math.round(result)).toBe(result);\n    }\n  });\n});\n"},{"name":"randomChoice","manifest":{"fnSignature":"randomChoice(array)","summary":"Returns a random element from `array`."},"description":"","src":"function randomChoice(array) {\n  return array[Math.floor(Math.random() * array.length)];\n}","test":"describe('randomChoice()', () => {\n  const TEST_REPETITIONS = 10;\n\n  it('returns an element from the original array', () => {\n    for (let i = 0; i < TEST_REPETITIONS; ++i) {\n      const array = ['a', 'b', 'c', 'd', 'e'];\n      expect(array).toContain(_.randomChoice(array));\n    }\n  });\n});\n"},{"name":"shuffle","manifest":{"fnSignature":"shuffle(array)","summary":"Returns a copy of `array` that has been shuffled."},"description":"","src":"function shuffle(array) {\n  return array\n    .map(value => ({ value, sortKey: Math.random() }))\n    .sort((a, b) => a.sortKey - b.sortKey)\n    .map(({ value }) => value);\n}","test":"describe('shuffle()', () => {\n  const TEST_REPETITIONS = 10;\n\n  it('returns an array with entries that are all in the original array', () => {\n    for (let i = 0; i < TEST_REPETITIONS; ++i) {\n      const originalArray = ['a', 'b', 'c', 'd', 'e'];\n      const result = _.shuffle(originalArray);\n      for (const entry of result) {\n        expect(originalArray).toContain(entry);\n      }\n    }\n  });\n\n  it('returns an array where all entries of the original array are found in the returned one', () => {\n    for (let i = 0; i < TEST_REPETITIONS; ++i) {\n      const originalArray = ['a', 'b', 'c', 'd', 'e'];\n      const result = _.shuffle(originalArray);\n      for (const entry of originalArray) {\n        expect(result).toContain(entry);\n      }\n    }\n  });\n});\n"}]},{"categoryHeading":"HTML-Building Helpers","entries":[{"name":"el","manifest":{"fnSignature":"el(tagName, attrs?, children?)","summary":"Creates an HTML element."},"description":"# Parameters\n\n- `tagName`\n\n  The new element's tag\n\n- `attrs`\n\n  A mapping of attribute names to values\n\n- `...children`\n\n  A variable number of child nodes. A child can either be a string, an HTML element (e.g. one generated by el()), or an array of strings and/or HTML elements.\n\n# Examples\n\n```javascript\nel('div', { id: 'my-div' }, [\n  el('span', {}, 'Hello'),\n  'World!',\n  el(\n    'p', { class: 'lead' },\n    \"It's great to be here at\",\n    el('b', {}, 'Venue Name Here'), '!'\n  ),\n])\n\n/* The above results in the following HTML structure\n<div id=\"my-div\">\n  <span>Hello</span>\n  World!\n  <p class=\"lead\">\n    It's great to be here at\n    <b>Venue Name Here</b>!\n  </p>\n</div>\n*/\n```\n\n# Additional Information\n\nWhile `el()` can be useful for quick-and-dirty HTML-building, for more complicated content you may want to consider custom elements with HTML templates. [The following MDN guide can help get you started with this style of programming](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_templates_and_slots).\n","src":"function el(tagName, attrs = {}, ...children) {\n  const newElement = document.createElement(tagName);\n  for (const [key, value] of Object.entries(attrs)) {\n    newElement.setAttribute(key, value);\n  }\n  newElement.append(...children.flat());\n  return newElement;\n}","test":""},{"name":"fragment","manifest":{"fnSignature":"fragment(children?)","summary":"Creates an HTML fragment."},"description":"# Parameters\n\n- `...children`\n\n  A variable number of child nodes. A child can either be a string, an HTML element (e.g. one generated by el()), or an array of strings and/or HTML elements.\n\n# Examples\n\n```\nfragment([\n  // Using the el() snap.js function in this example.\n  el('span', {}, ['Hello']),\n  'World!',\n  el(\n    'p', { class: 'lead' },\n    \"It's great to be here at\",\n    el('b', {}, 'Venue Name Here'), '!'\n  ),\n])\n\n/* The above results in the following HTML structure\n<span>Hello</span>\nWorld!\n<p class=\"lead\">\n  It's great to be here at\n  <b>Venue Name Here</b>!\n</p>\n*/\n```\n","src":"function fragment(...children) {\n  const newFragment = new DocumentFragment();\n  newFragment.append(...children.flat());\n  return newFragment;\n}","test":""}]},{"categoryHeading":"Miscellaneous Helpers","entries":[{"name":"createEventEmitter","manifest":{"fnSignature":"createEventEmitter()","summary":"Creates a simple eventEmitter instance to aid with the pub-sub pattern of subscribing to events and notifying subscribers."},"description":"","src":"function createEventEmitter() {\n  const listeners = [];\n  return {\n    subscribe(fn) {\n      listeners.push(fn);\n      let unsubscribed = false;\n      return function unsubscribe() {\n        if (unsubscribed) return;\n        const index = listeners.indexOf(fn);\n        listeners.splice(index, 1);\n        unsubscribed = true;\n      };\n    },\n    trigger(...args) {\n      return listeners.map(fn => fn(...args));\n    },\n  };\n}","test":"describe('createEventEmitter()', () => {\n  it('triggers subscribed events with arguments', () => {\n    const event = _.createEventEmitter();\n    const spy1 = jest.fn();\n    event.subscribe(spy1);\n    const spy2 = jest.fn();\n    event.subscribe(spy2);\n\n    event.trigger(1, 2);\n    expect(spy1).toHaveBeenCalledWith(1, 2);\n    expect(spy2).toHaveBeenCalledWith(1, 2);\n  });\n\n  it('returns the results of the subscribed functions', () => {\n    const event = _.createEventEmitter();\n    event.subscribe(() => 2);\n    event.subscribe(() => 3);\n\n    const res = event.trigger();\n    expect(res).toEqual([2, 3]);\n  });\n\n  it('is capable of having async subscribers', async () => {\n    const event = _.createEventEmitter();\n    event.subscribe(async () => 2);\n    event.subscribe(async () => 3);\n\n    const res = await Promise.all(event.trigger());\n    expect(res).toEqual([2, 3]);\n  });\n\n  it('is capable of being triggered multiple times, with new subscribers', () => {\n    const event = _.createEventEmitter();\n    expect(event.trigger()).toEqual([]);\n\n    event.subscribe(() => 1);\n    expect(event.trigger()).toEqual([1]);\n\n    event.subscribe(() => 2);\n    expect(event.trigger()).toEqual([1, 2]);\n  });\n\n  it('allows unsubscribing', () => {\n    const event = _.createEventEmitter();\n\n    const unsubscribe = event.subscribe(() => 1);\n    event.subscribe(() => 2);\n    unsubscribe();\n    expect(event.trigger()).toEqual([2]);\n  });\n\n  it('allows repeated calls to unsubscribe', () => {\n    const event = _.createEventEmitter();\n\n    const unsubscribe = event.subscribe(() => 1);\n    event.subscribe(() => 2);\n    unsubscribe();\n    unsubscribe();\n    expect(event.trigger()).toEqual([2]);\n  });\n\n  it('can unsubscribe the correct function, even if the function identity does not change', () => {\n    // Tested by unsubscribing multiple times, but only expecting one unsubscribe to happen\n    const fn = () => 2;\n\n    const event = _.createEventEmitter();\n    const unsubscribe = event.subscribe(fn);\n    event.subscribe(fn);\n    unsubscribe();\n    unsubscribe();\n    expect(event.trigger()).toEqual([2]);\n  });\n});\n"},{"name":"addToDate","manifest":{"fnSignature":"addToDate(date, offset)","summary":"Returns a new date with year/month/day offsets added the `date`"},"description":"","src":"function addToDate(date_, offset) {\n  const {\n    years = 0,\n    months = 0,\n    days = 0,\n    hours = 0,\n    minutes = 0,\n    seconds = 0,\n    ms = 0,\n  } = offset;\n\n  const date = new Date(date_.valueOf());\n  date.setFullYear(date.getFullYear() + years);\n  date.setMonth(date.getMonth() + months);\n  date.setDate(date.getDate() + days);\n  date.setHours(date.getHours() + hours);\n  date.setMinutes(date.getMinutes() + minutes);\n  date.setSeconds(date.getSeconds() + seconds);\n  date.setMilliseconds(date.getMilliseconds() + ms);\n  return date;\n}","test":"describe('addToDate()', () => {\n  it('should be able to add years to the date', () => {\n    const oldDate = new Date(2000, 5, 3);\n    const newDate = _.addToDate(oldDate, { years: 2 });\n    expect(newDate.toString()).toBe(new Date(2002, 5, 3).toString());\n  });\n\n  it('should be able to add months to the date, and have it wrap to a new year', () => {\n    const oldDate = new Date(2000, 10, 3);\n    const newDate = _.addToDate(oldDate, { months: 3 });\n    expect(newDate.toString()).toBe(new Date(2001, 1, 3).toString());\n  });\n\n  it('should be able to add days to the date, and have it wrap to a new year', () => {\n    const oldDate = new Date(2000, 11, 29);\n    const newDate = _.addToDate(oldDate, { days: 4 });\n    expect(newDate.toString()).toBe(new Date(2001, 0, 2).toString());\n  });\n\n  it('should be able to add hours to the date, and have it wrap to a new year', () => {\n    const oldDate = new Date(2000, 11, 31, 23);\n    const newDate = _.addToDate(oldDate, { hours: 2 });\n    expect(newDate.toString()).toBe(new Date(2001, 0, 1, 1).toString());\n  });\n\n  it('should be able to add minutes to the date, and have it wrap to a new year', () => {\n    const oldDate = new Date(2000, 11, 31, 24, 59);\n    const newDate = _.addToDate(oldDate, { minutes: 2 });\n    expect(newDate.toString()).toBe(new Date(2001, 0, 1, 1, 1).toString());\n  });\n\n  it('should be able to add seconds to the date, and have it wrap to a new year', () => {\n    const oldDate = new Date(2000, 11, 31, 24, 59, 59);\n    const newDate = _.addToDate(oldDate, { seconds: 2 });\n    expect(newDate.toString()).toBe(new Date(2001, 0, 1, 1, 0, 1).toString());\n  });\n\n  it('should be able to add milliseconds to the date, and have it wrap to a new year', () => {\n    const oldDate = new Date(2000, 11, 31, 24, 59, 59, 999);\n    const newDate = _.addToDate(oldDate, { ms: 2 });\n    expect(newDate.toString()).toBe(\n      new Date(2001, 0, 1, 1, 0, 0, 1).toString()\n    );\n  });\n\n  it('should be able to update all attributes at the same time.', () => {\n    const oldDate = new Date(2000, 1, 2, 3, 4, 5, 6, 7);\n    const newDate = _.addToDate(oldDate, {\n      years: 1,\n      months: 2,\n      days: 3,\n      hours: 4,\n      minutes: 5,\n      seconds: 6,\n      ms: 7,\n    });\n    expect(newDate.toString()).toBe(\n      new Date(2001, 3, 5, 7, 9, 11, 13, 15).toString()\n    );\n  });\n\n  it('should support negative deltas', () => {\n    const oldDate = new Date(2001, 3, 5, 7, 9, 11, 13, 15);\n    const newDate = _.addToDate(oldDate, {\n      years: -1,\n      months: -2,\n      days: -3,\n      hours: -4,\n      minutes: -5,\n      seconds: -6,\n      ms: -7,\n    });\n    expect(newDate.toString()).toBe(\n      new Date(2000, 1, 2, 3, 4, 5, 6, 7).toString()\n    );\n  });\n});\n"}]}]