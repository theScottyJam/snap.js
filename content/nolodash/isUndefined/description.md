```javascript
value === undefined;
```

At one point in time it was often considered a good practice to compare against `void 0` instead of `undefined`, as `undefined` was just a property on the window object that could be overwritten to be any value while `void 0` (which returns the undefined value) can not be overwritten since it is syntax. The ability to globally overwrite the `undefined` value was changed in ES5, removing this concern in modern browsers. Even back then, this concern was largely over-hyped - yes you can override the value of `undefined`, but you can also override `Array`, `Math`, `Object`, `Function`, `setTimeout`, and so on - if the code you write doesn't try to defend against these globals being overwritten, then it should not try to defend against `undefined` being overwritten either.

Side rant: In case you didn't know, `void` is _not_ a function, it is a prefix operator with the same precedence as `!`, `await`, `typeof`, and so on. You don't try to pretend `await` is a function by always adding parentheses after it, do you? (`await(doSomeAsyncTask())`)? No. And you really don't need to do it with `void` either. Is there harm in pretending a prefix operator is a function? In general, yes, because it makes order of operations confusing - if we pretend that `await` is a function, then you might end up writing code such as `await(getUser(id)).username` that looks reasonable, except it's not going to work - `getUser(...)` is going to return a promise, and then it's going to try to access the `username` property on that promise _before_ the `await` happens, which is not what the author intended. Is it bad to pretend that `void`, specifically, is a function instead of an operator. Well, technically no, there's no reasonable code that you would write using `void` where order of operations would get confusing, at least in the language as it stands today. But, the point is, `void` is an operator, not a function, and there's no reason to pretend it's something that it's not.
