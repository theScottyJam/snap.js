[{"categoryHeading":"Array","entries":[{"name":"chunk","manifest":{"fnSignature":"_.chunk(array, size?)","lodashLink":"https://lodash.com/docs/4.17.15#chunk","summary":"Creates an array of elements split into groups the length of `size`. If `array` can't be split evenly, the final chunk will be the remaining elements."},"description":"```javascript\nfunction chunk(array, size = 1) {\n  const result = [];\n  for (let i = 0; i < array.length; i += size) {\n    result.push(array.slice(i, i + size));\n  }\n  return result;\n}\n```\n","src":null,"test":""},{"name":"compact","manifest":{"fnSignature":"_.compact(array)","lodashLink":"https://lodash.com/docs/4.17.15#compact","summary":"Creates an array with all falsey values removed. The values `false`, `null`, `0`, `\"\"`, `undefined`, and `NaN` are falsey."},"description":"All of these solutions are equivalent. Pick the one you find to be the most readable.\n\n```javascript\narray.filter(value => !!value);\n\narray.filter(value => value);\n\narray.filter(Boolean);\n```\n","src":null,"test":""},{"name":"concat","manifest":{"fnSignature":"_.concat(array, ...values)","lodashLink":"https://lodash.com/docs/4.17.15#concat","summary":"Creates a new array concatenating `array` with any additional arrays and/or values."},"description":"```javascript\nconst result = [...array1, ...array2, ...array3];\n```\n\nThis solution above only works on arrays and other iterables. If some of your values might not be arrays, you can use the native `.concat()` method instead.\n\n```javascript\nconst array1 = [1, 2, 3];\nconst value1 = 4;\nconst array2 = [5, 6, 7];\n\nconst result = array1.concat(value1, array2);\n\n// Expected output: [1, 2, 3, 4, 5, 6, 7]\n```\n","src":null,"test":""},{"name":"difference","manifest":{"fnSignature":"_.difference(array, values?)","lodashLink":"https://lodash.com/docs/4.17.15#difference","summary":"Creates an array of `array` values not included in the other given arrays using `SameValueZero` for equality comparisons. The order and references of result values are determined by the first array."},"description":"To subtract everything in array2 from array1, use the following:\n\n```javascript\narray1.filter(x => !array2.includes(x));\n```\n\nRemember that `.includes()` has an `O(n)` lookup time. If you're dealing with larger arrays, make sure to convert the target array into a set first (a set's `.has()` method has `O(1)` lookup time).\n\n```javascript\nconst set2 = new Set(array2);\nconst result = array1.filter(x => !set2.has(x));\n```\n\nBoth `array.includes()` and `set.has()` use [the SameValueZero comparison algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality) under-the-hood as well, just like Lodash's `_.difference()`.\n","src":null,"test":""},{"name":"differenceBy","manifest":{"fnSignature":"_.differenceBy(array, values?, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#differenceBy","summary":"This method is like `_.difference` except that it accepts `iteratee` which is invoked for each element of `array` and `values` to generate the criterion by which they're compared. The order and references of result values are determined by the first array."},"description":"```javascript\nfunction differenceBy(array, values, iteratee) {\n  const transformedValues = new Set(values.map(x => iteratee(x)));\n  return array.filter(x => !transformedValues.has(iteratee(x)));\n}\n```\n","src":null,"test":""},{"name":"differenceWith","manifest":{"fnSignature":"_.differenceWith(array, values?, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#differenceWith","summary":"This method is like `_.difference` except that it accepts `comparator` which is invoked to compare elements of `array` to `values`."},"description":"```javascript\nfunction differenceWith(array, values, comparator) {\n  return array.filter(x => !values.some(y => comparator(x, y)));\n}\n```\n","src":null,"test":""},{"name":"drop","manifest":{"fnSignature":"_.drop(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#drop","summary":"Creates a slice of `array` with `n` elements dropped from the beginning."},"description":"```javascript\narray.slice(n)\n```\n","src":null,"test":""},{"name":"dropRight","manifest":{"fnSignature":"_.dropRight(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#dropRight","summary":"Creates a slice of `array` with `n` elements dropped from the end."},"description":"```javascript\narray.slice(0, -n)\n```\n\nYou do have to watch out for the zero case. `_.dropRight(0)` will return the whole array, while, `array.slice(0, -0)` will return an empty array.\n","src":null,"test":""},{"name":"dropRightWhile","manifest":{"fnSignature":"_.dropRightWhile(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#dropRightWhile","summary":"Creates a slice of `array` excluding elements dropped from the end. Elements are dropped until `predicate` returns falsey."},"description":"```javascript\nfunction dropRightWhile(array, predicate) {\n  const index = array.findLastIndex((...args) => !predicate(...args))\n  if (index === -1) {\n    return [];\n  }\n\n  return array.slice(0, index + 1);\n}\n```","src":null,"test":""},{"name":"dropWhile","manifest":{"fnSignature":"_.dropWhile(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#dropWhile","summary":"Creates a slice of `array` excluding elements dropped from the beginning. Elements are dropped until `predicate` returns falsey."},"description":"```javascript\nfunction dropWhile(array, predicate) {\n  const index = array.findIndex((...args) => !predicate(...args))\n  if (index === -1) {\n    return [];\n  }\n\n  return array.slice(index);\n}\n```","src":null,"test":""},{"name":"fill","manifest":{"fnSignature":"_.fill(array, value, start?, end?)","lodashLink":"https://lodash.com/docs/4.17.15#fill","summary":"Fills elements of `array` with `value` from `start` up to, but not including, `end`."},"description":"```javascript\narray.fill(value, start, end);\n```\n\nThe `start` and `end` parameters are optional.\n","src":null,"test":""},{"name":"findIndex","manifest":{"fnSignature":"_.findIndex(array, predicate?, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#findIndex","summary":"This method is like `_.find` except that it returns the index of the first element `predicate` returns truthy for instead of the element itself."},"description":"```javascript\narray.findIndex(predicate);\n```\n\nIf you need to start from a particular index, a simple solution is to check which index you're at inside your predicate. In this example, we'll look for the first non-null element that exists at index 5 or greater.\n\n```javascript\narray.findIndex((value, i) => i >= 5 && value !== null);\n```\n\nIf you need to start from a particular index, and you're dealing with larger arrays, you may just need to build your own `findIndex` function from a simple for loop, in order to help with performance.\n","src":null,"test":""},{"name":"findLastIndex","manifest":{"fnSignature":"_.findLastIndex(array, predicate?, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#findLastIndex","summary":"This method is like `_.findIndex` except that it iterates over elements of `collection` from right to left."},"description":"```javascript\narray.findLastIndex(predicate);\n```\n\nIf you need to start from a particular index, a simple solution is to check which index you're at inside your predicate. In this example, we'll look for the first non-null element that exists at index 5 or earlier.\n\n```javascript\narray.findLastIndex((value, i) => i <= 5 && value !== null);\n```\n\nIf you need to start from a particular index, and you're dealing with larger arrays, you may just need to build your own `findLastIndex` function from a simple for loop, in order to help with performance.\n","src":null,"test":""},{"name":"flatten","manifest":{"fnSignature":"_.flatten(array)","lodashLink":"https://lodash.com/docs/4.17.15#flatten","summary":"Flattens `array` a single level deep."},"description":"```javascript\narray.flat();\n```\n","src":null,"test":""},{"name":"flattenDeep","manifest":{"fnSignature":"_.flattenDeep(array)","lodashLink":"https://lodash.com/docs/4.17.15#flattenDeep","summary":"Recursively flattens `array`."},"description":"```javascript\narray.flat(Infinity);\n```\n","src":null,"test":""},{"name":"flattenDepth","manifest":{"fnSignature":"_.flattenDepth(array, depth?)","lodashLink":"https://lodash.com/docs/4.17.15#flattenDeep","summary":"Recursively flatten `array` up to `depth` times."},"description":"```javascript\narray.flat(depth);\n```\n","src":null,"test":""},{"name":"fromPairs","manifest":{"fnSignature":"_.fromPairs(pairs)","lodashLink":"https://lodash.com/docs/4.17.15#fromPairs","summary":"The inverse of `_.toPairs`; this method returns an object composed from key-value `pairs`."},"description":"```javascript\nObject.fromEntries(pairs);\n```\n","src":null,"test":""},{"name":"head","manifest":{"fnSignature":"_.head(array)","lodashLink":"https://lodash.com/docs/4.17.15#head","summary":"Gets the first element of `array`."},"description":"```javascript\narray[0];\n```\n","src":null,"test":""},{"name":"indexOf","manifest":{"fnSignature":"_.indexOf(array, value, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#indexOf","summary":"Gets the index at which the first occurrence of `value` is found in `array` using `SameValueZero` for equality comparisons. If `fromIndex` is negative, it's used as the offset from the end of array."},"description":"```javascript\narray.findIndex(x => x === value);\n```\n\nIf you need to start from a particular index, a simple solution is to check which index you're at inside your predicate. In this example, we'll look for the index of the first `42` that exists at index 5 or greater.\n\n```javascript\narray.findIndex((value, i) => i >= 5 && value === 42);\n```\n\nIf you need to start from a particular index, and you're dealing with larger arrays, you may just need to build your own `findIndex` function using a simple for loop, in order to help with performance.\n\nIf you wish to perform comparisons using [the SameValueZero algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality), similar to how Lodash does it, you can use this helper function:\n\n```javascript\nfunction sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) && Number.isNaN(y));\n}\n```\n","src":null,"test":""},{"name":"initial","manifest":{"fnSignature":"_.initial(array)","lodashLink":"https://lodash.com/docs/4.17.15#initial","summary":"Gets all but the last element of `array`."},"description":"```javascript\narray.slice(0, -1)\n```\n","src":null,"test":""},{"name":"intersection","manifest":{"fnSignature":"_.intersection(...arrays)","lodashLink":"https://lodash.com/docs/4.17.15#intersection","summary":"Creates an array of unique values that are included in all given arrays using `SameValueZero` for equality comparisons."},"description":"To take the intersection of array1 and array2, use the following:\n\n```javascript\narray1.filter(x => array2.includes(x));\n```\n\nIf you also wish to remove duplicate elements from the final result, the same way `_.intersection()` does, you can use a set, like so:\n\n```javascript\nconst resultWithDuplicates = array1.filter(x => array2.includes(x));\nconst resultWithoutDuplicates = [...new Set(resultWithDuplicates)];\n```\n\nRemember that `.includes()` has an `O(n)` lookup time. If you're dealing with larger arrays, make sure to convert the second array into a set (a set's `.has()` method has `O(1)` lookup time).\n\n```javascript\nconst set2 = new Set(array2);\nconst resultWithDuplicates = array1.filter(x => set2.has(x));\n```\n\nBoth `array.includes()` and `set.has()` use [the SameValueZero comparison algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality) under-the-hood as well, just like Lodash's `_.intersection()`.\n\nThere is [an upcoming proposal](https://github.com/tc39/proposal-set-methods) that will introduce a native `.intersection()` method for sets.\n","src":null,"test":""},{"name":"intersectionBy","manifest":{"fnSignature":"_.intersectionBy(...arrays, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#intersectionBy","summary":"This method is like `_.intersection` except that it accepts `iteratee` which is invoked for each element of each `arrays` to generate the criterion by which they're compared."},"description":"```javascript\nfunction intersectionBy(array1, array2, iteratee = x => x) {\n  const result = [];\n  const resultTransformed = new Set();\n  const array2Transformed = new Set(array2.map(x => iteratee(x)));\n  for (const element of array1) {\n    const transformedElement = iteratee(element);\n    const isInIntersection = (\n      !resultTransformed.has(transformedElement)\n      && array2Transformed.has(transformedElement)\n    );\n\n    if (isInIntersection) {\n      result.push(element);\n      resultTransformed.add(transformedElement);\n    }\n  }\n\n  return result;\n}\n```\n\nIf you know that `array1` doesn't contain duplicate elements, or you don't care if duplicate elements from `array1` end up in the final result, then this implementation will achieve the same effect:\n\n```javascript\nfunction intersectionBy(array1, array2, iteratee = x => x) {\n  const array2Transformed = new Set(array2.map(x => iteratee(x)));\n  return array1.filter(x => array2Transformed.has(iteratee(x)));\n}\n```\n","src":null,"test":""},{"name":"intersectionWith","manifest":{"fnSignature":"_.intersectionWith(...arrays, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#intersectionWith","summary":"This method is like `_.intersection` except that it accepts `comparator` which is invoked to compare elements of `arrays`."},"description":"```javascript\nfunction intersectionWith(array1, array2, comparator) {\n  const result = [];\n  for (const element of array1) {\n    const isInIntersection = (\n      !result.some(x => comparator(x, element))\n      && array2.some(x => comparator(x, element))\n    );\n\n    if (isInIntersection) {\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n```\n\nIf you know that `array1` doesn't contain duplicate elements, or you don't care if duplicate elements from `array1` end up in the final result, then this implementation will achieve the same effect:\n\n```javascript\nfunction intersectionWith(array1, array2, comparator) {\n  return array1.filter(x => array2.some(y => comparator(x, y)));\n}\n```\n","src":null,"test":""},{"name":"join","manifest":{"fnSignature":"_.join(array, separator?)","lodashLink":"https://lodash.com/docs/4.17.15#join","summary":"Converts all elements in `array` into a string separated by `separator`."},"description":"```javascript\narray.join(separator);\n```\n","src":null,"test":""},{"name":"last","manifest":{"fnSignature":"_.last(array)","lodashLink":"https://lodash.com/docs/4.17.15#last","summary":"Gets the last element of `array`."},"description":"```javascript\narray.at(-1);\n```\n","src":null,"test":""},{"name":"lastIndexOf","manifest":{"fnSignature":"_.lastIndexOf(array, value, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#lastIndexOf","summary":"This method is like `_.indexOf` except that it iterates over elements of `array` from right to left."},"description":"```javascript\narray.findLastIndex(x => x === value);\n```\n\nIf you need to start from a particular index, a simple solution is to check which index you're at inside your predicate. In this example, we'll look for the index of the last `42` that exists at index 5 or lower.\n\n```javascript\narray.findLastIndex((value, i) => i <= 5 && value === 42);\n```\n\nIf you need to start from a particular index, and you're dealing with larger arrays, you may just need to build your own `findLastIndex` function using a simple for loop, in order to help with performance.\n\nIf you wish to perform comparisons using [the SameValueZero algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality), similar to how Lodash does it, you can use this helper function:\n\n```javascript\nfunction sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) && Number.isNaN(y));\n}\n```\n","src":null,"test":""},{"name":"nth","manifest":{"fnSignature":"_.nth(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#nth","summary":"Gets the element at index `n` of `array`. If `n` is negative, the nth element from the end is returned."},"description":"```javascript\narray[n];\n```\n\nOr, if you need support for negative indices:\n\n```javascript\narray.at(n);\n```\n","src":null,"test":""},{"name":"pull","manifest":{"fnSignature":"_.pull(array, ...values)","lodashLink":"https://lodash.com/docs/4.17.15#pull","summary":"Removes all given values from `array` using `SameValueZero` for equality comparisons. Note: Unlike `_.without`, this method mutates `array`."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following `filterInPlace()` helper can be used to achieve the desired result in `O(n)` time.\n\n```javascript\nfunction filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\n// Pull everything out from `array` that equals `targetValue`.\nconst result = filterInPlace(array, x => x === targetValue);\n```\n\nIf you wish to perform comparisons using [the SameValueZero algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality), similar to how Lodash does it, you can use this helper function:\n\n```javascript\nfunction sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) && Number.isNaN(y));\n}\n```\n\nSee the `_.pullAll()` entry if you have multiple items you wish to pull at once.\n","src":null,"test":""},{"name":"pullAll","manifest":{"fnSignature":"_.pullAll(array, values)","lodashLink":"https://lodash.com/docs/4.17.15#pullAll","summary":"This method is like `_.pull` except that it accepts an array of values to remove."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following `filterInPlace()` helper can be used to achieve the desired result in `O(n)` time.\n\n```javascript\nfunction filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\n// Pull everything in the `values` array from `array`.\nconst result = filterInPlace(array, x => values.include(x));\n```\n\nRemember that the `values.includes()` used at the end also has an `O(n)` lookup time. If you're dealing with a larger `values` array, make sure to convert it into a set first (a set's `.has()` method has `O(1)` lookup time).\n\nBoth `array.includes()` and `set.has()` use [the SameValueZero comparison algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality) under-the-hood as well, just like Lodash's `_.pull()`.\n","src":null,"test":""},{"name":"pullAllBy","manifest":{"fnSignature":"_.pullAllBy(array, values, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#pullAllBy","summary":"This method is like `_.pullAll` except that it accepts `iteratee` which is invoked for each element of `array` and `values` to generate the criterion by which they're compared."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following `filterInPlace()` helper can be used to achieve the desired result in `O(n)` time.\n\n```javascript\nfunction filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\nfunction pullAllBy(array, values, iteratee) {\n  const transformedValues = new Set(values.map(x => iteratee(x)));\n  filterInPlace(array, x => !transformedValues.has(iteratee(x)));\n}\n```\n","src":null,"test":""},{"name":"pullAllWith","manifest":{"fnSignature":"_.pullAllWith(array, values, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#pullAllWith","summary":"This method is like `_.pullAll` except that it accepts `comparator` which is invoked to compare elements of `array` to `values`."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following `filterInPlace()` helper can be used to achieve the desired result.\n\n```javascript\nfunction filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\nfunction pullAllWith(array, values, comparator) {\n  filterInPlace(array, x => !values.some(y => comparator(x, y)));\n}\n```\n","src":null,"test":""},{"name":"pullAt","manifest":{"fnSignature":"_.pullAt(array, indexes?)","lodashLink":"https://lodash.com/docs/4.17.15#pullAt","summary":"Removes elements from `array` corresponding to `indexes` and returns an array of removed elements."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following `filterInPlace()` helper can be used to achieve the desired result in `O(n)` time.\n\n```javascript\nfunction filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\nfunction pullAt(array, indexes_) {\n  const pulled = indexes_.map(i => array[i]);\n  const indexes = new Set(indexes_);\n  filterInPlace(array, (_, i) => !indexes.has(i));\n  return pulled;\n}\n```\n","src":null,"test":""},{"name":"remove","manifest":{"fnSignature":"_.remove(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#remove","summary":"Removes all elements from `array` that `predicate` returns truthy for and returns an array of the removed elements."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following implementation can be used to achieve the desired result in `O(n)` time.\n\n```javascript\nfunction remove(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n```\n","src":null,"test":""},{"name":"reverse","manifest":{"fnSignature":"_.reverse(array)","lodashLink":"https://lodash.com/docs/4.17.15#reverse","summary":"Reverses `array` so that the first element becomes the last, the second element becomes the second to last, and so on."},"description":"```javascript\narray.reverse();\n```\n","src":null,"test":""},{"name":"slice","manifest":{"fnSignature":"_.slice(array, start?, end?)","lodashLink":"https://lodash.com/docs/4.17.15#slice","summary":"Creates a slice of `array` from `start` up to, but not including, `end`."},"description":"```javascript\narray.slice(start, end);\n```\n\nOne benefit of Lodash's implementation of `.slice()`, is that it'll always return a dense array (as opposed to a [sparse one](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#sparse_arrays)). The same behavior can be achieved in plain JavaScript by simply spreading the array into another one.\n\n```javascript\nconst sparseArray = [2,,3,,4]; // [2, <empty>, 3, <empty>, 4]\nconst denseArray = [...sparseArray]; // [2, undefined, 3, undefined, 4]\nconsole.log(denseArray.slice(1, 3)); // [undefined, 3]\n```\n\nNote, however, that Lodash is providing this behavior, mostly because it makes their `.slice()` implementation more consistent with how newer JavaScript array methods treat sparse arrays - by pretending the holes are the same as `undefined` values. In practice, such a feature shouldn't make a difference in your codebase, as it's generally considered bad practice to create or pass around sparse arrays. If you're a library developer who may be receiving arbitrary user input, simply treat arguments that could potentially be sparse arrays the same way you would treat any other kind of bad input the end-user gives you. If you don't do any data validation, then don't worry about it - a sparse array would result in undefined behavior, the same way any other bad input would. If you do up-front data validation, you can choose to add the detection of sparse arrays as an additional up-front check.\n","src":null,"test":""},{"name":"sortedIndex","manifest":{"fnSignature":"_.sortedIndex(array, value)","lodashLink":"https://lodash.com/docs/4.17.15#sortedIndex","summary":"Uses a binary search to determine the lowest index at which `value` should be inserted into `array` in order to maintain its sort order."},"description":"```javascript\nfunction sortedIndex(array, value, _range) {\n  const [low, high] = _range ?? [0, array.length];\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = value <= array[midPoint]\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedIndex(array, value, newRange);\n}\n```\n","src":null,"test":""},{"name":"sortedIndexBy","manifest":{"fnSignature":"_.sortedIndexBy(array, value, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#sortedIndexBy","summary":"This method is like `_.sortedIndex` except that it accepts `iteratee` which is invoked for `value` and each element of `array` to compute their sort ranking."},"description":"```javascript\nfunction sortedIndexBy(array, value, iteratee, _recurseOpts) {\n  _recurseOpts ??= {\n    range: [0, array.length],\n    transformedValue: iteratee(value),\n  };\n\n  const transformedValue = _recurseOpts.transformedValue;\n  const [low, high] = _recurseOpts.range;\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = transformedValue <= iteratee(array[midPoint])\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedIndexBy(array, value, iteratee, { transformedValue, range: newRange });\n}\n```\n","src":null,"test":""},{"name":"sortedIndexOf","manifest":{"fnSignature":"_.sortedIndexOf(array, value)","lodashLink":"https://lodash.com/docs/4.17.15#sortedIndexOf","summary":"This method is like `_.indexOf` except that it performs a binary search on a sorted `array`."},"description":"We will use a plain JavaScript implementation of `_.sortedIndex()` to help define `sortedIndexOf()`.\n\n```javascript\nfunction sortedIndex(array, value, _range) {\n  const [low, high] = _range ?? [0, array.length];\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = value <= array[midPoint]\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedIndex(array, value, newRange);\n}\n\nfunction sortedIndexOf(array, value) {\n  const index = sortedIndex(array, value);\n  return array[index] === value ? index : -1;\n}\n```","src":null,"test":""},{"name":"sortedLastIndex","manifest":{"fnSignature":"_.sortedLastIndex(array, value)","lodashLink":"https://lodash.com/docs/4.17.15#sortedLastIndex","summary":"This method is like `_.sortedIndex` except that it returns the highest index at which `value` should be inserted into `array` in order to maintain its sort order."},"description":"```javascript\nfunction sortedLastIndex(array, value, _range) {\n  const [low, high] = _range ?? [0, array.length];\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = value < array[midPoint]\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedLastIndex(array, value, newRange);\n}\n```\n","src":null,"test":""},{"name":"sortedLastIndexBy","manifest":{"fnSignature":"_.sortedLastIndexBy(array, value, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#sortedLastIndexBy","summary":"This method is like `_.sortedLastIndex` except that it accepts `iteratee` which is invoked for value and each element of array to compute their sort ranking."},"description":"```javascript\nfunction sortedLastIndexBy(array, value, iteratee, _recurseOpts) {\n  _recurseOpts ??= {\n    range: [0, array.length],\n    transformedValue: iteratee(value),\n  };\n\n  const transformedValue = _recurseOpts.transformedValue;\n  const [low, high] = _recurseOpts.range;\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = transformedValue < iteratee(array[midPoint])\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedLastIndexBy(array, value, iteratee, { transformedValue, range: newRange });\n}\n```\n","src":null,"test":""},{"name":"sortedLastIndexOf","manifest":{"fnSignature":"_.sortedLastIndexOf(array, value)","lodashLink":"https://lodash.com/docs/4.17.15#sortedLastIndexOf","summary":"This method is like `_.lastIndexOf` except that it performs a binary search on a sorted `array`."},"description":"We will use a plain JavaScript implementation of `_.sortedLastIndex()` to help define `sortedLastIndexOf()`.\n\n```javascript\nfunction sortedLastIndex(array, value, _range) {\n  const [low, high] = _range ?? [0, array.length];\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = value < array[midPoint]\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedLastIndex(array, value, newRange);\n}\n\nfunction sortedLastIndexOf(array, value) {\n  const index = sortedLastIndex(array, value) - 1;\n  return index > -1 && array[index] === value ? index : -1;\n}\n```","src":null,"test":""},{"name":"sortedUniq","manifest":{"fnSignature":"_.sortedUniq(array)","lodashLink":"https://lodash.com/docs/4.17.15#sortedUniq","summary":"This method is like `_.uniq` except that it's designed and optimized for sorted arrays."},"description":"```javascript\nfunction sortedUniq(array) {\n  if (array.length === 0) {\n    return [];\n  }\n\n  const result = [array[0]];\n  for (const value of array) {\n    if (result[result.length - 1] !== value) {\n      result.push(value);\n    }\n  }\n\n  return result;\n}\n```\n\n[Some basic benchmarks](https://gist.github.com/theScottyJam/8424183e49f4555b60752b21f1076129) shows that the processing time per item improves as the number of repeated items increase. If you're not dealing with large arrays, or arrays with many repeated items, then using the simpler `[...new Set(array)]` solution should be sufficient.\n","src":null,"test":""},{"name":"sortedUniqBy","manifest":{"fnSignature":"_.sortedUniqBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#sortedUniqBy","summary":"This method is like `_.uniqBy` except that it's designed and optimized for sorted arrays."},"description":"```javascript\nfunction sortedUniqBy(array, iteratee) {\n  if (array.length === 0) {\n    return [];\n  }\n\n  let lastTransformedValue = iteratee(array[0]);\n  const result = [array[0]];\n  for (let i = 0; i < array.length; ++i) {\n    const transformedValue = iteratee(array[i]);\n    if (lastTransformedValue !== transformedValue) {\n      result.push(array[i]);\n      lastTransformedValue = transformedValue;\n    }\n  }\n\n  return result;\n}\n```\n","src":null,"test":""},{"name":"tail","manifest":{"fnSignature":"_.tail(array)","lodashLink":"https://lodash.com/docs/4.17.15#tail","summary":"Gets all but the first element of `array`."},"description":"```javascript\narray.slice(1);\n```\n","src":null,"test":""},{"name":"take","manifest":{"fnSignature":"_.take(array, n)","lodashLink":"https://lodash.com/docs/4.17.15#take","summary":"Creates a slice of `array` with `n` elements taken from the beginning."},"description":"```javascript\narray.slice(0, n);\n```\n","src":null,"test":""},{"name":"takeRight","manifest":{"fnSignature":"_.takeRight(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#takeRight","summary":"Creates a slice of `array` with `n` elements taken from the end."},"description":"```javascript\narray.slice(-n);\n```\n\nYou do have to watch out for the zero case. `_.takeRight(0)` will return an empty array, while, `array.slice(-0)` will return the whole array.\n","src":null,"test":""},{"name":"takeRightWhile","manifest":{"fnSignature":"_.takeRightWhile(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#takeRightWhile","summary":"Creates a slice of `array` with elements taken from the end. Elements are taken until `predicate` returns falsey."},"description":"```javascript\nfunction takeRightWhile(array, predicate) {\n  const index = array.findLastIndex((...args) => !predicate(...args))\n  if (index === -1) {\n    return array;\n  }\n\n  return array.slice(index + 1);\n}\n```\n","src":null,"test":""},{"name":"takeWhile","manifest":{"fnSignature":"_.takeWhile(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#takeWhile","summary":"Creates a slice of `array` with elements taken from the beginning. Elements are taken until `predicate` returns falsey."},"description":"```javascript\nfunction takeWhile(array, predicate) {\n  const index = array.findIndex((...args) => !predicate(...args))\n  if (index === -1) {\n    return array;\n  }\n\n  return array.slice(0, index);\n}\n```\n","src":null,"test":""},{"name":"union","manifest":{"fnSignature":"_.union(...arrays)","lodashLink":"https://lodash.com/docs/4.17.15#union","summary":"Creates an array of unique values, in order, from all given arrays using `SameValueZero` for equality comparisons."},"description":"```javascript\n[...new Set([...array1, ...array2])];\n```\n\nSets internally use [the SameValueZero comparison algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality) under-the-hood, just like Lodash's `_.union()`.\n\nThere is [an upcoming proposal](https://github.com/tc39/proposal-set-methods) that will introduce a native `.union()` method for sets.\n","src":null,"test":""},{"name":"unionBy","manifest":{"fnSignature":"_.unionBy(...arrays, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#unionBy","summary":"This method is like `_.union` except that it accepts `iteratee` which is invoked for each element of each `arrays` to generate the criterion by which uniqueness is computed."},"description":"We will use a plain JavaScript implementation of `_.uniqBy()` to solve this problem.\n\n```javascript\nfunction uniqBy(array, iteratee) {\n  const transformedResults = new Set();\n  const result = [];\n  for (const element of array) {\n    const transformedElement = iteratee(element);\n    if (!transformedResults.has(transformedElement)) {\n      transformedResults.add(transformedElement);\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n\n// Merge the given arrays, then filter out duplicates.\n// This end-effect will be the union of these two arrays,\n// using `iteratee` to decide equivalence.\nuniqBy([...array1, ...array2], iteratee);\n```\n","src":null,"test":""},{"name":"unionWith","manifest":{"fnSignature":"_.unionWith(array, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#unionWith","summary":"This method is like `_.union` except that it accepts `comparator` which is invoked to compare elements of `arrays`."},"description":"We will use a plain JavaScript implementation of `_.uniqWith()` to solve this problem.\n\n```javascript\nfunction uniqWith(array, comparator) {\n  const result = [];\n  for (const element of array) {\n    if (result.every(x => !comparator(x, element))) {\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n\n// Merge the given arrays, then filter out duplicates.\n// This end-effect will be the union of these two arrays,\n// using `comparator` to decide equivalence.\nuniqWith([...array1, ...array2], comparator);\n```\n","src":null,"test":""},{"name":"uniq","manifest":{"fnSignature":"_.uniq(array)","lodashLink":"https://lodash.com/docs/4.17.15#uniq","summary":"Creates a duplicate-free version of an array, using `SameValueZero` for equality comparisons."},"description":"```javascript\n[...new Set(array)];\n```\n\nSets internally use [the SameValueZero comparison algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality) under-the-hood, just like Lodash's `_.uniq()`.\n","src":null,"test":""},{"name":"uniqBy","manifest":{"fnSignature":"_.uniqBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#uniqBy","summary":"This method is like `_.uniq` except that it accepts `iteratee` which is invoked for each element in array to generate the criterion by which uniqueness is computed."},"description":"```javascript\nfunction uniqBy(array, iteratee) {\n  const transformedResults = new Set();\n  const result = [];\n  for (const element of array) {\n    const transformedElement = iteratee(element);\n    if (!transformedResults.has(transformedElement)) {\n      transformedResults.add(transformedElement);\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n```\n","src":null,"test":""},{"name":"uniqWith","manifest":{"fnSignature":"_.uniqWith(array, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#uniqWith","summary":"This method is like `_.uniq` except that it accepts `comparator` which is invoked to compare elements of `array`."},"description":"```javascript\nfunction uniqWith(array, comparator) {\n  const result = [];\n  for (const element of array) {\n    if (result.every(x => !comparator(x, element))) {\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n```\n","src":null,"test":""},{"name":"unzip","manifest":{"fnSignature":"_.unzip(array)","lodashLink":"https://lodash.com/docs/4.17.15#unzip","summary":"This method is like `_.zip` except that it accepts an array of grouped elements and creates an array regrouping the elements to their pre-zip configuration."},"description":"`_.zip()` is actually the inverse of itself, meaning you can use it to unzip the result of `_.zip()`, like this:\n\n```javascript\nconst original = [[1, 2, 3], ['A', 'B', 'C']]\nconst zipped = _.zip(...original); // [[1, 'A'], [2, 'B'], [3, 'C']]\nconst unzipped = _.zip(...zipped); // [[1, 2, 3], ['A', 'B', 'C']]\n```\n\nThe only difference between `_.zip()` and `_.unzip()` is how it accepts parameters.\n\n```javascript\n// With _.zip(), arrays are passed in as separate parameters\n_.zip([1, 2], ['A', 'B']);     // [[1, 'A'], [2, 'B']]\n// With _.unzip(), arrays are placed inside a single larger array.\n_.unzip([[1, 2], ['A', 'B']]); // [[1, 'A'], [2, 'B']]\n```\n\nSo, to implement an unzip function, all you really need is an implementation for `zip()`.\n\n```javascript\nfunction zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(arrays.map(arr => arr[i]));\n  }\n\n  return result;\n}\n```\n\nIf you want a Lodash-style unzip function, here's how to implement it:\n\n```javascript\nfunction unzip(arrays) {\n  return zip(...arrays);\n}\n```\n","src":null,"test":""},{"name":"unzipWith","manifest":{"fnSignature":"_.unzipWith(array, iteratee)","lodashLink":"https://lodash.com/docs/4.17.15#unzipWith","summary":"This method is like `_.unzip` except that it accepts `iteratee` to specify how regrouped values should be combined."},"description":"The only difference between `_.zipWith()` and `_.unzipWith()` is how it accepts parameters.\n\n```javascript\n// With _.zipWith(), arrays are passed in as separate parameters\n_.zipWith([10, 20], [1, 2], (a, b) => a + b);     // [11, 22]\n// With _.unzipWith(), arrays are placed inside a single larger array.\n_.unzipWith([[10, 20], [1, 2]], (a, b) => a + b); // [11, 22]\n```\n\n!!!!\n\nSo, to implement an unzipWith function, all you really need is an implementation for `zipWith()`.\n\n```javascript\nfunction zipWith(...args) {\n  const arrays = args.slice(0, -1);\n  const iteratee = args.at(-1);\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(iteratee(...arrays.map(arr => arr[i])));\n  }\n\n  return result;\n}\n```\n\nIf you want a Lodash-style unzipWith function, here's how to implement it:\n\n```javascript\nfunction unzipWith(arrays, iteratee) {\n  return zip(arrays, iteratee);\n}\n```\n","src":null,"test":""},{"name":"without","manifest":{"fnSignature":"_.without(array, ...values)","lodashLink":"https://lodash.com/docs/4.17.15#without","summary":"Creates an array excluding all given values using `SameValueZero` for equality comparisons."},"description":"```javascript\narray.filter(x => x !== value);\n```\n\nIf you wish to filter out multiple values, look at the plain JavaScript version of `_.difference()`. Both `_.difference()` and `_.without()` achieve the same effect, but with slightly different function signatures.\n\nIf you wish to perform comparisons using [the SameValueZero algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality), similar to how Lodash does it, you can use this helper function:\n\n```javascript\nfunction sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) && Number.isNaN(y));\n}\n```\n","src":null,"test":""},{"name":"xor","manifest":{"fnSignature":"_.xor(...arrays)","lodashLink":"https://lodash.com/docs/4.17.15#xor","summary":"Creates an array of unique values that is the symmetric difference of the given arrays."},"description":"```javascript\nfunction xor(array1, array2) {\n  const set1 = new Set(array1);\n  const set2 = new Set(array2);\n  return [\n    ...array1.filter(x => !set2.has(x)),\n    ...array2.filter(x => !set1.has(x)),\n  ];\n}\n```\n","src":null,"test":""},{"name":"xorBy","manifest":{"fnSignature":"_.xorBy(...arrays, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#xorBy","summary":"This method is like `_.xor` except that it accepts `iteratee` which is invoked for each element of each `arrays` to generate the criterion by which by which they're compared."},"description":"```javascript\nfunction xorBy(array1, array2, iteratee) {\n  const set1 = new Set(array1.map(x => iteratee(x)));\n  const set2 = new Set(array2.map(x => iteratee(x)));\n  return [\n    ...array1.filter(x => !set2.has(iteratee(x))),\n    ...array2.filter(x => !set1.has(iteratee(x))),\n  ];\n}\n```\n","src":null,"test":""},{"name":"xorWith","manifest":{"fnSignature":"_.xorWith(...arrays, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#xorWith","summary":"This method is like `_.xor` except that it accepts `comparator` which is invoked to compare elements of arrays."},"description":"```javascript\nfunction xorWith(array1, array2, comparator) {\n  return [\n    ...array1.filter(x => !array2.some(y => comparator(x, y))),\n    ...array2.filter(x => !array1.some(y => comparator(x, y))),\n  ];\n}\n```\n","src":null,"test":""},{"name":"zip","manifest":{"fnSignature":"_.zip(...arrays)","lodashLink":"https://lodash.com/docs/4.17.15#zip","summary":"Creates an array of grouped elements, the first of which contains the first elements of the given arrays, the second of which contains the second elements of the given arrays, and so on."},"description":"```javascript\nfunction zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(arrays.map(arr => arr[i]));\n  }\n\n  return result;\n}\n```\n","src":null,"test":""},{"name":"zipObject","manifest":{"fnSignature":"_.zipObject(props?, values?)","lodashLink":"https://lodash.com/docs/4.17.15#zipObject","summary":"This method is like `_.fromPairs` except that it accepts two arrays, one of property identifiers and one of corresponding values."},"description":"We will use a plain JavaScript implementation of `_.zip()` to solve this problem.\n\n```javascript\nfunction zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(arrays.map(arr => arr[i]));\n  }\n\n  return result;\n}\n\n// First zips the keys and values,\n// then build an object from the zipped entries.\nObject.fromEntries(zip(props, values));\n```\n","src":null,"test":""},{"name":"zipObjectDeep","manifest":{"fnSignature":"_.zipObjectDeep(props?, values?)","lodashLink":"https://lodash.com/docs/4.17.15#zipObjectDeep","summary":"This method is like `_.zipObject` except that it supports property paths."},"description":"It's recommended to avoid this function. Building objects via dynamic string paths may (or may not) be indicative of a deeper issue with how the problem is being approached. But, if you really do need support for this sort of thing, it can be done, with the help of the plain JavaScript implementation of `_.set()` and `_.zip()`.\n\n```javascript\nfunction set(object, path, value) {\n  if (typeof path === 'string') {\n    const isQuoted = str => str[0] === '\"' && str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x => x)\n      .map(x => !isNaN(Number(x)) ? Number(x) : x)\n      .map(x => typeof x === 'string' && isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = value;\n    return object;\n  }\n\n  if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  set(object[head], tail, value);\n  return object;\n}\n\nfunction zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(arrays.map(arr => arr[i]));\n  }\n\n  return result;\n}\n\nfunction zipObjectDeep(props, values) {\n  const resultObj = {};\n  for (const [path, value] of zip(props, values)) {\n    set(resultObj, path, value);\n  }\n\n  return resultObj;\n}\n```\n\nNote that the support for string paths in the above `zipObjectDeep()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.zipObjectDeep()` isn't all that different in this regard.\n","src":null,"test":""},{"name":"zipWith","manifest":{"fnSignature":"_.zipWith(...arrays, iteratee)","lodashLink":"https://lodash.com/docs/4.17.15#zipWith","summary":"This method is like `_.zip` except that it accepts `iteratee` to specify how grouped values should be combined."},"description":"```javascript\nfunction zipWith(...args) {\n  const arrays = args.slice(0, -1);\n  const iteratee = args.at(-1);\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(iteratee(...arrays.map(arr => arr[i])));\n  }\n\n  return result;\n}\n```\n","src":null,"test":""}]},{"categoryHeading":"Collection","entries":[{"name":"countBy","manifest":{"fnSignature":"_.countBy(collection, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#countBy","summary":"Creates an object composed of keys generated from the results of running each element of `collection` thru `iteratee`. The corresponding value of each key is the number of times the key was returned by `iteratee`."},"description":"```javascript\n// collection must be an iterable (such as an array)\nfunction countBy(collection, iteratee = x => x) {\n  const result = {};\n  for (const value of collection) {\n    const changedValue = iteratee(value);\n    result[changedValue] ??= 0;\n    result[changedValue]++;\n  }\n  return result;\n}\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n","src":null,"test":"function countBy(array, iteratee = x => x) {\n  const result = {};\n  for (const value of array) {\n    const changedValue = iteratee(value);\n    result[changedValue] ??= 0;\n    result[changedValue]++;\n  }\n  return result;\n}\n\ndescribe('countBy()', () => {\n  it('can can count values in the array via the provided iteratee', () => {\n    const result = countBy([6.1, 4.2, 6.3], Math.floor);\n    expect(result).toEqual({ 4: 1, 6: 2 });\n  });\n\n  it('can use its default parameter', () => {\n    const result = countBy(['A', 'B', 'A']);\n    expect(result).toEqual({ A: 2, B: 1 });\n  });\n\n  it('returns an empty object when given an empty array', () => {\n    const result = countBy([]);\n    expect(result).toEqual({});\n  });\n});\n"},{"name":"every","manifest":{"fnSignature":"_.every(collection, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#every","summary":"Checks if `predicate` returns truthy for all elements of `collection`."},"description":"```javascript\n// collection must be an array\ncollection.every(predicate)\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert iterables into an array, use the spread syntax (e.g. `[...collection]`).\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n","src":null,"test":""},{"name":"filter","manifest":{"fnSignature":"_.filter(collection, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#filter","summary":"Iterates over elements of `collection`, returning an array of all elements `predicate` returns truthy for."},"description":"```javascript\n// collection must be an array\ncollection.filter(predicate)\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert iterables into an array, use the spread syntax (e.g. `[...collection]`).\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n","src":null,"test":""},{"name":"find","manifest":{"fnSignature":"_.find(collection, predicate?, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#find","summary":"Iterates over elements of `collection`, returning the first element `predicate` returns truthy for."},"description":"```javascript\n// collection must be an array\ncollection.find(predicate)\n```\n\nOr if you want to start searching from a particular index, you can do:\n\n```javascript\n// collection must be an array\ncollection.slice(fromIndex).find(predicate)\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert iterables into an array, use the spread syntax (e.g. `[...collection]`).\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n","src":null,"test":""},{"name":"findLast","manifest":{"fnSignature":"_.findLast(collection, predicate?, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#findLast","summary":"This method is like _.find except that it iterates over elements of `collection` from right to left."},"description":"```javascript\n// collection must be an array\ncollection.findLast(predicate)\n```\n\nOr if you want to start searching from a particular index, you can do:\n\n```javascript\n// collection must be an array\ncollection.slice(0, fromIndex + 1).findLast(predicate)\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert iterables into an array, use the spread syntax (e.g. `[...collection]`).\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n","src":null,"test":""},{"name":"flatMap","manifest":{"fnSignature":"_.flatMap(collection, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#flatMap","summary":"Creates a flattened array of values by running each element in `collection` thru `iteratee` and flattening the mapped results."},"description":"```javascript\n// collection must be an array\ncollection.flatMap(iteratee)\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert iterables into an array, use the spread syntax (e.g. `[...collection]`).\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n","src":null,"test":""},{"name":"flatMapDeep","manifest":{"fnSignature":"_.flatMapDeep(collection, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#flatMapDeep","summary":"This method is like `_.flatMap` except that it recursively flattens the mapped results."},"description":"```javascript\n// collection must be an array\ncollection.map(iteratee).flat(Infinity)\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert iterables into an array, use the spread syntax (e.g. `[...collection]`).\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n","src":null,"test":""},{"name":"flatMapDepth","manifest":{"fnSignature":"_.flatMapDepth(collection, iteratee?, depth?)","lodashLink":"https://lodash.com/docs/4.17.15#flatMapDepth","summary":"This method is like `_.flatMap` except that it recursively flattens the mapped results up to `depth` times."},"description":"```javascript\n// collection must be an array\ncollection.map(iteratee).flat(depth)\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert iterables into an array, use the spread syntax (e.g. `[...collection]`).\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n","src":null,"test":""},{"name":"forEach","manifest":{"fnSignature":"_.forEach(collection, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#forEach","summary":"Iterates over elements of collection and invokes iteratee for each element."},"description":"```javascript\n// collection can be any iterable (such as an array)\nfor (const value of collection) {\n  iteratee(value);\n}\n```\n\nIf you need both the array index and value as you iterate, you can use the `.entries()` function on the array like so:\n\n```javascript\n// collection must be an array\nfor (const [i, value] of collection.entries()) {\n  iteratee(value);\n}\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert iterables into an array, use the spread syntax (e.g. `[...collection]`).\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n\nJavaScript also offers an `array.forEach()` function which behaves similarly to Lodash's `_.forEach()` (with the biggest difference being that you can't break out of the native `.forEach()` loop early, while you can in Lodash's version by returning `false`). In practice, there's no real reason to use the native `.forEach()` function anymore. The newer \"for of\" syntax presented above is strictly better and more powerful than `.forEach()`:\n* It supports `break` and `continue`.\n* You can do `await` inside a \"for of\" loop. [\"await\" will not work properly in `.forEach()`](https://stackoverflow.com/questions/37576685/using-async-await-with-a-foreach-loop).\n* You can use `return` to return early from a function from inside your loop.\n* \"for-of\" works with any iterable, including some odd-ball ones like the arguments object.\n","src":null,"test":""},{"name":"forEachRight","manifest":{"fnSignature":"_.forEachRight(collection, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#forEachRight","summary":"This method is like `_.forEach` except that it iterates over elements of `collection` from right to left."},"description":"```javascript\n// collection must be an array\nfor (const value of collection.toReversed()) {\n  iteratee();\n}\n```\n\nIf you need both the array index and value as you iterate, you can use the `.entries()` function on the array like so:\n\n```javascript\n// collcetion must be an iterable (such as an array)\nfor (const [i, value] of [...collection.entries()].toReversed()) {\n  iteratee(value);\n}\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert iterables into an array, use the spread syntax (e.g. `[...collection]`).\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.","src":null,"test":""},{"name":"groupBy","manifest":{"fnSignature":"_.groupBy(collection, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#groupBy","summary":"Creates an object composed of keys generated from the results of running each element of collection thru iteratee."},"description":"```javascript\n// collection must be an iterable (such as an array)\nObject.groupBy(collection, iteratee)\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n","src":null,"test":""},{"name":"includes","manifest":{"fnSignature":"_.includes(collection, value, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#includes","summary":"Checks if value is in collection."},"description":"To search for an item in an array:\n\n```javascript\narray.includes(item)\n```\n\nTo search for an item in an array-like value:\n\n```javascript\nArray.from(array).includes(item)\n```\n\nTo search for a property value in an object:\n\n```javascript\nObject.values(yourObject).includes(item)\n```\n\nTo search for a substring in a string:\n\n```javascript\nstring.includes(subString)\n```\n\nMany iterables will provide some form of an `.includes()` method, but if they don't, you can convert the iterable to an array before looking for a value in there.\n\n```javascript\n[...array].includes(item)\n```\n","src":null,"test":""},{"name":"invokeMap","manifest":{"fnSignature":"_.invokeMap(collection, path, ...args)","lodashLink":"https://lodash.com/docs/4.17.15#invokeMap","summary":"Invokes the method at path of each element in collection, returning an array of the results of each invoked method."},"description":"They give the following usage example, which calls a method on each value in your array:\n\n```javascript\n_.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n// => [[1, 5, 7], [1, 2, 3]]\n```\n\nThe equivalent in JavaScript would be:\n\n```javascript\n[[5, 1, 7], [3, 2, 1]].map(value => value.sort())\n```\n\nLodash's `_.invokeMap()` also has a completely separate use-case with it - it can behave like a regular `.map()`, except it passes each value to the callback as the \"this\" parameter instead of a normal parameter, as they demonstraighted with this example:\n\n```javascript\n_.invokeMap([123, 456], String.prototype.split, '');\n// => [['1', '2', '3'], ['4', '5', '6']]\n```\n\nThe generalized equivalent in JavaScript would be to use a normal `.map()` with a `.call()` as follows:\n\n```javascript\n[123, 456].map(value => String.prototype.split.call(value, ''))\n```\n\nThough in this specific example, you can just do this:\n\n```javascript\n[123, 456].map(value => String(value).split(''))\n```\n\nThe use of `.map()` requres an array. If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert iterables into an array, use the spread syntax (e.g. `[...collection]`).\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n\nIf you're using `_.invokeMap()` but your path argument is a string or an array of strings, then you can use the JavaScript equivalent to [Lodash's `_.invoke()`](#!/nolodash/invoke) inside of a `.map()` as follows:\n\n```javascript\n// Please see the \"_.invoke()\" documentation entry to see\n// how to implement it.\narray.map(value => invoke(value, path, ...args))\n```\n","src":null,"test":""},{"name":"keyBy","manifest":{"fnSignature":"_.keyBy(collection, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#keyBy","summary":"Creates an object composed of keys generated from the results of running each element of `collection` thru `iteratee`. The corresponding value of each key is the last element responsible for generating the key."},"description":"```javascript\n// collection must be an iterable\nfunction keyBy(collection, iteratee = x => x) {\n  const result = {};\n  for (const value of collection) {\n    const key = iteratee(value);\n    result[key] = value;\n  }\n  return result;\n}\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n","src":null,"test":"function keyBy(collection, iteratee = x => x) {\n  const result = {};\n  for (const value of collection) {\n    const key = iteratee(value);\n    result[key] = value;\n  }\n  return result;\n}\n\ndescribe('keyBy()', () => {\n  it('will group array entries into an object, according to the keys returned by iteratee', () => {\n    const array = [\n      { dir: 'left', code: 97 },\n      { dir: 'right', code: 100 },\n    ];\n\n    const result = keyBy(array, o => String.fromCharCode(o.code));\n\n    expect(result).toEqual({\n      a: { dir: 'left', code: 97 },\n      d: { dir: 'right', code: 100 },\n    });\n  });\n\n  it('will use the last-found value when a conflict occures', () => {\n    const array = [3, 4, 5];\n\n    const result = keyBy(array, n => (n % 2 === 0 ? 'even' : 'odd'));\n\n    expect(result).toEqual({\n      even: 4,\n      odd: 5,\n    });\n  });\n});\n"},{"name":"map","manifest":{"fnSignature":"_.map(collection, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#map","summary":"Creates an array of values by running each element in `collection` thru `iteratee`. "},"description":"```javascript\n// collection must be an array\ncollection.map(iteratee)\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert iterables into an array, use the spread syntax (e.g. `[...collection]`).\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n","src":null,"test":""},{"name":"orderBy","manifest":{"fnSignature":"_.orderBy(collection, iteratees, orders)","lodashLink":"https://lodash.com/docs/4.17.15#orderBy","summary":"This method is like `_.sortBy` except that it allows specifying the sort orders of the iteratees to sort by. You can specify an order of \"desc\" for descending or \"asc\" for ascending sort order of corresponding values."},"description":"To support using multiple \"iteratee\" functions:\n\n```javascript\n// collection must be an array\n// orders should be an array of \"asc\" or \"desc\" strings.\nfunction orderBy(collection, iteratees, orders) {\n  return collection.sort((value1, value2) => {\n    for (const [i, iteratee] of iteratees.entries()) {\n      const reverseSortOrder = orders[i] === 'desc';\n      const comparable1 = iteratee(value1);\n      const comparable2 = iteratee(value2);\n      if (comparable1 < comparable2) return reverseSortOrder ? 1 : -1;\n      if (comparable1 > comparable2) return reverseSortOrder ? -1 : 1;\n    }\n    return 0;\n  });\n}\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert iterables into an array, use the spread syntax (e.g. `[...collection]`).\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n","src":null,"test":"function orderBy(collection, iteratees, orders) {\n  return collection.sort((value1, value2) => {\n    for (const [i, iteratee] of iteratees.entries()) {\n      const reverseSortOrder = orders[i] === 'desc';\n      const comparable1 = iteratee(value1);\n      const comparable2 = iteratee(value2);\n      if (comparable1 < comparable2) return reverseSortOrder ? 1 : -1;\n      if (comparable1 > comparable2) return reverseSortOrder ? -1 : 1;\n    }\n    return 0;\n  });\n}\n\ndescribe('orderBy()', () => {\n  it('sorts using the iteratee functions and order instructions', () => {\n    const users = [\n      { user: 'fred', age: 48 },\n      { user: 'barney', age: 36 },\n      { user: 'fred', age: 40 },\n      { user: 'barney', age: 34 },\n    ];\n\n    const result = orderBy(users, [o => o.user, o => o.age], ['asc', 'desc']);\n\n    expect(result).toEqual([\n      { user: 'barney', age: 36 },\n      { user: 'barney', age: 34 },\n      { user: 'fred', age: 48 },\n      { user: 'fred', age: 40 },\n    ]);\n  });\n});\n"},{"name":"partition","manifest":{"fnSignature":"_.partition(collection, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#partition","summary":"Creates an array of elements split into two groups, the first of which contains elements predicate returns truthy for, the second of which contains elements predicate returns falsey for."},"description":"In Lodash, you might use the partition function to sort between evens and odds as follows:\n\n```javascript\nconst numbers = [2, 3, 7, 8, 9];\n\nconst [evens, odds] = _.partition(numbers, n => n % 2 === 0);\n// evens -> [ 2, 8 ]\n// odds -> [ 3, 7, 9 ]\n```\n\nThe same objective can be accomplished in JavaScript as follows:\n\n```javascript\nconst numbers = [2, 3, 7, 8, 9];\n\nconst { true: evens, false: odds } = Object.groupBy(numbers, n => n % 2 === 0);\n// evens -> [ 2, 8 ]\n// odds -> [ 3, 7, 9 ]\n```\n","src":null,"test":""},{"name":"reduce","manifest":{"fnSignature":"_.reduce(collection, iteratee, accumulator?)","lodashLink":"https://lodash.com/docs/4.17.15#reduce","summary":"Reduces collection to a value which is the accumulated result of running each element in collection thru iteratee, where each successive invocation is supplied the return value of the previous."},"description":"```javascript\n// collection must be an array\ncollection.reduce(iteratee, accumulator)\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert iterables into an array, use the spread syntax (e.g. `[...collection]`).\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n","src":null,"test":""},{"name":"reduceRight","manifest":{"fnSignature":"_.reduceRight(collection, iteratee, accumulator?)","lodashLink":"https://lodash.com/docs/4.17.15#reduceRight","summary":"This method is like `_.reduce` except that it iterates over elements of `collection` from right to left."},"description":"```javascript\n// collection must be an array\ncollection.toReversed().reduce(iteratee, accumulator)\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert iterables into an array, use the spread syntax (e.g. `[...collection]`).\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n","src":null,"test":""},{"name":"reject","manifest":{"fnSignature":"_.reject(collection, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#reject","summary":"The opposite of `_.filter`; this method returns the elements of `collection` that `predicate` does **not** return truthy for."},"description":"```javascript\n// collection must be an array\ncollection.filter(value => !predicate(value))\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert iterables into an array, use the spread syntax (e.g. `[...collection]`).\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n","src":null,"test":""},{"name":"sample","manifest":{"fnSignature":"_.sample(collection)","lodashLink":"https://lodash.com/docs/4.17.15#sample","summary":"Gets a random element from `collection`."},"description":"```javascript\n// collection must be array-like\nfunction sample(collection) {\n  return collection[Math.floor(Math.random() * collection.length)];\n}\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert iterables into an array, use the spread syntax (e.g. `[...collection]`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n","src":null,"test":""},{"name":"sampleSize","manifest":{"fnSignature":"_.sampleSize(collection, n)","lodashLink":"https://lodash.com/docs/4.17.15#sampleSize","summary":"Gets `n` random elements at unique keys from `collection` up to the size of `collection`."},"description":"```javascript\n// collection must be iterable\nfunction sampleSize(collection_, n) {\n  const collection = [...collection_];\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    const randomIndex = Math.floor(Math.random() * collection.length);\n    result.push(collection[randomIndex]);\n    collection.splice(randomIndex, 1);\n  }\n  return result;\n}\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n","src":null,"test":""},{"name":"shuffle","manifest":{"fnSignature":"_.shuffle(collection)","lodashLink":"https://lodash.com/docs/4.17.15#shuffle","summary":"Creates an array of shuffled values."},"description":"```javascript\n// collection must be an array\nfunction shuffle(collection) {\n  return collection\n    .map(value => ({ value, order: Math.random() }))\n    .sort((a, b) => a.order - b.order)\n    .map(({ value }) => value);\n}\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert iterables into an array, use the spread syntax (e.g. `[...collection]`).\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n\nSometimes you'll see a recommendation to shuffle using an algorithm such as this:\n\n```javascript\nfunction shuffle(collection) {\n  return collection.sort(() => Math.random() - 0.5);\n}\n```\n\nSuch an algorithm has the appearance of working, but it is actually a very bias and broken shuffle. This is because a random choice is being made at each comparison, causing some elements to be compared more often than others, which in turn results in this bias.\n","src":null,"test":""},{"name":"size","manifest":{"fnSignature":"_.size(collection)","lodashLink":"https://lodash.com/docs/4.17.15#size","summary":"Gets the size of `collection` by returning its length for array-like values or the number of own enumerable string keyed properties for objects."},"description":"To get the size of arrays and array-likes:\n\n```javascript\narray.length\n```\n\nTo get the number of own, enumerable, string-keyed properties in an object:\n\n```javascript\nObject.keys(obj).length\n```\n","src":null,"test":""},{"name":"some","manifest":{"fnSignature":"_.some(collection)","lodashLink":"https://lodash.com/docs/4.17.15#some","summary":"Checks if `predicate` returns truthy for any element of `collection`."},"description":"```javascript\n// collection must be an array\ncollection.some(predicate)\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert iterables into an array, use the spread syntax (e.g. `[...collection]`).\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n","src":null,"test":""},{"name":"sortBy","manifest":{"fnSignature":"_.sortBy(collection, iteratees)","lodashLink":"https://lodash.com/docs/4.17.15#sortBy","summary":"Creates an array of elements, sorted in ascending order by the results of running each element in a collection thru each iteratee."},"description":"To sort using a single \"iteratee\" (sort) function:\n\n```javascript\n// collection must be an array\nfunction sortBy(collection, iteratee) {\n  return collection.sort((value1, value2) => {\n    const comparable1 = iteratee(value1);\n    const comparable2 = iteratee(value2);\n    if (comparable1 < comparable2) return -1;\n    if (comparable1 > comparable2) return 1;\n    return 0;\n  });\n}\n```\n\nTo support using multiple \"iteratee\" functions:\n\n```javascript\n// collection must be an array\nfunction sortBy(collection, iteratees) {\n  return collection.sort((value1, value2) => {\n    for (const iteratee of iteratees) {\n      const comparable1 = iteratee(value1);\n      const comparable2 = iteratee(value2);\n      if (comparable1 < comparable2) return -1;\n      if (comparable1 > comparable2) return 1;\n    }\n    return 0;\n  });\n}\n```\n\nIf you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:\n* To convert iterables into an array, use the spread syntax (e.g. `[...collection]`).\n* To convert array-likes into an array, use [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) (e.g. `Array.from(collection)`).\n* To convert objects into an array, use [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), or [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) depending on what your needs are.\n","src":null,"test":"describe('sortBy() supporting only one iteratee', () => {\n  function sortBy(collection, iteratee) {\n    return collection.sort((value1, value2) => {\n      const comparable1 = iteratee(value1);\n      const comparable2 = iteratee(value2);\n      if (comparable1 < comparable2) return -1;\n      if (comparable1 > comparable2) return 1;\n      return 0;\n    });\n  }\n\n  it('sorts using the iteratee function', () => {\n    const users = [\n      { user: 'fred', age: 48 },\n      { user: 'barney', age: 36 },\n      { user: 'fred', age: 40 },\n      { user: 'barney', age: 34 },\n    ];\n\n    const result = sortBy(users, o => o.user);\n\n    expect(result).toEqual([\n      { user: 'barney', age: 36 },\n      { user: 'barney', age: 34 },\n      { user: 'fred', age: 48 },\n      { user: 'fred', age: 40 },\n    ]);\n  });\n});\n\ndescribe('sortBy() supporting multiple iteratees', () => {\n  function sortBy(collection, iteratees) {\n    return collection.sort((value1, value2) => {\n      for (const iteratee of iteratees) {\n        const comparable1 = iteratee(value1);\n        const comparable2 = iteratee(value2);\n        if (comparable1 < comparable2) return -1;\n        if (comparable1 > comparable2) return 1;\n      }\n      return 0;\n    });\n  }\n\n  it('sorts using the iteratee functions', () => {\n    const users = [\n      { user: 'fred', age: 48 },\n      { user: 'barney', age: 36 },\n      { user: 'fred', age: 40 },\n      { user: 'barney', age: 34 },\n    ];\n\n    const result = sortBy(users, [o => o.user, o => o.age]);\n\n    expect(result).toEqual([\n      { user: 'barney', age: 34 },\n      { user: 'barney', age: 36 },\n      { user: 'fred', age: 40 },\n      { user: 'fred', age: 48 },\n    ]);\n  });\n});\n"}]},{"categoryHeading":"Date","entries":[{"name":"now","manifest":{"fnSignature":"_.now()","lodashLink":"https://lodash.com/docs/4.17.15#now","summary":"Gets the timestamp of the number of milliseconds that have elapsed since the Unix epoch."},"description":"```javascript\nDate.now();\n```\n","src":null,"test":""}]},{"categoryHeading":"Function","entries":[{"name":"after","manifest":{"fnSignature":"_.after(n, func)","lodashLink":"https://lodash.com/docs/4.17.15#after","summary":"The opposite of `_.before`; this method creates a function that invokes `func` once it's called `n` or more times."},"description":"`_.after()` was a convenient helper function back when asynchronous programming was done primarily through callbacks - it allowed you execute a function after a number of asynchronous tasks have finished, as shown in this example from their documentation.\n\n```javascript\nvar saves = ['profile', 'settings'];\n \nvar done = _.after(saves.length, function() {\n  console.log('done saving!');\n});\n \n_.forEach(saves, function(type) {\n  asyncSave({ 'type': type, 'complete': done });\n});\n// => Logs 'done saving!' after the two async saves have completed.\n```\n\nNow days, the `asyncSave()` function from the example would typically be written to return a promise instead of accepting a callback (and if its not, you can convert it to a promise-based function yourself with the [Promise constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise)). With a promise-based `asyncSave()`, we can rewrite this example to just use `Promise.all()` instead.\n\n```javascript\nawait Promise.all([\n  asyncSave({ type: 'profile' }),\n  asyncSave({ type: 'settings' }),\n])\n\nconsole.log('done saving!');\n// => Logs 'done saving!' after the two async saves have completed.\n```\n\nIf the `saves` array is dynamically generated, you can use the [`Promise.all()` + `array.map()` pattern](https://stackoverflow.com/a/37576787/7696223).\n\n```javascript\nconst saves = getAnArrayFromSomewhere();\n \nawait Promise.all(saves.map(async type => {\n  await asyncSave({ type });\n}))\n\nconsole.log('done saving!');\n// => Logs 'done saving!' after the two async saves have completed.\n```\n\nThat being said, if you need a utility that acts like Lodash's `_.after()`, here's how you could code it up:\n\n```javascript\nfunction after(n, func) {\n  let callCount = 0;\n  return function(...args) {\n    callCount++;\n    if (callCount < n) {\n      return;\n    }\n\n    // Using .call() may be overkill.\n    // You could just do `return func(...args)` if you\n    // don't need to worry about preserving the \"this\" argument.\n    return func.call(this, ...args);\n  };\n}\n```\n","src":null,"test":"function after(n, func) {\n  let callCount = 0;\n  return function (...args) {\n    callCount++;\n    if (callCount < n) {\n      return;\n    }\n\n    // Using .call() may be overkill.\n    // You could just do `return func(...args)` if you\n    // don't need to worry about preserving the \"this\" argument.\n    return func.call(this, ...args);\n  };\n}\n\ndescribe('after()', () => {\n  it('calls the passed-in callback as normal once returned function has been called n times', () => {\n    const fn = after(3, (x, y) => x + y);\n\n    expect(fn(2, 3)).toEqual(undefined);\n    expect(fn(2, 3)).toEqual(undefined);\n    expect(fn(2, 3)).toEqual(5);\n  });\n\n  it('preserves the \"this\" argument', () => {\n    let self;\n\n    const fn = after(1, function () {\n      self = this;\n    });\n\n    const myThis = { x: 2 };\n    fn.call(myThis);\n\n    expect(self).toEqual(myThis);\n  });\n});\n"},{"name":"ary","manifest":{"fnSignature":"_.ary(func, n)","lodashLink":"https://lodash.com/docs/4.17.15#ary","summary":"Creates a function that invokes `func`, with up to `n` arguments, ignoring any additional arguments."},"description":"`_.ary()` was created before JavaScript provided arrow function syntax. Now days, it's fairly easy and concise to just use an arrow function to accomplish the same job.\n\n\n```javascript\n// An example of using _.ary() from their documentation\n_.map(['6', '8', '10'], _.ary(parseInt, 1)); // => [6, 8, 10]\n\n// How you can do the same thing with an arrow function\n['6', '8', '10'].map(n => parseInt(n)); // => [6, 8, 10]\n```\n\nIf you wish to have a utility function that acts like Lodash's `_.ary()`, you can use the following:\n\n```javascript\nfunction ary(func, n) {\n  return function(...args) {\n    // Using .call() may be overkill.\n    // You could just do `return func(...args.slice(0, n))` if you\n    // don't need to worry about preserving the \"this\" argument.\n    return func.call(this, ...args.slice(0, n));\n  };\n}\n```\n","src":null,"test":"function ary(func, n) {\n  return function (...args) {\n    // Using .call() may be overkill.\n    // You could just do `return func(...args.slice(0, n))` if you\n    // don't need to worry about preserving the \"this\" argument.\n    return func.call(this, ...args.slice(0, n));\n  };\n}\n\ndescribe('ary()', () => {\n  it('only passes in the first n arguments', () => {\n    const fn = ary((x, y, z) => [x, y, z], 2);\n\n    expect(fn(2, 3, 4)).toEqual([2, 3, undefined]);\n  });\n\n  it('preserves the \"this\" argument', () => {\n    let self;\n\n    const fn = ary(function () {\n      self = this;\n    }, 0);\n\n    const myThis = { x: 2 };\n    fn.call(myThis);\n\n    expect(self).toEqual(myThis);\n  });\n});\n"},{"name":"before","manifest":{"fnSignature":"_.before(n, func)","lodashLink":"https://lodash.com/docs/4.17.15#before","summary":"Creates a function that invokes `func`, with the `this` binding and arguments of the created function, while it's called less than `n` times. Subsequent calls to the created function return the result of the last `func` invocation."},"description":"```javascript\nfunction before(n, func) {\n  let lastResult;\n  return function(...args) {\n    n--;\n    if (n <= 0) {\n      return lastResult;\n    }\n\n    lastResult = func.call(this, ...args);\n    return lastResult;\n  };\n}\n```\n\nPersonally, I'm not sure why a function like this is all that useful. If you ever find this function to be helpful, I'd be interested to hear why - you can open a GitHub issue and let me know.\n\nIf you want to use this function with `n=1`, then refer to `_.once()` instead.\n","src":null,"test":"function before(n, func) {\n  let lastResult;\n  return function (...args) {\n    n--;\n    if (n <= 0) {\n      return lastResult;\n    }\n\n    lastResult = func.call(this, ...args);\n    return lastResult;\n  };\n}\n\ndescribe('before()', () => {\n  it('returns the last result after n calls', () => {\n    const fn = before(4, x => x ** 2);\n\n    expect(fn(1)).toEqual(1);\n    expect(fn(2)).toEqual(4);\n    expect(fn(3)).toEqual(9);\n    expect(fn(4)).toEqual(9);\n    expect(fn(5)).toEqual(9);\n  });\n\n  it('preserves the \"this\" argument', () => {\n    let self;\n    const fn = before(3, function () {\n      self = this;\n    });\n\n    const myThis = { x: 2 };\n    fn.call(myThis);\n\n    expect(self).toEqual(myThis);\n  });\n});\n"},{"name":"bind","manifest":{"fnSignature":"_.bind(func, thisArg, ...partials)","lodashLink":"https://lodash.com/docs/4.17.15#bind","summary":"Creates a function that invokes `func` with the `this` binding of `thisArg` and `partials` prepended to the arguments it receives."},"description":"You can use an arrow function to get the same effect, or the native `.bind()` method will work for most use cases as well.\n\nTo bind a method to the object it is found on:\n\n```javascript\n// Instead of this\n_.bind(obj.method, obj)\n\n// You can use an arrow function\n(...args) => obj.method(...args)\n\n// or you can use the native .bind() method.\nobj.method.bind(obj)\n```\n\nTo bind a method to any object:\n\n```javascript\n// Instead of this\n_.bind(obj.method, anyObj)\n\n// You can use an arrow function with .call()\n(...args) => obj.method.call(anyObj, ...args)\n\n// or you can use the native .bind() method.\nobj.method.bind(anyObj)\n```\n\nIf you wish to partially apply some initial arguments:\n\n```javascript\n// Instead of this\n_.bind(obj.method, obj, 1, 2, 3)\n\n// You can use an arrow function\n(...args) => obj.method(1, 2, 3, ...args)\n\n// or you can use the native .bind() method.\nobj.method.bind(obj, 1, 2, 3)\n```\n\nIf you wish to partially apply some arguments from any position\n\n```javascript\n// Instead of this\n_.bind(obj.method, obj, 1, _, 2, 3)\n\n// You can use an arrow function\nx => obj.method(1, x, 2, 3)\n```","src":null,"test":""},{"name":"bindKey","manifest":{"fnSignature":"_.bindKey(object, key, ...partials)","lodashLink":"https://lodash.com/docs/4.17.15#bindKey","summary":"Creates a function that invokes the method at `object[key]` with `partials` prepended to the arguments it receives. This method differs from `_.bind` by allowing bound functions to reference methods that may be redefined or don't yet exist."},"description":"You can use arrow functions to achieve the same results.\n\nTo bind a method's this parameter to the object it is found on:\n\n```javascript\n// Instead of this\n_.bindKey(obj, 'method')\n\n// You can use an arrow function\n(...args) => obj.method(...args)\n```\n\nIf you wish to partially apply some initial arguments in addition to binding a this parameter:\n\n```javascript\n// Instead of this\n_.bindKey(obj, 'method', 1, 2, 3)\n\n// You can use an arrow function\n(...args) => obj.method(1, 2, 3, ...args)\n```\n\nIf you wish to partially apply some arguments from any position in addition to binding a this parameter:\n\n```javascript\n// Instead of this\n_.bindKey(obj, 'method', 1, _, 2, 3)\n\n// You can use an arrow function\nx => obj.method(1, x, 2, 3)\n```\n\nNotice that if we changed the `method` property on `obj` and swap it out for a new method, both the arrow function and `_.bindKey` will start invoking the new method, while using the native `.bind()` method or Lodash's `_.bind()` will use the old method.\n\n```javascript\nconst obj = {\n  method: () => 'before'\n}\n\nconst lodashBindKeyFn = _.bindKey(obj, 'method');\nconst arrowFn = () => obj.method();\nconst lodashBindFn = _.bind(obj.method, obj);\nconst nativeBindFn = obj.method.bind(obj);\n\nobj.method = () => 'after';\n\nlodashBindKeyFn(); // 'after'\narrowFn(); // 'after'\nlodashBindFn(); // 'before'\nnativeBindFn(); // 'before'\n```","src":null,"test":""},{"name":"curryRight","manifest":{"fnSignature":"_.curryRight(func, arity?)","lodashLink":"https://lodash.com/docs/4.17.15#curryRight","summary":"This method is like _.curryRight except that arguments will be passed in in reverse order."},"description":"Currying is a principle of point-free programming, a programming style that JavaScript wasn't really designed to support. You can do it, but without the help of a third-party library, you'll just be fighting against the language and its uncurried standard library every step of the way. If you want to do point-free programming, you are better off adopting a library such as Rambda, which basically provides an alternative, pre-curried standard library along with some helper functions such as a replacement for Lodash's `_.curryRight()`.\n\nThat being said, you can easily curry-right any function by using arrow function syntax. For example, to curry-right a function that takes two arguments, do the following:\n\n```javascript\n// hasOwn() is a curried-right version of Object.hasOwn()\nconst hasOwn = prop => obj => Object.hasOwn(obj, prop);\n\n// Example usage:\nconst doesObjHaveMyProp = hasOwn('exampleProp');\nconsole.log(doesObjHaveMyProp({ exampleProp: 22 })); // true\n```\n\nIf you want a function that does it, you can use the following:\n\n```javascript\nfunction curryRight(func, arity, _appliedArgs = []) {\n  return (...args) => {\n    const newAppliedArgs = [...args, ..._appliedArgs];\n    if (newAppliedArgs.length < arity) {\n      return curryRight(func, arity, newAppliedArgs);\n    } else {\n      return func(...newAppliedArgs);\n    }\n  };\n}\n```\n\nAnd if you need support for being able to skip parameters when partially applying a curried function (i.e. passing in the `_` value when calling it), you can use the following:\n\n```javascript\nconst _ = Symbol('curry placeholder');\n\nfunction curryRight(func, arity, _appliedArgs = {}, _numApplied = 0) {\n  return (...args) => {\n    const appliedArgs = { ..._appliedArgs };\n    let numApplied = _numApplied;\n    for (let i = arity - 1; i >= 0; i--) {\n      if (i in appliedArgs) continue;\n      if (args.at(-1) !== _) {\n        numApplied++;\n        appliedArgs[i] = args.at(-1);\n      }\n      args.pop();\n      if (args.length === 0) break;\n    }\n\n    if (numApplied === arity) {\n      return func(...Array.from({ ...appliedArgs, length: arity }));\n    } else {\n      return curryRight(func, arity, appliedArgs, numApplied);\n    }\n  };\n}\n```\n\nNotice that the `curryRight()` functions above requires you to supply an `arity` parameter - it does not fall back to using `func.length` (i.e. the number of parameters `func` says it takes). This is purposely different from Lodash's `_.curryRight()`. Code maintainers often don't consider the `length` property of their functions to be a value they're supposed to keep stable between releases - in fact, many JavaScript developers are not even be aware of its existence. People are generally free to do updates such as `(x, y) => { ... }` to `(...args) => { ... }` or `(x, y) => { if (y === undefined) { y = someDefault; } ... }` to `(x, y=someDefault) => { ... }`. Lets keep it that way. Don't write fragile code that depends on the `.length` property of functions, causing your code to break if a refactoring like this occurs.\n","src":null,"test":"describe('curryRight() without \"_\" placeholder support', () => {\n  function curryRight(func, arity, _appliedArgs = []) {\n    return (...args) => {\n      const newAppliedArgs = [...args, ..._appliedArgs];\n      if (newAppliedArgs.length < arity) {\n        return curryRight(func, arity, newAppliedArgs);\n      } else {\n        return func(...newAppliedArgs);\n      }\n    };\n  }\n\n  it('can curry a function', () => {\n    const fn = curryRight((a, b) => a + b, 2);\n    expect(fn('a')('b')).toEqual('ba');\n  });\n\n  it('allows you to supply multiple arguments at once to a curried function', () => {\n    const fn = curryRight((a, b, c) => a + b + c, 3);\n    expect(fn('a', 'b')('c')).toEqual('cab');\n  });\n\n  it('can call a curried function with an arity argument of 0', () => {\n    const fn = curryRight(() => 'result', 0);\n    expect(fn()).toEqual('result');\n  });\n});\n\ndescribe('curryRight() with \"_\" placeholder support', () => {\n  const _ = Symbol('curry placeholder');\n\n  function curryRight(func, arity, _appliedArgs = {}, _numApplied = 0) {\n    return (...args) => {\n      const appliedArgs = { ..._appliedArgs };\n      let numApplied = _numApplied;\n      for (let i = arity - 1; i >= 0; i--) {\n        if (i in appliedArgs) continue;\n        if (args.at(-1) !== _) {\n          numApplied++;\n          appliedArgs[i] = args.at(-1);\n        }\n        args.pop();\n        if (args.length === 0) break;\n      }\n\n      if (numApplied === arity) {\n        return func(...Array.from({ ...appliedArgs, length: arity }));\n      } else {\n        return curryRight(func, arity, appliedArgs, numApplied);\n      }\n    };\n  }\n\n  it('can curry a function', () => {\n    const fn = curryRight((a, b) => a + b, 2);\n    expect(fn('b')('a')).toEqual('ab');\n  });\n\n  it('allows you to supply multiple arguments at once to a curried function', () => {\n    const fn = curryRight((a, b, c) => a + b + c, 3);\n    expect(fn('b', 'c')('a')).toEqual('abc');\n  });\n\n  it('allows you to skip parameters when partially apply a curried function', () => {\n    const fn = curryRight((a, b, c) => a + b + c, 3);\n    expect(fn('b', _)('a', 'c')).toEqual('abc');\n  });\n\n  it('allows you to fill all parameters except for skipped ones', () => {\n    const fn = curryRight((a, b, c, d) => a + b + c + d, 4);\n    expect(fn('a', _, _, 'd')('c')('b')).toEqual('abcd');\n  });\n\n  it('can call a curried function with an arity argument of 0', () => {\n    const fn = curryRight(() => 'result', 0);\n    expect(fn()).toEqual('result');\n  });\n});\n"},{"name":"curry","manifest":{"fnSignature":"_.curry(func, arity?)","lodashLink":"https://lodash.com/docs/4.17.15#curry","summary":"Creates a function that invokes the method at `object[key]` with `partials` prepended to the arguments it receives. This method differs from `_.bind` by allowing bound functions to reference methods that may be redefined or don't yet exist."},"description":"Currying is a principle of point-free programming, a programming style that JavaScript wasn't really designed to support. You can do it, but without the help of a third-party library, you'll just be fighting against the language and its uncurried standard library every step of the way. If you want to do point-free programming, you are better off adopting a library such as Rambda, which basically provides an alternative, pre-curried standard library along with some helper functions such as a replacement for Lodash's `_.curry()`.\n\nThat being said, you can easily curry any function by using arrow function syntax. For example, to curry a function that takes two arguments, do the following:\n\n```javascript\n// hasOwn() is a curried version of Object.hasOwn()\nconst hasOwn = obj => prop => Object.hasOwn(obj, prop);\n\n// Example usage:\nconst doesMyObjHaveProp = hasOwn({ a: 1, b: 2 });\nconsole.log(doesMyObjHaveProp('a')); // true\n```\n\nIf you want a function that does it, you can use the following:\n\n```javascript\nfunction curry(func, arity, _appliedArgs = []) {\n  return (...args) => {\n    const newAppliedArgs = [..._appliedArgs, ...args];\n    if (newAppliedArgs.length < arity) {\n      return curry(func, arity, newAppliedArgs)\n    } else {\n      return func(...newAppliedArgs);\n    }\n  };\n}\n```\n\nAnd if you need support for being able to skip parameters when partially applying a curried function (i.e. passing in the `_` value when calling it), you can use the following:\n\n```javascript\nconst _ = Symbol('curry placeholder');\n\nfunction curry(func, arity, _appliedArgs = {}, _numApplied = 0) {\n  return (...args) => {\n    const appliedArgs = { ..._appliedArgs };\n    let numApplied = _numApplied;\n    for (let i = 0; i < arity; i++) {\n      if (i in appliedArgs) continue;\n      if (args[0] !== _) {\n        numApplied++;\n        appliedArgs[i] = args[0];\n      }\n      args.shift();\n      if (args.length === 0) break;\n    }\n\n    if (numApplied === arity) {\n      return func(...Array.from({ ...appliedArgs, length: arity }));\n    } else {\n      return curry(func, arity, appliedArgs, numApplied);\n    }\n  };\n}\n```\n\nNotice that the `curry()` functions above requires you to supply an `arity` parameter - it does not fall back to using `func.length` (i.e. the number of parameters `func` says it takes). This is purposely different from Lodash's `_.curry()`. Code maintainers often don't consider the `length` property of their functions to be a value they're supposed to keep stable between releases - in fact, many JavaScript developers are not even be aware of its existence. People are generally free to do updates such as `(x, y) => { ... }` to `(...args) => { ... }` or `(x, y) => { if (y === undefined) { y = someDefault; } ... }` to `(x, y=someDefault) => { ... }`. Lets keep it that way. Don't write fragile code that depends on the `.length` property of functions, causing your code to break if a refactoring like this occurs.\n","src":null,"test":"describe('curry() without \"_\" placeholder support', () => {\n  function curry(func, arity, _appliedArgs = []) {\n    return (...args) => {\n      const newAppliedArgs = [..._appliedArgs, ...args];\n      if (newAppliedArgs.length < arity) {\n        return curry(func, arity, newAppliedArgs);\n      } else {\n        return func(...newAppliedArgs);\n      }\n    };\n  }\n\n  it('can curry a function', () => {\n    const fn = curry((a, b) => a + b, 2);\n    expect(fn('a')('b')).toEqual('ab');\n  });\n\n  it('allows you to supply multiple arguments at once to a curried function', () => {\n    const fn = curry((a, b, c) => a + b + c, 3);\n    expect(fn('a', 'b')('c')).toEqual('abc');\n  });\n\n  it('can call a curried function with an arity argument of 0', () => {\n    const fn = curry(() => 'result', 0);\n    expect(fn()).toEqual('result');\n  });\n});\n\ndescribe('curry() with \"_\" placeholder support', () => {\n  const _ = Symbol('curry placeholder');\n\n  function curry(func, arity, _appliedArgs = {}, _numApplied = 0) {\n    return (...args) => {\n      const appliedArgs = { ..._appliedArgs };\n      let numApplied = _numApplied;\n      for (let i = 0; i < arity; i++) {\n        if (i in appliedArgs) continue;\n        if (args[0] !== _) {\n          numApplied++;\n          appliedArgs[i] = args[0];\n        }\n        args.shift();\n        if (args.length === 0) break;\n      }\n\n      if (numApplied === arity) {\n        return func(...Array.from({ ...appliedArgs, length: arity }));\n      } else {\n        return curry(func, arity, appliedArgs, numApplied);\n      }\n    };\n  }\n\n  it('can curry a function', () => {\n    const fn = curry((a, b) => a + b, 2);\n    expect(fn('a')('b')).toEqual('ab');\n  });\n\n  it('allows you to supply multiple arguments at once to a curried function', () => {\n    const fn = curry((a, b, c) => a + b + c, 3);\n    expect(fn('a', 'b')('c')).toEqual('abc');\n  });\n\n  it('allows you to skip parameters when partially apply a curried function', () => {\n    const fn = curry((a, b, c) => a + b + c, 3);\n    expect(fn(_, 'b')('a', 'c')).toEqual('abc');\n  });\n\n  it('allows you to fill all parameters except for skipped ones', () => {\n    const fn = curry((a, b, c, d) => a + b + c + d, 4);\n    expect(fn('a', _, _, 'd')('b')('c')).toEqual('abcd');\n  });\n\n  it('can call a curried function with an arity argument of 0', () => {\n    const fn = curry(() => 'result', 0);\n    expect(fn()).toEqual('result');\n  });\n});\n"},{"name":"debounce","manifest":{"fnSignature":"_.debounce(func, wait, options?)","lodashLink":"https://lodash.com/docs/4.17.15#debounce","summary":"Creates a debounced function that delays invoking `func` until after `wait` milliseconds have elapsed since the last time the debounced function was invoked. The `func` is invoked with the last arguments provided to the debounced function. Subsequent calls to the debounced function return the result of the last `func` invocation. See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/) for details over the differences between `_.debounce` and `_.throttle`."},"description":"```javascript\n/*# METADATA\n[\n  {\n    \"id\": \"when\",\n    \"type\": \"radio\",\n    \"message\": \"When a user attempts to call your debounced function multiple times in quick succession, at what point should the wrapped function actually be called?\",\n    \"default\": \"trailing\",\n    \"options\": {\n      \"leading\": \"At the leading end of the series of calls.\",\n      \"trailing\": \"At the trailing end of the series of calls.\",\n      \"leadingAndTrailing\": \"At both the leading and trailing end of the series of calls.\"\n    }\n  },\n  {\n    \"id\": \"withHelpers\",\n    \"type\": \"radio\",\n    \"message\": \"Should functions be attached to the returned debounced function for additional control?\",\n    \"default\": \"none\",\n    \"options\": {\n      \"none\": \"No\",\n      \"cancel\": \"Provide a cancel function, to cancel delayed function invocations.\",\n      \"flushAndCancel\": \"In addition to a cancel function, provide a flush function that forces any delayed function invocations to run immediately.\"\n    }\n  }\n]\n#*/\n\n//# CONFIG { \"when\": \"leading\", \"withHelpers\": \"none\" }\n\n/**\n * Invokes the function `func` then starts a countdown for `wait` ms.\n * Any further invocations that happen during the countdown will be ignored,\n * and will reset the countdown back to `wait` ms.\n * @return The value that `func` returned when it was last called.\n */\nfunction debounceLeading(func, wait) {\n  let timeoutId = undefined;\n  let lastResult;\n\n  const debounced = (...args) => {\n    if (timeoutId === undefined) {\n      // Invokes the function and starts a countdown\n      lastResult = func(...args);\n      timeoutId = setTimeout(() => { timeoutId = undefined }, wait);\n    } else {\n      // Ignores this call and resets the countdown\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => { timeoutId = undefined }, wait);\n    }\n\n    return lastResult;\n  };\n\n  return debounced;\n}\n\n//# CONFIG { \"when\": \"leading\", \"withHelpers\": \"cancel\" }\n\n/**\n * Invokes the function `func` then starts a countdown for `wait` ms.\n * Any further invocations that happen during the countdown will be ignored,\n * and will reset the countdown back to `wait` ms.\n * @return The value that `func` returned when it was last called.\n */\nfunction debounceLeading(func, wait) {\n  let timeoutId = undefined;\n  let lastResult;\n\n  const debounced = (...args) => {\n    if (timeoutId === undefined) {\n      // Invokes the function and starts a countdown\n      lastResult = func(...args);\n      timeoutId = setTimeout(() => { timeoutId = undefined }, wait);\n    } else {\n      // Ignores this call and resets the countdown\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => { timeoutId = undefined }, wait);\n    }\n\n    return lastResult;\n  };\n\n  debounced.cancel = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n  };\n\n  return debounced;\n}\n\n//# CONFIG { \"when\": \"leading\", \"withHelpers\": \"flushAndCancel\" }\n\n/*\n.flush() doesn't actually make sense in the context of a leading-only debounce function,\nas there's nothing to flush - the callback has already been called.\n\nChoose a different combination of options :).\n*/\n\n//# CONFIG { \"when\": \"trailing\", \"withHelpers\": \"none\" }\n\n/**\n * Starts a countdown for `wait` ms.\n * Any invocations that happen during the countdown will reset the countdown\n * back to `wait` ms. When the countdown is done, the function `func` will be called.\n * @return The value that `func` returned when it was last called, or\n *   undefined if it hasn't been called yet.\n */\nfunction debounceTrailing(func, wait) {\n  let lastFuncResult = undefined;\n  let timeoutId = undefined;\n\n  const debounced = (...args) => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() => {\n      timeoutId = undefined;\n      lastFuncResult = func(...args);\n    }, wait);\n\n    return lastFuncResult;\n  };\n\n  return debounced;\n}\n\n//# CONFIG { \"when\": \"trailing\", \"withHelpers\": \"cancel\" }\n\n/**\n * Starts a countdown for `wait` ms.\n * Any invocations that happen during the countdown will reset the countdown\n * back to `wait` ms. When the countdown is done, the function `func` will be called.\n * @return The value that `func` returned when it was last called, or\n *   undefined if it hasn't been called yet.\n */\nfunction debounceTrailing(func, wait) {\n  let lastFuncResult = undefined;\n  let timeoutId = undefined;\n\n  const debounced = (...args) => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() => {\n      timeoutId = undefined;\n      lastFuncResult = func(...args);\n    }, wait);\n\n    return lastFuncResult;\n  };\n\n  debounced.cancel = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n  };\n\n  return debounced;\n}\n\n//# CONFIG { \"when\": \"trailing\", \"withHelpers\": \"flushAndCancel\" }\n\n/**\n * Starts a countdown for `wait` ms.\n * Any invocations that happen during the countdown will reset the countdown\n * back to `wait` ms. When the countdown is done, the function `func` will be called.\n * @return The value that `func` returned when it was last called, or\n *   undefined if it hasn't been called yet.\n */\nfunction debounceTrailing(func, wait) {\n  let lastFuncResult = undefined;\n  let timeoutId = undefined;\n  let debouncedArgs = undefined; // This will only be set when timeoutId is also set\n\n  const onTimeout = () => {\n    timeoutId = undefined;\n    try {\n      lastFuncResult = func(...debouncedArgs);\n    } finally {\n      debouncedArgs = undefined;\n    }\n    return lastFuncResult;\n  };\n\n  const debounced = (...args) => {\n    debouncedArgs = args;\n\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(onTimeout, wait);\n\n    return lastFuncResult;\n  };\n\n  debounced.cancel = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n      debouncedArgs = undefined;\n    }\n  };\n\n  debounced.flush = () => {\n    if (timeoutId === undefined) {\n      return lastFuncResult;\n    }\n\n    clearTimeout(timeoutId);\n    return onTimeout();\n  };\n\n  return debounced;\n}\n\n//# CONFIG { \"when\": \"leadingAndTrailing\", \"withHelpers\": \"none\" }\n\n/**\n * Invokes the function `func` then starts a countdown for `wait` ms.\n * Any further invocations that happen during the countdown will be ignored,\n * and will reset the countdown back to `wait` ms.\n * When the countdown expires, `func` will be called if there was an\n * attempt to call it during the countdown.\n * @return The value that `func` returned when it was last called.\n */\nfunction debounceLeadingAndTrailing(func, wait) {\n  let lastFuncResult;\n  let timeoutId = undefined;\n\n  const debounced = (...args) => {\n    if (timeoutId === undefined) {\n      // Invokes the function and starts a countdown\n      lastFuncResult = func(...args);\n      timeoutId = setTimeout(() => {\n        timeoutId = undefined;\n      }, wait);\n    } else {\n      // Ignores this call and resets the countdown.\n      // When the countdown ends, it'll now also call func() again.\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => {\n        timeoutId = undefined;\n        lastFuncResult = func(...args);\n      }, wait);\n    }\n\n    return lastFuncResult;\n  };\n\n  return debounced;\n}\n\n//# CONFIG { \"when\": \"leadingAndTrailing\", \"withHelpers\": \"cancel\" }\n\n/**\n * Invokes the function `func` then starts a countdown for `wait` ms.\n * Any further invocations that happen during the countdown will be ignored,\n * and will reset the countdown back to `wait` ms.\n * When the countdown expires, `func` will be called if there was an\n * attempt to call it during the countdown.\n * @return The value that `func` returned when it was last called.\n */\nfunction debounceLeadingAndTrailing(func, wait) {\n  let lastFuncResult;\n  let timeoutId = undefined;\n\n  const debounced = (...args) => {\n    if (timeoutId === undefined) {\n      // Invokes the function and starts a countdown\n      lastFuncResult = func(...args);\n      timeoutId = setTimeout(() => {\n        timeoutId = undefined;\n      }, wait);\n    } else {\n      // Ignores this call and resets the countdown.\n      // When the countdown ends, it'll now also call func() again.\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => {\n        timeoutId = undefined;\n        lastFuncResult = func(...args);\n      }, wait);\n    }\n\n    return lastFuncResult;\n  };\n\n  debounced.cancel = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n  };\n\n  return debounced;\n}\n\n//# CONFIG { \"when\": \"leadingAndTrailing\", \"withHelpers\": \"flushAndCancel\" }\n\n/**\n * Invokes the function `func` then starts a countdown for `wait` ms.\n * Any further invocations that happen during the countdown will be ignored,\n * and will reset the countdown back to `wait` ms.\n * When the countdown expires, `func` will be called if there was an\n * attempt to call it during the countdown.\n * @return The value that `func` returned when it was last called.\n */\nfunction debounceLeadingAndTrailingWithFlushSupport(func, wait) {\n  let lastFuncResult;\n  let timeoutId = undefined;\n  // Set to undefined when no countdown is active or\n  // the function does not need to be called during timeout handling.\n  // Otherwise, set to a list of arguments that'll be sent to `func` during\n  // timeout handling.\n  let debouncedArgs = undefined;\n\n  const onTimeout = () => {\n    timeoutId = undefined;\n    if (debouncedArgs !== undefined) {\n      lastFuncResult = func(...debouncedArgs);\n    }\n    return lastFuncResult;\n  };\n\n  const debounced = (...args) => {\n    if (timeoutId === undefined) {\n      // Invokes the function and starts a countdown\n      lastFuncResult = func(...args);\n      debouncedArgs = undefined;\n      timeoutId = setTimeout(onTimeout, wait);\n    } else {\n      // Ignores this call and resets the countdown.\n      // When the countdown ends, it'll now also call func() again.\n      clearTimeout(timeoutId);\n      debouncedArgs = args;\n      timeoutId = setTimeout(onTimeout, wait);\n    }\n\n    return lastFuncResult;\n  };\n\n  debounced.cancel = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n  };\n\n  debounced.flush = () => {\n    if (timeoutId === undefined) {\n      return lastFuncResult;\n    }\n    \n    clearTimeout(timeoutId);\n    return onTimeout();\n  };\n\n  return debounced;\n}\n\n```\n","src":null,"test":"/* global globalThis */\n\n// The below function is copied into description.md under\n//   //# CONFIG { \"when\": \"leading\", \"withHelpers\": \"none\" }\n//   (with the debounced.cancel() function removed)\n// and\n//   //# CONFIG { \"when\": \"leading\", \"withHelpers\": \"cancel\" }\n\n/**\n * Invokes the function `func` then starts a countdown for `wait` ms.\n * Any further invocations that happen during the countdown will be ignored,\n * and will reset the countdown back to `wait` ms.\n * @return The value that `func` returned when it was last called.\n */\nfunction debounceLeading(func, wait) {\n  let timeoutId = undefined;\n  let lastResult;\n\n  const debounced = (...args) => {\n    if (timeoutId === undefined) {\n      // Invokes the function and starts a countdown\n      lastResult = func(...args);\n      timeoutId = setTimeout(() => { timeoutId = undefined }, wait);\n    } else {\n      // Ignores this call and resets the countdown\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => { timeoutId = undefined }, wait);\n    }\n\n    return lastResult;\n  };\n\n  debounced.cancel = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n  };\n\n  return debounced;\n}\n\n// The below function is copied into description.md under\n//   //# CONFIG { \"when\": \"trailing\", \"withHelpers\": \"none\" }\n//   (with the debounced.cancel() function removed)\n// and\n//   //# CONFIG { \"when\": \"trailing\", \"withHelpers\": \"cancel\" }\n\n/**\n * Starts a countdown for `wait` ms.\n * Any invocations that happen during the countdown will reset the countdown\n * back to `wait` ms. When the countdown is done, the function `func` will be called.\n * @return The value that `func` returned when it was last called, or\n *   undefined if it hasn't been called yet.\n */\nfunction debounceTrailing(func, wait) {\n  let lastFuncResult = undefined;\n  let timeoutId = undefined;\n\n  const debounced = (...args) => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() => {\n      timeoutId = undefined;\n      lastFuncResult = func(...args);\n    }, wait);\n\n    return lastFuncResult;\n  };\n\n  debounced.cancel = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n  };\n\n  return debounced;\n}\n\n// The below function is copied into description.md under\n//   //# CONFIG { \"when\": \"trailing\", \"withHelpers\": \"flushAndCancel\" }\n//   (with the function renamed to simply debounceTrailing())\n\n/**\n * Starts a countdown for `wait` ms.\n * Any invocations that happen during the countdown will reset the countdown\n * back to `wait` ms. When the countdown is done, the function `func` will be called.\n * @return The value that `func` returned when it was last called, or\n *   undefined if it hasn't been called yet.\n */\nfunction debounceTrailingWithFlushSupport(func, wait) {\n  let lastFuncResult = undefined;\n  let timeoutId = undefined;\n  let debouncedArgs = undefined; // This will only be set when timeoutId is also set\n\n  const onTimeout = () => {\n    timeoutId = undefined;\n    try {\n      lastFuncResult = func(...debouncedArgs);\n    } finally {\n      debouncedArgs = undefined;\n    }\n    return lastFuncResult;\n  };\n\n  const debounced = (...args) => {\n    debouncedArgs = args;\n\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(onTimeout, wait);\n\n    return lastFuncResult;\n  };\n\n  debounced.cancel = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n      debouncedArgs = undefined;\n    }\n  };\n\n  debounced.flush = () => {\n    if (timeoutId === undefined) {\n      return lastFuncResult;\n    }\n\n    clearTimeout(timeoutId);\n    return onTimeout();\n  };\n\n  return debounced;\n}\n\n// The below function is copied into description.md under\n//   //# CONFIG { \"when\": \"leadingAndTrailing\", \"withHelpers\": \"none\" }\n//   (with the debounced.cancel() function removed)\n// and\n//   //# CONFIG { \"when\": \"leadingAndTrailing\", \"withHelpers\": \"cancel\" }\n\n/**\n * Invokes the function `func` then starts a countdown for `wait` ms.\n * Any further invocations that happen during the countdown will be ignored,\n * and will reset the countdown back to `wait` ms.\n * When the countdown expires, `func` will be called if there was an\n * attempt to call it during the countdown.\n * @return The value that `func` returned when it was last called.\n */\nfunction debounceLeadingAndTrailing(func, wait) {\n  let lastFuncResult;\n  let timeoutId = undefined;\n\n  const debounced = (...args) => {\n    if (timeoutId === undefined) {\n      // Invokes the function and starts a countdown\n      lastFuncResult = func(...args);\n      timeoutId = setTimeout(() => {\n        timeoutId = undefined;\n      }, wait);\n    } else {\n      // Ignores this call and resets the countdown.\n      // When the countdown ends, it'll now also call func() again.\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => {\n        timeoutId = undefined;\n        lastFuncResult = func(...args);\n      }, wait);\n    }\n\n    return lastFuncResult;\n  };\n\n  debounced.cancel = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n  };\n\n  return debounced;\n}\n\n// The below function is copied into description.md under\n//   //# CONFIG { \"when\": \"debounceLeadingAndTrailing\", \"withHelpers\": \"flushAndCancel\" }\n//   (with the function renamed to simply debounceLeadingAndTrailing())\n\n/**\n * Invokes the function `func` then starts a countdown for `wait` ms.\n * Any further invocations that happen during the countdown will be ignored,\n * and will reset the countdown back to `wait` ms.\n * When the countdown expires, `func` will be called if there was an\n * attempt to call it during the countdown.\n * @return The value that `func` returned when it was last called.\n */\nfunction debounceLeadingAndTrailingWithFlushSupport(func, wait) {\n  let lastFuncResult;\n  let timeoutId = undefined;\n  // Set to undefined when no countdown is active or\n  // the function does not need to be called during timeout handling.\n  // Otherwise, set to a list of arguments that'll be sent to `func` during\n  // timeout handling.\n  let debouncedArgs = undefined;\n\n  const onTimeout = () => {\n    timeoutId = undefined;\n    if (debouncedArgs !== undefined) {\n      lastFuncResult = func(...debouncedArgs);\n    }\n    return lastFuncResult;\n  };\n\n  const debounced = (...args) => {\n    if (timeoutId === undefined) {\n      // Invokes the function and starts a countdown\n      lastFuncResult = func(...args);\n      debouncedArgs = undefined;\n      timeoutId = setTimeout(onTimeout, wait);\n    } else {\n      // Ignores this call and resets the countdown.\n      // When the countdown ends, it'll now also call func() again.\n      clearTimeout(timeoutId);\n      debouncedArgs = args;\n      timeoutId = setTimeout(onTimeout, wait);\n    }\n\n    return lastFuncResult;\n  };\n\n  debounced.cancel = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n  };\n\n  debounced.flush = () => {\n    if (timeoutId === undefined) {\n      return lastFuncResult;\n    }\n    \n    clearTimeout(timeoutId);\n    return onTimeout();\n  };\n\n  return debounced;\n}\n\nclass FakeTimeout {\n  #originals = {};\n  #now = 0;\n  #events = [];\n  #fakeSetTimeout(callback, ms=0) {\n    if (!Number.isInteger(ms) || ms < 0) {\n      throw new Error(`Invalid timeout: ${ms}`);\n    }\n    const id = Math.floor(Math.random() * 1e8);\n    this.#events.push({ callback, fireAt: this.#now + ms, id });\n    return id;\n  }\n\n  #fakeClearTimeout(id) {\n    this.#events = this.#events.filter(event => event.id !== id);\n  }\n\n  tick(deltaMs, { expectedError = undefined } = {}) {\n    const newNow = this.#now + deltaMs;\n    this.#events.sort((a, b) => b.fireAt - a.fireAt);\n    while (this.#events.length > 0 && this.#events.at(-1).fireAt < newNow) {\n      const event = this.#events.pop();\n      // Update this.#now before calling event.callback(),\n      // because the callback() could, in turn, call setTimeout()\n      this.#now = event.fireAt;\n      try {\n        event.callback();\n      } catch (error) {\n        if (expectedError !== undefined && expectedError === error) {\n          // ignore it\n        } else {\n          throw error;\n        }\n      }\n      // Re-sorting events - it's possible that the callback registered another event.\n      this.#events.sort((a, b) => b.fireAt - a.fireAt);\n    }\n    this.#now = newNow;\n  }\n\n  flush() {\n    // Doing this in a loop, in case further events got registered after the flush happened\n    while (this.#events.length > 0) {\n      const furthestEventTime = Math.max(...this.#events.map(event => event.fireAt));\n      // The +1 is probably unnecessary, but doing it anyways.\n      this.tick(furthestEventTime - this.#now + 1);\n    }\n  }\n\n  areTherePendingTimers() {\n    return this.#events.length > 0;\n  }\n\n  getTimestamp() {\n    return this.#now;\n  }\n\n  install() {\n    this.#originals = {\n      setTimeout: globalThis.setTimeout,\n      clearTimeout: globalThis.clearTimeout,\n    };\n    globalThis.setTimeout = this.#fakeSetTimeout.bind(this);\n    globalThis.clearTimeout = this.#fakeClearTimeout.bind(this);\n  }\n\n  uninstall() {\n    globalThis.setTimeout = this.#originals.setTimeout;\n    globalThis.clearTimeout = this.#originals.clearTimeout;\n    this.#originals = {};\n  }\n}\n\n// What gets returned if no return value was specified.\nconst DEFAULT_RETURN_VALUE = Symbol('Default mock callback return value');\nclass MockCallback {\n  #eventTimes = [];\n  #returns = { value: DEFAULT_RETURN_VALUE }; // { value: ... } or { error: ... }\n  #fakeTimeout;\n  constructor(fakeTimeout) {\n    this.#fakeTimeout = fakeTimeout;\n  }\n\n  fn = () => {\n    this.#eventTimes.push(this.#fakeTimeout.getTimestamp());\n    if ('value' in this.#returns) {\n      return this.#returns.value;\n    } else {\n      throw this.#returns.error;\n    }\n  };\n\n  reset() {\n    this.#eventTimes = [];\n    this.#returns = { value: DEFAULT_RETURN_VALUE };\n  }\n\n  setReturnValue(value) {\n    this.#returns = { value };\n  }\n\n  throwWhenCalled(error) {\n    this.#returns = { error };\n  }\n\n  getCallCount() {\n    return this.#eventTimes.length;\n  }\n\n  wasCalledAt(timeStamp) {\n    return this.#eventTimes.some(eventTime => eventTime === timeStamp);\n  }\n\n  // Not actually used in any tests, but it can be helpful to call this to debug test issues.\n  _getAllCallTimes() {\n    return [...this.#eventTimes];\n  }\n}\n\nfunction multiTest(description, expectationGroups, testFn, { only = false } = {}) {\n  (only ? describe.only.bind(describe) : describe)(description, () => {\n    for (const { targets, expectations = undefined } of expectationGroups) {\n      for (const [name, target] of Object.entries(targets)) {\n        if (only) console.log('???')\n        it(`${name}()`, () => testFn(target, expectations));\n      }\n    }\n  });\n}\n\nmultiTest.only = (description, expectationGroups, testFn) => multiTest(description, expectationGroups, testFn, { only: true });\n\ndescribe('debounce()', () => {\n  const DEBOUNCE_TIME = 10 * 1000; // 10 seconds\n\n  const fakeTimeout = new FakeTimeout();\n  const mockCallback = new MockCallback(fakeTimeout);\n  // Using the same debounced instances across all tests as an easy way to\n  // verify that debounced functions clean themselves up between\n  // different types of interactions.\n  const debounced = {\n    leading: debounceLeading(mockCallback.fn, DEBOUNCE_TIME),\n    trailing: debounceTrailing(mockCallback.fn, DEBOUNCE_TIME),\n    trailingWithFlushSupport: debounceTrailingWithFlushSupport(mockCallback.fn, DEBOUNCE_TIME),\n    leadingAndTrailing: debounceLeadingAndTrailing(mockCallback.fn, DEBOUNCE_TIME),\n    leadingAndTrailingWithFlushSupport: debounceLeadingAndTrailingWithFlushSupport(mockCallback.fn, DEBOUNCE_TIME),\n  };\n\n  beforeAll(() => {\n    fakeTimeout.install();\n  });\n\n  afterEach(() => {\n    fakeTimeout.flush();\n    mockCallback.reset();\n  })\n\n  afterAll(() => {\n    fakeTimeout.uninstall();\n  });\n\n  multiTest('repeated calls to the debounced function prevents the wrapped function from getting called', [\n    {\n      targets: {\n        debounceLeading: debounced.leading,\n        debounceTrailing: debounced.trailing,\n        debounceTrailingWithFlushSupport: debounced.trailingWithFlushSupport,\n      },\n      expectations: { callCount: 1 },\n    },\n    {\n      targets: {\n        debounceLeadingAndTrailing: debounced.leadingAndTrailing,\n        debounceLeadingAndTrailingWithFlushSupport: debounced.leadingAndTrailingWithFlushSupport,\n      },\n      // If multiple invocations happen during the debounce interval, and it's supposed\n      // to fire both on the leading and trailing end of the interval, then we'd expect\n      // the wrapped function to be called twice.\n      expectations: { callCount: 2 },\n    },\n  ], (debouncedFn, expectations) => {\n    for (let i = 0; i < 100; i++) {\n      debouncedFn();\n      fakeTimeout.tick(1000);\n    }\n    fakeTimeout.flush();\n\n    expect(mockCallback.getCallCount()).toEqual(expectations.callCount);\n  });\n\n  multiTest('An isolated call to the debounced function results in a single call to the wrapped function', [\n    {\n      targets: {\n        debounceLeading: debounced.leading,\n        debounceTrailing: debounced.trailing,\n        debounceTrailingWithFlushSupport: debounced.trailingWithFlushSupport,\n        // This test is especially important for these two functions.\n        // If multiple calls happen in quick succession, these two functions\n        // are configured to call the wrapped function twice - on the leading and trailing end of the interval.\n        // However, when only one call happens, these should only invoke the wrapped function once instead of twice.\n        debounceLeadingAndTrailing: debounced.leadingAndTrailing,\n        debounceLeadingAndTrailingWithFlushSupport: debounced.leadingAndTrailingWithFlushSupport,\n      }\n    },\n  ], debouncedFn => {\n    debouncedFn();\n    fakeTimeout.flush();\n\n    expect(mockCallback.getCallCount()).toEqual(1);\n  });\n\n  // Only applicable for a leading debounce function\n  multiTest('Calls the wrapped function on the leading end', [\n    {\n      targets: {\n        debounceLeading: debounced.leading,\n        debounceLeadingAndTrailing: debounced.leadingAndTrailing,\n        debounceLeadingAndTrailingWithFlushSupport: debounced.leadingAndTrailingWithFlushSupport,\n      },\n    },\n  ], debouncedFn => {\n    const startTime = fakeTimeout.getTimestamp();\n\n    debouncedFn();\n    fakeTimeout.tick(100);\n    debouncedFn();\n    fakeTimeout.tick(100);\n    debouncedFn();\n    fakeTimeout.flush();\n\n    expect(mockCallback.wasCalledAt(startTime)).toEqual(true);\n  });\n\n  // Only applicable for a trailing debounce function\n  multiTest('Calls the wrapped function on the trailing end', [\n    {\n      targets: {\n        debounceTrailing: debounced.trailing,\n        debounceTrailingWithFlushSupport: debounced.trailingWithFlushSupport,\n        debounceLeadingAndTrailing: debounced.leadingAndTrailing,\n        debounceLeadingAndTrailingWithFlushSupport: debounced.leadingAndTrailingWithFlushSupport,\n      },\n    },\n  ], debouncedFn => {\n    debouncedFn();\n    fakeTimeout.tick(100);\n    debouncedFn();\n    fakeTimeout.tick(100);\n    debouncedFn();\n    const lastCallTime = fakeTimeout.getTimestamp();\n    fakeTimeout.flush();\n\n    expect(mockCallback.wasCalledAt(lastCallTime + DEBOUNCE_TIME)).toEqual(true);\n  });\n\n  // Only applicable for leading debounce functions\n  multiTest('Memoizes the return value from the leading call', [\n    {\n      targets: {\n        debounceLeading: debounced.leading,\n        debounceLeadingAndTrailing: debounced.leadingAndTrailing,\n        debounceLeadingAndTrailingWithFlushSupport: debounced.leadingAndTrailingWithFlushSupport,\n      },\n    },\n  ], debouncedFn => {\n    mockCallback.setReturnValue('THE_RETURN_VALUE');\n    debouncedFn();\n    mockCallback.setReturnValue('NOT_THE_RETURN_VALUE');\n\n    fakeTimeout.tick(100);\n    expect(debouncedFn()).toBe('THE_RETURN_VALUE');\n  });\n\n  // only applicable for trailing-only debounce functions\n  // <-- Because I'm reusing the debounce functions, I would actually expect this to have a value from a previous debounce function instead of undefined. What's going on?\n  multiTest('returns undefined if no value has been memoized yet', [\n    {\n      targets: {\n        // Using fresh debounce instances, because this undefined-returning behavior only happens\n        // with fresh instances.\n        debounceTrailing: debounceTrailing(mockCallback.fn, DEBOUNCE_TIME),\n        debounceTrailingWithFlushSupport: debounceTrailingWithFlushSupport(mockCallback.fn, DEBOUNCE_TIME),\n      },\n    },\n  ], debouncedFn => {\n    mockCallback.setReturnValue('THE_RETURN_VALUE');\n\n    expect(debouncedFn()).toBe(undefined);\n    // Even after a bit of time, it still behaves the same\n    fakeTimeout.tick(100);\n    expect(debouncedFn()).toBe(undefined);\n  });\n\n\n  // This is only applicable for trailing-only debounce functions, because leading debounce functions\n  // will simply call the wrapped function again at this point in time and get a new value to memoize.\n  multiTest('returns the memoized value shortly after the trailing end of the wait window', [\n    {\n      targets: {\n        debounceTrailing: debounced.trailing,\n        debounceTrailingWithFlushSupport: debounced.trailingWithFlushSupport,\n      },\n    },\n  ], debouncedFn => {\n    mockCallback.setReturnValue('THE_RETURN_VALUE');\n    debouncedFn()\n\n    fakeTimeout.tick(DEBOUNCE_TIME + 100);\n    mockCallback.setReturnValue('NOT_THE_RETURN_VALUE');\n\n    expect(debouncedFn()).toBe('THE_RETURN_VALUE');\n  });\n\n  // Only applicable for leading debounce functions\n  multiTest('recovers if a callback called on the leading end of the debounce window throws', [\n    {\n      targets: {\n        debounceLeading: debounced.leading,\n        debounceLeadingAndTrailing: debounced.leadingAndTrailing,\n        debounceLeadingAndTrailingWithFlushSupport: debounced.leadingAndTrailingWithFlushSupport,\n      },\n    },\n  ], debouncedFn => {\n    const error = new Error('Wuh Woh!');\n    mockCallback.throwWhenCalled(error);\n\n    // Just showing that when we start, no timers are scheduled\n    expect(fakeTimeout.areTherePendingTimers()).toBe(false);\n\n    expect(debouncedFn).toThrowError(error);\n\n    // After it's been called, we should stay in the exact same state,\n    // which means no timers should be scheduled still.\n    // Timers aren't needed, because the way we're implementing this,\n    // we don't want to start a debounce window unless the\n    // callback returns successfully.\n    expect(fakeTimeout.areTherePendingTimers()).toBe(false);\n  });\n\n  // This set of tests only handles leading debounce functions.\n  // There's another set of tests below for the trailing-only functions that test the same thing\n  multiTest('recovers if a callback called on the trailing end throws', [\n    {\n      targets: {\n        debounceLeading: debounced.leading,\n        debounceLeadingAndTrailing: debounced.leadingAndTrailing,\n        debounceLeadingAndTrailingWithFlushSupport: debounced.leadingAndTrailingWithFlushSupport,\n      },\n    },\n  ], debouncedFn => {\n    debouncedFn()\n\n    const error = new Error('Wuh Woh!');\n    mockCallback.throwWhenCalled(error);\n\n    // It throws an error while trying to auto-call the callback at the trailing end\n    fakeTimeout.tick(DEBOUNCE_TIME + 100, { expectedError: error });\n\n    // Things still work as normal afterwards, e.g. it'll still cache return values and what-not.\n    fakeTimeout.tick(100);\n    mockCallback.setReturnValue('NEW_RETURN_VALUE');\n    expect(debouncedFn()).toBe('NEW_RETURN_VALUE');\n  });\n\n  // This set of tests only handles trailing-only debounce functions.\n  // There's another set of tests below for the leading functions that test the same thing\n  multiTest('recovers if a callback called on the trailing end throws', [\n    {\n      targets: {\n        debounceTrailing: debounced.trailing,\n        debounceTrailingWithFlushSupport: debounced.trailingWithFlushSupport,\n      },\n    },\n  ], debouncedFn => {\n    // Get an old value into the cache\n    mockCallback.setReturnValue('OLD_RETURN_VALUE');\n    debouncedFn()\n    fakeTimeout.tick(DEBOUNCE_TIME + 100);\n\n    // Start a new time window\n    mockCallback.setReturnValue('NEW_RETURN_VALUE_1');\n    debouncedFn()\n\n    // Throw an error after the trailing end of the new time window\n    // (which means, nothing will be cached from this time window)\n    const error = new Error('Wuh Woh!');\n    mockCallback.throwWhenCalled(error);\n    // It throws an error while trying to auto-call the callback at the trailing end\n    fakeTimeout.tick(DEBOUNCE_TIME + 100, { expectedError: error });\n\n    // Things still work as normal afterwards, e.g. it'll still pull the old value from the cache and what-not\n    fakeTimeout.tick(100);\n    mockCallback.setReturnValue('NEW_RETURN_VALUE_2');\n    expect(debouncedFn()).toBe('OLD_RETURN_VALUE');\n  });\n\n  // Only applicable for a leading debounce function\n  multiTest('cancel() cancels timers, letting you re-trigger leading-edge behavior', [\n    {\n      targets: {\n        debounceLeading: debounced.leading,\n        debounceLeadingAndTrailing: debounced.leadingAndTrailing,\n        debounceLeadingAndTrailingWithFlushSupport: debounced.leadingAndTrailingWithFlushSupport,\n      },\n    },\n  ], debouncedFn => {\n    debouncedFn();\n    fakeTimeout.tick(100);\n\n    expect(mockCallback.getCallCount()).toEqual(1);\n    \n    debouncedFn.cancel();\n    debouncedFn();\n    expect(mockCallback.getCallCount()).toEqual(2);\n  });\n\n  // Only applicable for a trailing debounce function\n  multiTest('cancel() cancels timers, preventing the callback from getting called on the trailing end', [\n    {\n      targets: {\n        debounceTrailing: debounced.trailing,\n      },\n      expectations: { callCount: 0 },\n    },\n    {\n      targets: {\n        debounceLeadingAndTrailing: debounced.leadingAndTrailing,\n        debounceLeadingAndTrailingWithFlushSupport: debounced.leadingAndTrailingWithFlushSupport,\n      },\n      // It gets called once on the leading end\n      expectations: { callCount: 1 },\n    },\n  ], (debouncedFn, expectations) => {\n    debouncedFn();\n    debouncedFn.cancel();\n\n    expect(mockCallback.getCallCount()).toEqual(expectations.callCount);\n\n    // Make what would have been the debounce time window pass.\n    fakeTimeout.tick(DEBOUNCE_TIME + 100);\n\n    // The number of calls hasn't changed, even though we\n    // passed what would have been the trailing-end point of the time window.\n    expect(mockCallback.getCallCount()).toEqual(expectations.callCount);\n  });\n});\n"},{"name":"defer","manifest":{"fnSignature":"_.defer(func, ...args)","lodashLink":"https://lodash.com/docs/4.17.15#defer","summary":"Defers invoking the `func` until the current call stack has cleared. Any additional arguments are provided to `func` when it's invoked."},"description":"```javascript\nsetTimeout(fn)\n// or\nsetTimeout(fn, 0, ...args)\n```\n\nIf the timeout is omitted, it's the same as setting it to zero, which causes the function to run on the next event loop cycle assuming [it doesn't get delayed, which can happen for various reasons](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#reasons_for_delays_longer_than_specified).\n\nLodash's implementation will actually use a timeout of `1` instead of `0`, which means there will always be a `1ms` delay when using their implementation. Browsers in general also used to clamp `setTimeout()` to a minimum, but those restrictions have since been removed ([Here's one example of Chrome removing their 1ms clamping restriction](https://chromestatus.com/feature/4889002157015040)).\n\nPlease use `setTimeout(fn, 0)` as a last resort. If you need to wait for other code to finish running, prefer letting that other code tell you when it's finished running instead of trying to automatically figure it out based on when the call stack empties. Using `setTimeout(fn, 0)` means the code you're waiting on can't also use `setTimeout(fn, 0)` without causing your code to break (i.e. this hack can only be used so many times), and it means your code is at the mercy of running whenever `setTimeout()` lets it, which isn't always immediate.\n","src":null,"test":""},{"name":"delay","manifest":{"fnSignature":"_.delay(func, wait, ...args)","lodashLink":"https://lodash.com/docs/4.17.15#delay","summary":"Invokes `func` after `wait` milliseconds. Any additional arguments are provided to `func` when it's invoked."},"description":"```javascript\nsetTimeout(func, wait, ...args)\n```\n","src":null,"test":""},{"name":"flip","manifest":{"fnSignature":"_.flip(func)","lodashLink":"https://lodash.com/docs/4.17.15#flip","summary":"Creates a function that invokes `func` with arguments reversed."},"description":"Flipping a function's arguments is a technique that is sometimes done to facilitate point-free programming, a programming style that JavaScript wasn't really designed to support. You can do it, but without the help of a third-party library, you'll just be fighting against the language every step of the way. If you want to do point-free programming, you are better off adopting a library such as Rambda, which basically provides an alternative standard library built from the ground up to make point-free programming much easier to handle, as well as providing utility functions such as this flip function.\n\nThat being said, if you really want your own implementation of the flip function, you can use the following:\n\n```javascript\nfunction flip(func) {\n  return function(...args) {\n    // Using .call() may be overkill.\n    // You could just do `return func(...args.reverse())` if you\n    // don't need to worry about preserving the \"this\" argument.\n    return func.call(this, ...args.reverse());\n  };\n}\n```\n","src":null,"test":"describe('flip()', () => {\n  function flip(func) {\n    return function (...args) {\n      // Using .call() may be overkill.\n      // You could just do `return func(...args.reverse())` if you\n      // don't need to worry about preserving the \"this\" argument.\n      return func.call(this, ...args.reverse());\n    };\n  }\n\n  it('can flip the arguments of a function', () => {\n    const fn = flip((a, b) => a + b);\n    expect(fn('a', 'b')).toEqual('ba');\n  });\n\n  it('preserves the \"this\" argument', () => {\n    let self;\n    const fn = flip(function () {\n      self = this;\n    });\n\n    const myThis = { x: 2 };\n    fn.call(myThis);\n\n    expect(self).toEqual(myThis);\n  });\n});\n"},{"name":"memoize","manifest":{"fnSignature":"_.memoize(func, resolver?)","lodashLink":"https://lodash.com/docs/4.17.15#memoize","summary":"Creates a function that memoizes the result of `func`. If `resolver` is provided, it determines the cache key for storing the result based on the arguments provided to the memoized function. By default, the first argument provided to the memoized function is used as the map cache key."},"description":"```javascript\nfunction defaultResolver(...args) {\n  if (args.length !== 1) {\n    throw new Error(\n      'Exactly one argument must be passed in to this memoized function ' +\n      '(unless a custom resolver function is provided)'\n    );\n  }\n  return args[0];\n}\n\nfunction memoize(fn, resolver = defaultResolver) {\n  const cache = new Map();\n  return function (...args) {\n    const key = resolver(...args);\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n\n    // Using .call() may be overkill.\n    // You could just do `const res = fn(...args);` if you\n    // don't need to worry about preserving the \"this\" argument.\n    const res = fn.call(this, ...args);\n    cache.set(key, res);\n    return res;\n  };\n}\n```\n\nThe default resolver behavior in the above implementation is to cache the result based on the first argument, but unlike Lodash's `_.memoize()`, it will also require that only one argument is supplied, in order to help avoid accidental mis-use. If you want a resolver that behave's more like Lodash's, just pass in `x => x` as your resolver function.\n\n","src":null,"test":""},{"name":"negate","manifest":{"fnSignature":"_.negate(predicate)","lodashLink":"https://lodash.com/docs/4.17.15#negate","summary":"Creates a function that negates the result of the predicate `func`."},"description":"Instead of this:\n\n```javascript\nfunction isEven(n) {\n  return n % 2 == 0;\n}\n \n[1, 2, 3, 4, 5, 6].filter(_.negate(isEven)); // [1, 3, 5]\n```\n\njust use an arrow function like this:\n\n```javascript\n[1, 2, 3, 4, 5, 6].filter(n => !isEven(n)); // [1, 3, 5]\n```","src":null,"test":""},{"name":"once","manifest":{"fnSignature":"_.once(func)","lodashLink":"https://lodash.com/docs/4.17.15#once","summary":"Creates a function that is restricted to invoking `func` once. Repeat calls to the function return the value of the first invocation."},"description":"```javascript\nfunction once(func) {\n  let cachedResult;\n  let hasCachedResult = false;\n  return function(...args) {\n    if (hasCachedResult) {\n      return cachedResult;\n    }\n\n    hasCachedResult = true;\n    cachedResult = func.call(this, ...args);\n    return cachedResult;\n  };\n}\n```\n","src":null,"test":"function once(func) {\n  let cachedResult;\n  let hasCachedResult = false;\n  return function (...args) {\n    if (hasCachedResult) {\n      return cachedResult;\n    }\n\n    hasCachedResult = true;\n    cachedResult = func.call(this, ...args);\n    return cachedResult;\n  };\n}\n\ndescribe('once()', () => {\n  it('returns the last result after one calls', () => {\n    const fn = once(x => x ** 2);\n\n    expect(fn(2)).toEqual(4);\n    // Regardless of what is passed in, we always get the first answer back\n    expect(fn(3)).toEqual(4);\n    expect(fn(4)).toEqual(4);\n    expect(fn(5)).toEqual(4);\n  });\n\n  it('preserves the \"this\" argument', () => {\n    let self;\n    const fn = once(function () {\n      self = this;\n    });\n\n    const myThis = { x: 2 };\n    fn.call(myThis);\n\n    expect(self).toEqual(myThis);\n  });\n});\n"},{"name":"overArgs","manifest":{"fnSignature":"_.overArgs(func, transforms)","lodashLink":"https://lodash.com/docs/4.17.15#overArgs","summary":"Creates a function that invokes `func` with its arguments transformed."},"description":"Instead of this:\n\n```javascript\nconst doubled = n => n * 2;\nconst square = n => n ** 2;\nconst originalFunc = (x, y) => [x, y];\n \nconst wrappedFunc = _.overArgs(originalFunc, [square, doubled]);\n \nwrappedFunc(9, 3); // => [81, 6]\n```\n\njust create a new function like this:\n\n```javascript\nconst doubled = n => n * 2;\nconst square = n => n ** 2;\nconst originalFunc = (x, y) => [x, y];\n\nfunction wrappedFunc(x, y) {\n  return originalFunc(square(x), doubled(y));\n}\n\nwrappedFunc(9, 3); // => [81, 6]\n```\n","src":null,"test":""},{"name":"rest","manifest":{"fnSignature":"_.rest(func, start?)","lodashLink":"https://lodash.com/docs/4.17.15#rest","summary":"Creates a function that invokes `func` with the `this` binding of the created function and arguments from `start` and beyond provided as an array."},"description":"Instead of this:\n\n```javascript\nconst buildMessage = _.rest((key, values) => {\n  return `${key}: ${values.join(', ')}`;\n});\n \nbuildMessage('users', 'fred', 'barney', 'pebbles'); // => 'users: fred, barney, pebbles'\n```\n\nUse the \"rest\" syntax.\n\n```javascript\nconst buildMessage = (key, ...values) => {\n  return `${key}: ${values.join(', ')}`;\n};\n \nbuildMessage('users', 'fred', 'barney', 'pebbles'); // => 'users: fred, barney, pebbles'\n```\n","src":null,"test":""},{"name":"spread","manifest":{"fnSignature":"_.spread(func, start?)","lodashLink":"https://lodash.com/docs/4.17.15#spread","summary":"Creates a function that invokes `func` with the `this` binding of the `create` function and an array of arguments much like `Function.prototype.apply`."},"description":"Instead of using `_.spread()`, you can use the spread syntax to spread arguments at the call site, such as what's seen in this example:\n\n```javascript\n// -- An example from their documentation --\nvar say = _.spread(function(who, what) {\n  return who + ' says ' + what;\n});\n \nsay(['fred', 'hello']);\n// => 'fred says hello'\n\n// -- The example re-written to use spread syntax --\nfunction say(who, what) {\n  return who + ' says ' + what;\n};\n \nsay(...['fred', 'hello']); // or, in this specific case, say('fred', 'hello') does the same thing.\n// => 'fred says hello'\n```\n\nThey also provided an example where it wasn't convenient to use spread syntax at the call site - in this particular case, you can just destructure the parameters.\n\n```javascript\n// -- An example from their documentation --\nvar numbers = Promise.all([\n  Promise.resolve(40),\n  Promise.resolve(36)\n]);\n \nnumbers.then(_.spread(function(x, y) {\n  return x + y;\n}));\n// => a Promise of 76\n\n// -- The example re-written to use destructuring --\nconst numbers = Promise.all([\n  Promise.resolve(40),\n  Promise.resolve(36)\n]);\n \nnumbers.then(([x, y]) => x + y);\n// => a Promise of 76\n\n// -- The example re-written to also make use of async/await --\nconst [x, y] = await Promise.all([\n  Promise.resolve(40),\n  Promise.resolve(36)\n]);\n\nx + y;\n// => 76\n```\n","src":null,"test":""},{"name":"unary","manifest":{"fnSignature":"_.unary(func)","lodashLink":"https://lodash.com/docs/4.17.15#unary","summary":"Creates a function that accepts up to one argument, ignoring any additional arguments."},"description":"You can get the same effect by simply using arrow function syntax.\n\n```javascript\n// With Lodash\n['6', '8', '10'].map(_.unary(parseInt)) // => [6, 8, 10]\n\n// Without Lodash\n['6', '8', '10'].map(s => parseInt(s)) // => [6, 8, 10]\n```\n\nIn case you weren't aware, `.map()` supplies multiple parameters to its callbacks, including an index, and `parseInt()` can accept a second parameter, a base, so simply plugging the two together with `['6', '8', '10'].map(parseInt)` will result in the index being fed into the base parameter, resulting in `[6, NaN, 2]`. This is why it's important to use an arrow function (or `_.unary`) to force additional parameters to be ignored.\n\nIn general, it's good to avoid passing in more arguments than what a function takes - even if the function you're calling is just ignoring those additional parameters, there's no guarantee that it won't stay that way - often, functions are changed to support additional optional parameters, and this is usually not considered a breaking change - don't let that kind of change break your code. So, for example, prefer `array.map(x => Number(x))` over `array.map(Number)` - both of these will technically behave the same today, but if the JavaScript committee were to ever add a second, optional parameter to `Number`, then any code with `array.map(Number)` would break (In reality, they're unlikely to ever make this specific change to `Number()` because so many people have written `array.map(Number)` in their code, but they do often make other similar changes to other functions).\n","src":null,"test":""},{"name":"wrap","manifest":{"fnSignature":"_.wrap(value, wrapper)","lodashLink":"https://lodash.com/docs/4.17.15#wrap","summary":"Creates a function that provides `value` to `wrapper` as its first argument. Any additional arguments provided to the function are appended to those provided to the `wrapper`."},"description":"You can get the same effect by simply using arrow function syntax.\n\n```javascript\nconst add = (x, y) => x + y;\n\n// With Lodash\nconst addOne = _.wrap(1, add);\naddOne(2); // => 3\n\n// Without Lodash\nconst addOne = x => add(1, x);\naddOne(2); // => 3\n```\n\n`.bind()` is technically able to accomplish this task as well. Pass in the correct `this` value as the first parameter (or `undefined` if it is not needed), then pass in any additional parameters that you want to be automatically supplied to the function being called.\n\n```javascript\nconst addOne = add.bind(undefined, 1);\naddOne(2); // => 3\n```\n\nI personally would recommend just going with arrow functions - there's no real advantage to using `.bind()`, and arrow functions are simpler for others to understand.\n","src":null,"test":""}]},{"categoryHeading":"Lang","entries":[{"name":"castArray","manifest":{"fnSignature":"_.castArray(value)","lodashLink":"https://lodash.com/docs/4.17.15#castArray","summary":"Casts `value` as an array if it's not one."},"description":"```javascript\nArray.isArray(value) ? value : [value]\n```\n","src":null,"test":""},{"name":"clone","manifest":{"fnSignature":"_.clone(value)","lodashLink":"https://lodash.com/docs/4.17.15#clone","summary":"Creates a shallow clone of `value`."},"description":"To shallow-clone a value, you can simply use the API provided by the specific object type you have. If a particular class doesn't provide any particular way to clone a value, then it may not be possible clone it - not even Lodash's `_.cone()` will be able to help.\n\nHere are a few different ways to create shallow clones of various built-in data types.\n\n* Primitives (such as strings, numbers, booleans, etc): It's not possible to clone these. You also don't need to - they're immutable anyways.\n* Objects: Use the spread syntax, e.g. `const newObj = { ...oldObj };`\n* Arrays: Use the spread syntax, e.g. `const newArray = [...oldArray];`\n* Maps: `const newMap = new Map(oldMap);`\n* Sets: `const newSet = new Set(oldSet);`\n* Dates: `const newDate = new Date(oldDate)`\n* Regular Expressions: `const newRegex = new RegExp(oldRegex); newRegex.lastIndex = oldRegex.lastIndex;`. The `lastIndex` property holds state related to where the regular expression was last searching in a given string - depending on your use-case, it may or may not make sense to preserve this information when cloning.\n* Array Buffers: `const newArrayBuffer = oldArrayBuffer.slice();`\n* typed arrays: As these are just views on array buffers, they don't need to be cloned - unless you're trying to clone both the view and the underlying array buffer, in which case, use the `.buffer` property on your typed array to get access to the underlying buffer, clone it with `.slice()`, then build a new type array of the same type from the cloned buffer. Put together, for `Uint8Array`, this would look like `const newTypedArray = new Uint8Array(oldTypedArray.buffer.slice())`.\n","src":null,"test":""},{"name":"cloneDeep","manifest":{"fnSignature":"_.cloneDeep(value)","lodashLink":"https://lodash.com/docs/4.17.15#cloneDeep","summary":"This method is like `_.clone` except that it recursively clones value."},"description":"```javascript\nstructuredClone(value)\n```\n\n`_.cloneDeep()` is loosely based off of the structured clone algorithm, the same algorithm that is provided to you natively with the `structuredClone()` function. The structured clone algorithm can be useful for simpler scenarios, but it has severe limitations that you should be aware of:\n* many objects, such as `ArrayBuffer` instances, will have ownership of their data transferred to their clone, rendering the original unusable. A complete list of transferable objects can be found [on MDN's website](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Transferable_objects#supported_objects).\n* Some values, like functions, can not be cloned.\n* Some objects lose data when they get cloned. This includes the prototypes of most objects (making it impossible to properly clone instances of any userland class), getters and setters, some data stored on regular expression instances, etc.\n\nFor a complete reference to the algorithm's limitations, please refer to the [structured clone algorithm page](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm) on MDN.\n\nIf `structuredClone()` doesn't suit your needs (because, e.g., maybe you have userland instances that you wish to clone), you'll have to build up your own cloning algorithm by hand, according to your use-case. Here's a simple version to get you started - it shows examples of how you would deep-clone a handful of different types of data. It's up to you to add or remove functionality as needed. Note that this version does not support circular references - if you need to support that, you'll additionally need to keep around a set containing each value you've visited to make sure you're not going in a loop.\n\n```javascript\nconst isObject = value => ['object', 'function'].includes(typeof value) && value !== null;\n\nfunction cloneDeep(value) {\n  if (!isObject(value)) {\n    // It's a primitive, which is immutable, so we don't need to clone it.\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(cloneDeep);\n  } else if (value instanceof Map) {\n    return new Map(\n      [...value].map(([key, value]) => [cloneDeep(key), cloneDeep(value)])\n    );\n  } else if (value instanceof Set) {\n    return new Set(\n      [...value].map(x => cloneDeep(x))\n    );\n  } else if (Object.getPrototypeOf(value) === Object.prototype) {\n    return Object.fromEntries(\n      Object.entries(value).map(([key, value]) => [key, cloneDeep(value)])\n    );\n  } else if (Object.getPrototypeOf(value) === null) {\n    const newObject = Object.fromEntries(\n      Object.entries(value).map(([key, value]) => [key, cloneDeep(value)])\n    );\n    Object.setPrototypeOf(newObject, null);\n    return newObject;\n  } else {\n    throw new Error(`Can not clone an instance of ${value.constructor?.name}`);\n  }\n}\n```\n","src":null,"test":""},{"name":"eq","manifest":{"fnSignature":"_.eq(value, other)","lodashLink":"https://lodash.com/docs/4.17.15#eq","summary":"Performs a `SameValueZero` comparison between two values to determine if they are equivalent."},"description":"To check if two values are exactly the same, use `Object.is(x, y)` (which follows the `SameValue` algorithm).\n\nIf you want a slightly looser algorithm that considers `-0` and `+0` to be the same, use the `SameValueZero` algorithm. This is the same algorithm that Lodash uses in it's `_.eq()` implementation, and also the same algorithm the JavaScript language uses in many of it's built-in functions, such as `array.includes()`. This algorithm can be implemented as follows:\n\n```javascript\nfunction sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) && Number.isNaN(y));\n}\n```\n\nIf you want an algorithm that also conforms to the IEEE floating point spec, which states that `NaN` is not supposed to be considered equal to itself, use JavaScript's strict equality operator (`x === y`).\n\nIf you don't know what to use, use JavaScript's strict equality operator (`x === y`).\n\n[Refer to MDN for a deeper discussion on JavaScript's comparison algorithms](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness).\n","src":null,"test":"function sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) && Number.isNaN(y));\n}\n\ndescribe('sameValueZero()', () => {\n  it('considers -0 and +0 to be equal', () => {\n    expect(sameValueZero(-0, 0)).toEqual(true);\n  });\n\n  it('considers NaN to equal NaN', () => {\n    expect(sameValueZero(NaN, NaN)).toEqual(true);\n  });\n\n  it('considers different values of the same type to not be equal', () => {\n    expect(sameValueZero(1, 2)).toEqual(false);\n  });\n\n  it('considers values of different types to not be equal', () => {\n    expect(sameValueZero(1, '1')).toEqual(false);\n  });\n\n  it('considers references to the same object to be equal', () => {\n    const myObj = {};\n    expect(sameValueZero(myObj, myObj)).toEqual(true);\n    expect(sameValueZero(myObj, {})).toEqual(false);\n  });\n});\n"},{"name":"gt","manifest":{"fnSignature":"_.gt(value, other)","lodashLink":"https://lodash.com/docs/4.17.15#gt","summary":"Checks if `value` is greater than `other`."},"description":"```javascript\nvalue > other\n```\n\nOne reason `_.gt()` exists, is because it's a ready-made function, that can easily be passed into other functions, like this:\n\n```javascript\n> _.zipWith([1, 2, 3], [3, 2, 1], _.gt)\n[false, false, true]\n```\n\nWhen Lodash was first born, the only alternative at the time would be to create an entire function, using the `function` keyword.\n\n```javascript\n_.zipWith([1, 2, 3], [3, 2, 1], function (a, b) {\n  return a > b;\n})\n```\n\nSince then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.\n\n```javascript\n_.zipWith([1, 2, 3], [3, 2, 1], (a, b) => a > b)\n```\n","src":null,"test":""},{"name":"gte","manifest":{"fnSignature":"_.gte(value, other)","lodashLink":"https://lodash.com/docs/4.17.15#gte","summary":"Checks if `value` is greater than or equal to `other`."},"description":"```javascript\nvalue >= other\n```\n\nOne reason `_.gte()` exists, is because it's a ready-made function, that can easily be passed into other functions, like this:\n\n```javascript\n> _.zipWith([1, 2, 3], [3, 2, 1], _.gte)\n[false, true, true]\n```\n\nWhen Lodash was first born, the only alternative at the time would be to create an entire function, using the `function` keyword.\n\n```javascript\n_.zipWith([1, 2, 3], [3, 2, 1], function (a, b) {\n  return a >= b;\n})\n```\n\nSince then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.\n\n```javascript\n_.zipWith([1, 2, 3], [3, 2, 1], (a, b) => a >= b)\n```\n","src":null,"test":""},{"name":"isArguments","manifest":{"fnSignature":"_.isArguments(value)","lodashLink":"https://lodash.com/docs/4.17.15#isArguments","summary":"Checks if `value` is likely an `arguments` object."},"description":"```javascript\nfunction isArguments(value) {\n  return Object.prototype.toString.call(value) === '[object Arguments]' && !(Symbol.toStringTag in value);\n}\n```\n\nThe above solution can technically give wrong answers if you provide an arguments object that has been mutated to contain `Symbol.toStringTag`.\n\n```javascript\nfunction() {\n  arguments[Symbol.toStringTag] = 'badValue';\n  isArguments(arguments); // false\n}\n```\n\nEven Lodash's implementation can be spoofed, but under different conditions. If you run the following, you'll see that it will incorrectly claim that the provided object is an arguments object `true`.\n\n```javascript\n_.isArguments({ get [Symbol.toStringTag]() { return 'Arguments' } }); // true\n```\n\nIf you're exclusively using Node, you're welcome to instead use `require('util').types.isArgumentsObject(value)` for your `isArguments` check.\n","src":null,"test":""},{"name":"isArray","manifest":{"fnSignature":"_.isArray(value)","lodashLink":"https://lodash.com/docs/4.17.15#isArray","summary":"Checks if `value` is classified as an `Array` object."},"description":"Lodash's `_.isArray()` is simply an alias for `Array.isArray(value)`.\n\nNote that `Array.isArray()` will return `true` both for array subclasses and if you directly pass in `Array.prototype`. In many cases this sort of thing isn't something you need to worry about, but if you want to prevent subclasses and/or `Array.prototype` from getting through there's various solutions you can use depending on how robust you need the solution to be.\n\n1. `Object.getPrototypeOf(value) === Array.prototype` is the simplest way to exclude `Array.prototype` and inherited instances, but has issues with cross-realm arrays (see footnote 1) and `Object.create(Array.prototype)` (see footnote 2).\n2. `Array.isArray(value) && Object.getPrototypeOf(value) === Array.prototype` is a little more robust and solved the `Object.create(Array.prototype)` issue (footnote 2), but still has issues with cross-realm arrays (footnote 1).\n3. The helper function below would be the strongest solution, and doesn't have any of the issues that the simpler solutions have.\n\n    ```javascript\n    // Cross realm compatible is-non-inherited-array check.\n    function isNonInheritedArray(value) {\n      const protoOf = Object.getPrototypeOf;\n      // An array's prototype chain should normally be\n      // value -> Array.prototype -> Object.prototype -> null\n      // If there's an extra link in there, it means inheritance has happened.\n      return (\n        Array.isArray(value) &&\n        protoOf(protoOf(value)) !== null && // This check fails if you pass in Array.prototype.\n        protoOf(protoOf(protoOf(value))) === null\n      );\n    }\n    ```\n\n4. If you just want to exclude `Array.prototype` and still allow subclasses, then you can use solution 3, but omit the last `protoOf(protoOf(protoOf(value))) === null` check.\n\nFootnotes:\n1. A \"cross-realm array\" is, for example, an array from an iframe. Since the Array class from within the iframe is separate from the Array class outside of the iframe, you can't simply do an equality check on their prototypes.\n2. The problem with `Object.create(Array.prototype)` is that this does not create a real array, it's just an object who's prototype happens to be `Array.prototype`.\n","src":null,"test":""},{"name":"isArrayBuffer","manifest":{"fnSignature":"_.isArrayBuffer(value)","lodashLink":"https://lodash.com/docs/4.17.15#isArrayBuffer","summary":"Checks if `value` is classified as an `ArrayBuffer` object."},"description":"To check if your value is an instance of `ArrayBuffer`:\n\n```javascript\nvalue instanceof ArrayBuffer;\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nIt's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:\n\n```javascript\nObject.getPrototypeOf(value) === ArrayBuffer.prototype;\n```\n\nBoth of the above type-detection mechanisms have a couple of flaws:\n1. they don't work with cross-realm values. For example, if you receive an instance of an `ArrayBuffer` from across an iframe boundary, that instance's prototype would link to the iframe's `ArrayBuffer` class, not your `ArrayBuffer` class, and both of the above checks would fail to recognize it as an ArrayBuffer.\n2. They will state that `Object.create(ArrayBuffer.prototype)` is an `ArrayBuffer`, but it's not. It's just a regular object who's prototype has been set to `ArrayBuffer.prototype`.\n\nBoth of these issues can be solved with a helper function like this:\n\n```javascript\n// An isArrayBuffer() check that supports cross-realm ArrayBuffers.\nfunction isArrayBuffer(value) {\n  try {\n    // If you call an ArrayBuffer method, like .slice(),\n    // with a \"this\" value that's anything\n    // other than an ArrayBuffer, a TypeError is thrown.\n    ArrayBuffer.prototype.slice.call(value, 0, 0);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nIf you additionally need to ensure that you are not receiving an ArrayBuffer instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace `return true;` with the following:\n\n```javascript\n// A ArrayBuffer's prototype's chain should be\n// value -> ArrayBuffer.prototype -> Object.prototype -> null\n// If it's not, then we're dealing with an ArrayBuffer subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n```\n\nLodash's `_.isArrayBuffer()` also supports cross-realm ArrayBuffer checks, but it uses a less robust algorithm that can be easily fooled. For example, if you run Lodash in the browser, the following will return the wrong answer.\n\n```javascript\n_.isArrayBuffer({ get [Symbol.toStringTag]() { return 'ArrayBuffer' } }); // true\n```\n\nIn Node, Lodash will instead use `require('util').types.isArrayBuffer(value)` for it's implementation, which you are also welcome to use if you know your code will only run in Node.\n\nSome very early JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:\n* [istypes](https://github.com/jasnell/proposal-istypes)\n* [Pattern matching's built-in matchers](https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1)\n","src":null,"test":""},{"name":"isArrayLike","manifest":{"fnSignature":"_.isArrayLike(value)","lodashLink":"https://lodash.com/docs/4.17.15#isArrayLike","summary":"Checks if `value` is array-like. A value is considered array-like if it's not a function and has a value.length that's an integer greater than or equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`."},"description":"An equivalent to Lodash's \"is-array-like\" algorithm is as follows:\n\n```javascript\nfunction isArrayLike(value) {\n  return (\n    typeof value !== 'function' &&\n    Number.isInteger(value?.length) &&\n    value.length >= 0\n  );\n}\n```\n\nThe JavaScript specification uses a much looser definition for \"array-like\" - basically, as long as you can get a \"length\" property from the value and coerce it into an integer somehow, then it's an array-like value. This means that even `{}` is \"array-like\", because it's able to get the (non-existent) length property (`undefined`), then coerce that into an integer (`0`). This definition technically makes almost any value except undefined, null, and a couple of other minor edge cases \"array-like\". A good way to check if something is considered array-like or not per the spec, is to run the following snippet and see if it throws an error, if it does not, your value is an array-like value.\n\n```javascript\nArray.prototype.slice.call(<your value>);\n```\n\nIn day-to-day conversation the term \"array-like\" goes beyond the technical definition of array-like as outlined by the spec. An array-like value is additionally a value that was intentionally designed to have array-like characteristics, which is why Lodash's implementation still makes sense - Lodash's does a good job at rejecting values that were never intended to be used like an array. The point is that Lodash's implementation isn't the only correct way to implement this check - depending on your use-case you might find that a different `isArrayLike()` implementation would be more appropriate.\n\nAn even better lesson from all of this is that if you're tempted to design a function that behaves differently depending on if an input value is array-like or not, it might be worthwhile to reconsider the API design so you don't have to make your public API depend on either a non-standard or overly loose definition of \"array-like\".\n","src":null,"test":"function isArrayLike(value) {\n  return (\n    typeof value !== 'function' &&\n    Number.isInteger(value?.length) &&\n    value.length >= 0\n  );\n}\n\ndescribe('isArrayLike()', () => {\n  it('considers an array to be array-like', () => {\n    expect(isArrayLike([2, 3])).toBe(true);\n  });\n\n  it('considers a string to be array-like', () => {\n    expect(isArrayLike('23')).toBe(true);\n  });\n\n  it('considers an arguments object to be array-like', () => {\n    (function () {\n      expect(isArrayLike(arguments)).toBe(true);\n    })();\n  });\n\n  it('does not consider a function to be array-like', () => {\n    expect(isArrayLike(function () {})).toBe(false);\n  });\n\n  it('considers a value missing a length property to not be array-like', () => {\n    expect(isArrayLike({})).toBe(false);\n  });\n\n  it('considers a value with a positive integer length to be array-like', () => {\n    expect(isArrayLike({ length: 2 })).toBe(true);\n  });\n\n  it('considers a value with the length 0 to be array-like', () => {\n    expect(isArrayLike({ length: 0 })).toBe(true);\n  });\n\n  it('considers a value with a string length to not be array-like', () => {\n    expect(isArrayLike({ length: '2' })).toBe(false);\n  });\n\n  it('considers a value with a length of Infinity to not be array-like', () => {\n    expect(isArrayLike({ length: Infinity })).toBe(false);\n  });\n\n  it('considers a value with a length of NaN to not be array-like', () => {\n    expect(isArrayLike({ length: NaN })).toBe(false);\n  });\n\n  it('considers a value with a float length to not be array-like', () => {\n    expect(isArrayLike({ length: 2.3 })).toBe(false);\n  });\n\n  it('considers a value with a really large length to not be array-like (as those are represented as floats)', () => {\n    expect(isArrayLike({ length: 2e999 })).toBe(false);\n  });\n});\n"},{"name":"isArrayLikeObject","manifest":{"fnSignature":"_.isArrayLikeObject(value)","lodashLink":"https://lodash.com/docs/4.17.15#isArrayLikeObject","summary":"This method is like `_.isArrayLike` except that it also checks if `value` is an object."},"description":"An equivalent to Lodash's \"is-array-like-object\" algorithm is as follows:\n\n```javascript\nfunction isArrayLikeObject(value) {\n  return isArrayLike(value) && isObject(value);\n}\n\n// -- helpers --\n\nfunction isArrayLike(value) {\n  return (\n    typeof value !== 'function' &&\n    Number.isInteger(value?.length) &&\n    value.length >= 0\n  );\n}\n\nfunction isObject(value) {\n  return value === Object(value);\n}\n```\n\n(Note that the only difference between `_.isArrayLikeObject()` and `_.isArrayLike()` is that `_.isArrayLikeObject()` does not return `true` for string primitives).\n\nThe JavaScript specification uses a much looser definition for \"array-like object\" - basically, as long as the value is an object and you can get a \"length\" property from the value and coerce it into an integer somehow, then it's an array-like value. This means that even `{}` is \"array-like\", because it's able to get the (non-existent) length property (`undefined`), then coerce that into an integer (`0`). This definition technically makes almost any non-primitive value \"array-like\" (an exception could be, for example, an object with a \"length\" getter that throws an error).\n\nIn day-to-day conversation the term \"array-like object\" goes beyond the technical definition of array-like object as outlined by the spec. An array-like object is additionally an object that was intentionally designed to have array-like characteristics, which is why Lodash's implementation still makes sense - Lodash's does a good job at rejecting values that were never intended to be used like an array. The point is that Lodash's implementation isn't the only correct way to implement this check - depending on your use-case you might find that a different `isArrayLikeObject()` implementation would be more appropriate.\n\nAn even better lesson from all of this is that if you're tempted to design a function that behaves differently depending on if an input value is an array-like object or not, it might be worthwhile to reconsider the API design so you don't have to make your public API depend on either a non-standard or overly loose definition of \"array-like object\".\n","src":null,"test":"function isArrayLikeObject(value) {\n  return isArrayLike(value) && isObject(value);\n}\n\nfunction isArrayLike(value) {\n  return (\n    typeof value !== 'function' &&\n    Number.isInteger(value?.length) &&\n    value.length >= 0\n  );\n}\n\nfunction isObject(value) {\n  return value === Object(value);\n}\n\ndescribe('isArrayLikeObject()', () => {\n  it('considers an array to be an array-like object', () => {\n    expect(isArrayLikeObject([2, 3])).toBe(true);\n  });\n\n  it('does not considers a string to be an array-like object', () => {\n    expect(isArrayLikeObject('23')).toBe(false);\n  });\n\n  it('considers an arguments object to be an array-like object', () => {\n    (function () {\n      expect(isArrayLikeObject(arguments)).toBe(true);\n    })();\n  });\n\n  it('does not consider a function to be an array-like object', () => {\n    expect(isArrayLikeObject(function () {})).toBe(false);\n  });\n\n  it('considers a value missing a length property to not be an array-like object', () => {\n    expect(isArrayLikeObject({})).toBe(false);\n  });\n\n  it('considers a value with a positive integer length to be an array-like object', () => {\n    expect(isArrayLikeObject({ length: 2 })).toBe(true);\n  });\n\n  it('considers a value with the length 0 to be an array-like object', () => {\n    expect(isArrayLikeObject({ length: 0 })).toBe(true);\n  });\n\n  it('considers a value with a string length to not be an array-like object', () => {\n    expect(isArrayLikeObject({ length: '2' })).toBe(false);\n  });\n\n  it('considers a value with a length of Infinity to not be an array-like object', () => {\n    expect(isArrayLikeObject({ length: Infinity })).toBe(false);\n  });\n\n  it('considers a value with a length of NaN to not be an array-like object', () => {\n    expect(isArrayLikeObject({ length: NaN })).toBe(false);\n  });\n\n  it('considers a value with a float length to not be an array-like object', () => {\n    expect(isArrayLikeObject({ length: 2.3 })).toBe(false);\n  });\n\n  it('considers a value with a really large length to not be an array-like object (as those are represented as floats)', () => {\n    expect(isArrayLikeObject({ length: 2e999 })).toBe(false);\n  });\n});\n"},{"name":"isBoolean","manifest":{"fnSignature":"_.isBoolean(value)","lodashLink":"https://lodash.com/docs/4.17.15#isBoolean","summary":"Checks if `value` is classified as a boolean primitive or object."},"description":"To check if a value is a boolean primitive:\n\n```javascript\ntypeof value === 'boolean';\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nLodash will also check if the value is a boolean object. In practice, such objects should never be found in your codebase, and if someone ever tries to hand such an object to you you really ought to treat it the same way you would treat any other bad input (throw an error, or if you aren't explicitly trying to check for bad inputs just let your library fall over, the same way it would with any other bad input).\n\nTo check if something is specifically a boolean object (and not a primitive), use the following:\n\n```javascript\nvalue instanceof Boolean;\n```\n\nThis, however, doesn't work cross realm (i.e. a boolean object created from inside an iframe would fail this check). It also would incorrectly state that `Object.create(Boolean.prototype)` is a boolean object, when in reality, it's just a normal object who's prototype is set to `Boolean.prototype`. If you need to worry about these kinds of issues, use the following solution instead:\n\n```javascript\n// An isBoolean() check that supports cross-realm Boolean instances.\n// This will check if `value` is a boolean primitive or object.\n// Returns `true` for values that inherit from `Boolean` as well.\nfunction isBoolean(value) {\n  try {\n    // If you call this method with a \"this\" value that's anything\n    // other than a boolean primitive or object, a TypeError is thrown.\n    Boolean.prototype.toString.call(value);\n    // Makes sure Boolean.prototype was not passed in.\n    const protoOf = Object.getPrototypeOf;\n    return protoOf(protoOf(value)) !== null;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nLodash's `_.isBoolean()` also supports cross-realm `Boolean` object checks, but it uses a less robust algorithm that can be easily fooled. For example, the following will return the wrong answer.\n\n```javascript\n_.isBoolean({ get [Symbol.toStringTag]() { return 'Boolean' } }); // true\n```\n\nIf you're exclusively using Node, you can use `require('util').types.isBooleanObject(value)` to specifically check if the value is a boolean object (not a primitive). This solution will also return `true` for both subclasses and `Boolean.prototype`.","src":null,"test":""},{"name":"isBuffer","manifest":{"fnSignature":"_.isBuffer(value)","lodashLink":"https://lodash.com/docs/4.17.15#isBuffer","summary":"Checks if `value` is a buffer."},"description":"The `Buffer` class is part of Node, and isn't found in the core JavaScript language. You can check if something is an instance of Buffer using Node's `isBuffer()` method as follows:\n\n```javascript\nBuffer.isBuffer(value);\n```\n\nThis will return `true` for `Buffer` subclasses. If you want to ensure your buffer instance is not a subclass, you can do the following:\n\n```javascript\nfunction isNonInheritedBuffer(value) {\n  // A Buffer's prototype's chain should be\n  // value -> Buffer.prototype -> Uint8Array.prototype -> TypedArray.prototype -> Object.prototype -> null\n  // If it's not, then we're dealing with a Buffer subclass.\n  const protoOf = Object.getPrototypeOf;\n  return (\n    Buffer.isBuffer(value) &&\n    protoOf(protoOf(protoOf(protoOf(protoOf(value))))) === null\n  )\n}\n```\n\nBoth of these solutions will work with cross-realm `Buffer` instances.","src":null,"test":""},{"name":"isDate","manifest":{"fnSignature":"_.isDate(value)","lodashLink":"https://lodash.com/docs/4.17.15#isDate","summary":"Checks if `value` is classified as a `Date` object."},"description":"To check if your value is an instance of `Date`:\n\n```javascript\nvalue instanceof Date;\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nIt's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:\n\n```javascript\nObject.getPrototypeOf(value) === Date.prototype;\n```\n\nBoth of the above type-detection mechanisms have a couple of flaws:\n1. they don't work with cross-realm values. For example, if you receive an instance of a `Date` from across an iframe boundary, that instance's prototype would link to the iframe's `Date` class, not your `Date` class, and both of the above checks would fail to recognize it as a `Date`.\n2. They will state that `Object.create(Date.prototype)` is a `Date`, but it's not. It's just a regular object who's prototype has been set to `Date.prototype`.\n\nBoth of these issues can be solved with a helper function like this:\n\n```javascript\n// An isDate() check that supports cross-realm Dates.\nfunction isDate(value) {\n  try {\n    // If you call a Date method, like .valueOf(),\n    // with a \"this\" value that's anything\n    // other than a Date, a TypeError is thrown.\n    Date.prototype.valueOf.call(value);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nIf you additionally need to ensure your are not receiving a `Date` instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace `return true;` with the following:\n\n```javascript\n// A Date's prototype's chain should be\n// value -> Date.prototype -> Object.prototype -> null\n// If it's not, then we're dealing with a Map subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n```\n\nLodash's `_.isDate()` also supports cross-realm `Date` checks, but it uses a less robust algorithm that can be easily fooled. For example, if you run Lodash in the browser, the following will return the wrong answer.\n\n```javascript\n_.isDate({ get [Symbol.toStringTag]() { return 'Date' } }); // true\n```\n\nIn Node, Lodash will instead use `require('util').types.isDate(value)` for it's implementation, which you are also welcome to use if you know your code will only run in Node. This solution will also return `true` for subclasses.\n\nSome very early JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:\n* [istypes](https://github.com/jasnell/proposal-istypes)\n* [Pattern matching's built-in matchers](https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1)\n","src":null,"test":""},{"name":"isElement","manifest":{"fnSignature":"_.isElement(value)","lodashLink":"https://lodash.com/docs/4.17.15#isElement","summary":"Checks if value is likely a `DOM` element."},"description":"To check if your value is an HTML Element:\n\n```javascript\nvalue instanceof Element;\n```\n\nFor the vast majority of scenarios the above should be good enough, but it does technically have a couple of flaws:\n1. it doesn't work with cross-realm values. For example, if you receive an instance of an `Element` from across an iframe boundary, that instance's prototype would link to the iframe's `Element` class, not your `Element` class, and the above check would fail to recognize it as an `Element`.\n2. They will state that `Object.create(Element.prototype)` is an element, but it's not. It's just a regular object who's prototype has been set to `Element.prototype`.\n\nBoth of these issues can be solved with a helper function like this:\n\n```javascript\n// An isElement() check that supports cross-realm Elements.\nfunction isElement(value) {\n  try {\n    // If you call a Element method, like .getAttribute(),\n    // with a \"this\" value that's anything\n    // other than an Element, a TypeError is thrown.\n    Element.prototype.getAttribute.call(value, '')\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nLodash's `_.isElement()` also supports cross-realm `Element` checks, but it uses a far less robust algorithm that can be easily fooled. To spoof it, you just need to provide a [non-plain object](https://lodash.com/docs/4.17.15#isPlainObject) which has a `nodeType` property set to `1`.\n\n```javascript\nclass NotAnElement {\n  nodeType = 1;\n}\n\n_.isElement(new NotAnElement()); // true\n```\n","src":null,"test":""},{"name":"isEmpty","manifest":{"fnSignature":"_.isEmpty(value)","lodashLink":"https://lodash.com/docs/4.17.15#isEmpty","summary":"Checks if `value` is an empty object, collection, map, or set."},"description":"To check if something is empty, you can simply use the API provided by the specific object type you have.\n\nFor array and strings, use the `.length` property.\n\n```javascript\nmyArray.length === 0;\nmyString.length === 0;\n```\n\nFor maps and sets, use the `.size` property.\n\n```javascript\nnew Map().size === 0;\nnew Set().size === 0;\n```\n\nYou can check if an object has zero non-inherited string keys by checking the length of `Object.keys()`.\n\n```javascript\nObject.keys({}).length === 0;\n```\n\nLodash treats undefined and null as empty, while treating all other non-string primitives as non-empty. This distinction is technically nonsense. Only containers can be empty. If your piece of data can't hold anything, then it _can't_ be empty or non-empty, instead it's simply an invalid input. It's true that a `null` or `undefined` can be used to represent the absence of a value, but these pieces of data aren't in-and-of-themselves _empty_. In any case, if you want to check if something is `undefined` or `null`, you can just use `value === undefined` or `value === null`.\n\nIf you want to check if an [array-like value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#array-like_objects) (e.g. the argument object, typed arrays, etc) is empty, check the `.length` property, the same way you would with a normal array.\n\n```javascript\nmyArrayLikeValue.length === 0;\n```\n\nDespite what Lodash's documentation seems to imply, `_.isEmpty()` does not work with _any_ array-like value. Take, for example, `{ length: 0 }`, which is an array-like object (it passes Lodash's `_.isArrayLike()` check), however, when passed into `_.isEmpty()`, Lodash will incorrectly state that this array-like value is not empty. The reason for this odd behavior is simply because this function has been overloaded with too many behaviors - while it's true that `{ length: 0 }` is an empty array-like object, it's also true that this is not an empty object, and Lodash has decided to let the \"is this an empty object\" behavior take precedence over the \"is this an empty array-like value\" behavior for this specific scenario. If you want to know the details of how it decides which behavior to follow, feel free to [read its source code](https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L11479).\n","src":null,"test":""},{"name":"isEqual","manifest":{"fnSignature":"_.isEqual(value, other)","lodashLink":"https://lodash.com/docs/4.17.15#isEqual","summary":"Performs a deep comparison between two values to determine if they are equivalent."},"description":"To deeply compare values you'll have to build up your own deep comparison algorithm by hand according to your use-case. General-purpose deep-comparison algorithms like Lodash's `_.isEqual()` can be nice to have for simple use-cases, but it's important to understand that all such algorithms have limitations and you may be forced to revert to building your own deep-comparison algorithm if you are using a data type that the algorithm does not explicitly support (e.g. no general-purpose algorithm can deeply compare private data defined in your classes), or if you need very specific behavior (e.g. should `+0` equal `-0` or not? Will you only compare an object's string keys, or will you include symbol keys too? etc).\n\nHere's a simple version to get you started - it shows examples of how you would compare a handful of different types of data. It's up to you to add, remove, or tweak functionality as needed. Note that this version does not support circular references - if you need to support that, you'll additionally need to keep around a set containing each value you've visited to make sure you're not going in a loop.\n\n```javascript\nconst isPrimitive = value => value !== Object(value);\n\nconst isPlainObject = value => (\n  value != null &&\n  [null, Object.prototype].includes(Object.getPrototypeOf(value))\n);\n\nfunction isEqual(value1, value2) {\n  // Each type corresponds to a particular comparison algorithm\n  const getType = value => {\n    if (isPrimitive(value)) return 'primitive';\n    if (Array.isArray(value)) return 'array';\n    if (value instanceof Map) return 'map';\n    if (isPlainObject(value)) return 'plainObject';\n    throw new Error(`deeply comparing an instance of type ${value1.constructor?.name} is not supported.`);\n  };\n\n  const type = getType(value1);\n  if (type !== getType(value2)) {\n    return false;\n  }\n\n  if (type === 'primitive') {\n    return (\n      value1 === value2 ||\n      (Number.isNaN(value1) && Number.isNaN(value2))\n    );\n  } else if (type === 'array') {\n    return (\n      value1.length === value2.length &&\n      value1.every((iterValue, i) => isEqual(iterValue, value2[i]))\n    );\n  } else if (type === 'map') {\n    // In this particular implementation, map keys are not\n    // being deeply compared, only map values.\n    return (\n      value1.size === value2.size &&\n      [...value1].every(([iterKey, iterValue]) => {\n        return value2.has(iterKey) && isEqual(iterValue, value2.get(iterKey));\n      })\n    );\n  } else if (type === 'plainObject') {\n    const value1AsMap = new Map(Object.entries(value1));\n    const value2AsMap = new Map(Object.entries(value2));\n    return (\n      value1AsMap.size === value2AsMap.size &&\n      [...value1AsMap].every(([iterKey, iterValue]) => {\n        return value2AsMap.has(iterKey) && isEqual(iterValue, value2AsMap.get(iterKey));\n      })\n    );\n  } else {\n    throw new Error(`Unreachable`);\n  }\n}\n```\n\nIf you're dealing with JSON-serializable data (i.e. data that does not contain values like `Date` instances or `undefined`), and you're not working in performance-sensitive code, you could also use the simpler solution of `JSON.stringify()`ing the two values and comparing the strings. You'll need to supply a `replacer` function to sort object keys before converting the object to JSON.\n\n```javascript\nfunction sortObjKeysReplacer(key, maybeObj) {\n  if (typeof maybeObj !== 'object' || maybeObj === null) return maybeObj;\n\n  return Object.fromEntries(\n    Object.entries(maybeObj)\n      .sort((a, b) => a[0] > b[0] ? 1 : -1)\n  );\n}\n\nfunction isEqual(value1, value2) {\n  const jsonValue1 = JSON.stringify(value1, sortObjKeysReplacer);\n  const jsonValue2 = JSON.stringify(value2, sortObjKeysReplacer);\n  return jsonValue1 === jsonValue2;\n}\n```\n","src":null,"test":""},{"name":"isEqualWith","manifest":{"fnSignature":"_.isEqualWith(value, other, [customizer])","lodashLink":"https://lodash.com/docs/4.17.15#isEqualWith","summary":"This method is like `_.isEqual` except that it accepts `customizer` which is invoked to compare values. If `customizer` returns `undefined`, comparisons are handled by the method instead."},"description":"Like with `_.isEqual()`, deep comparison algorithms need to be hand-built according to your use-cases. Lodash's `_.isEqualWith()` can be convenient to help with some use cases, but it won't cover everything (e.g. it can't peer into private data).\n\nHere's a simple version to get you started - it shows examples of how you would compare a handful of different types of data. It's up to you to add, remove, or tweak functionality as needed. Note that this version does not support circular references - if you need to support that, you'll additionally need to keep around a set containing each value you've visited to make sure you're not going in a loop.\n\n```javascript\nconst isPrimitive = value => value !== Object(value);\n\nconst isPlainObject = value => (\n  value != null &&\n  [null, Object.prototype].includes(Object.getPrototypeOf(value))\n);\n\nfunction isEqualWith(value1, value2, customizer, _parentNodeInfo = undefined) {\n  // Each type corresponds to a particular comparison algorithm\n  const getType = value => {\n    if (isPrimitive(value)) return 'primitive';\n    if (Array.isArray(value)) return 'array';\n    if (isPlainObject(value)) return 'plainObject';\n    throw new Error(`deeply comparing an instance of type ${value1.constructor?.name} is not supported.`);\n  };\n\n  // Checks with the customizer() function to see if it\n  // wants to override the default comparison behavior\n  {\n    let customizerResult;\n    if (_parentNodeInfo === undefined) {\n      customizerResult = customizer(value1, value2);\n    } else {\n      const { key, value1Parent, value2Parent } = _parentNodeInfo;\n      customizerResult = customizer(value1, value2, key, value1Parent, value2Parent);\n    }\n\n    if (customizerResult !== undefined) {\n      return customizerResult;\n    }\n  }\n\n  const type = getType(value1);\n  if (type !== getType(value2)) {\n    return false;\n  }\n\n  if (type === 'primitive') {\n    return (\n      value1 === value2 ||\n      (Number.isNaN(value1) && Number.isNaN(value2))\n    );\n  } else if (type === 'array') {\n    return (\n      value1.length === value2.length &&\n      value1.every(\n        (iterValue, i) => isEqualWith(\n          iterValue,\n          value2[i],\n          customizer,\n          { value1Parent: value1, value2Parent: value2, key: i }\n        )\n      )\n    );\n  } else if (type === 'plainObject') {\n    const value1AsMap = new Map(Object.entries(value1));\n    const value2AsMap = new Map(Object.entries(value2));\n    return (\n      value1AsMap.size === value2AsMap.size &&\n      [...value1AsMap].every(([iterKey, iterValue]) => {\n        return (\n          value2AsMap.has(iterKey) &&\n          isEqualWith(\n            iterValue,\n            value2AsMap.get(iterKey),\n            customizer,\n            { value1Parent: value1, value2Parent: value2, key: iterKey }\n          )\n        );\n      })\n    );\n  } else {\n    throw new Error('Unreachable');\n  }\n}\n```\n\nIn Lodash, the customizer function would be called with a sixth \"stack\" argument. Some probing shows that it's an instance of an internal \"Stack\" class that provides some methods which, presumably, can be used to gather information about the objects you're comparing. Due to the fact that this seems to be a rather complex feature that's entirely undocumented, it'll be assumed that the vast majority of users do not use this parameter, and so it's functionality won't be recreated here either.\n\nSpecial data types, like Maps and Sets, are not supported in the above example. This is partly because Lodash chooses to support them in a slightly odd way that you may not wish to mirror. For example:\n* The fourth or fifth argument to your customizer function is supposed to be the parent node, but if that parent node was a `Map` or `Set` instance, you'll instead receive arrays containing the node's contents (e.g. a map of usernames to ids would be turned into `[['Sally', 1], ['Zack', 2]]` before being provided to you).\n* When comparing two sets, like `new Set([1, 2, 3, 4])` and `new Set([5, 6, 7, 8])`, its going to call your `customizer` function _16_ different times (assuming the `customizer` function returns `false` or `undefined` each time). As your sets grow in length, the amount of times it has to call your customizer grows exponentially. Maps have a similar issue. This behavior is required to implement the general-purpose algorithm Lodash was going for, but maybe for your use-case you don't need your algorithm to be so general-purpose - maybe you can cut some corners to help with performance.\n","src":null,"test":""},{"name":"isError","manifest":{"fnSignature":"_.isError(value)","lodashLink":"https://lodash.com/docs/4.17.15#isError","summary":"Checks if value is an `Error`, `EvalError`, `RangeError`, `ReferenceError`, `SyntaxError`, `TypeError`, or `URIError` object."},"description":"Lodash's documentation makes it sound like they're checking if the value is specifically an instance of a set of built-in errors, but in reality, they're considering any [non-plain object](https://lodash.com/docs/4.17.15#isPlainObject) that has `message` and `name` properties that are strings to be errors. So, the following would return `true` despite not being an error.\n\n```javascript\nclass NotAnError {\n  name = 'NotAnError';\n  message = 'this is not an error';\n}\n\n_.isError(new NotAnError()); // true\n```\n\nIf you actually want to check if a value is an error or one of its subclasses (like `TypeError`, or a user-defined subclass), you can simply do this:\n\n```javascript\nvalue instanceof Error;\n```\n\nAnd if you want to check if a value is a specific error type (like `Error`, `TypeError`, or a user defined error), and you want to exclude subclasses, you can compare prototypes like this:\n\n```javascript\n// Replace `TypeError` with the Error class of your choice.\nObject.getPrototypeOf(value) === TypeError.prototype;\n```\n\nFor the vast majority of scenarios the above should be good enough, but those solutions do technically have a couple of flaws:\n1. they don't work with cross-realm values. For example, if you receive an instance of an `Error` from across an iframe boundary, that instance's prototype would link to the iframe's `Error` class, not your `Error` class, and both of the above checks would fail to recognize it as a `Error`.\n2. They will state that `Object.create(Error.prototype)` is an `Error`, but it's not. It's just a regular object who's prototype has been set to `Error.prototype`.\n\nBoth of these issues can be solved with a helper function like this:\n\n```javascript\n// An isError() check that supports cross-realm Errors.\nfunction isError(value) {\n  // DOMException and its subclasses will set a `Symbol.toStringTag` property\n  // on their instances to the string 'DOMException'.\n  const errorAsString = Object.prototype.toString.call(value);\n  return ['[object Error]', '[object DOMException]'].includes(errorAsString);\n}\n```\n\nThis helper function can unfortunately be spoofed by providing any object with a `Symbol.toStringTag` property set to one of the expected string tags, like this:\n\n```javascript\nisError({ [Symbol.toStringTag]: 'DOMException' }); // true\n```\n\nThere's not really anything that can be done to avoid this. You could try layering on additional checks, but there will always be a way to cause your `isError()` function to return a wrong answer.\n\nIf you're exclusively using Node, you can use `require('util').types.isNativeError(value)` to specifically check if the value is an instance of `Error` or one of its subclasses.\n\nSome very early JavaScript proposals may provide support for more robust ways to do cross-realm type checking:\n* [Error.isError](https://github.com/tc39/proposal-is-error)\n* [istypes](https://github.com/jasnell/proposal-istypes)\n* [Pattern matching's built-in matchers](https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1)\n","src":null,"test":""},{"name":"isFinite","manifest":{"fnSignature":"_.isFinite(value)","lodashLink":"https://lodash.com/docs/4.17.15#isFinite","summary":"Checks if `value` is a finite primitive number."},"description":"```javascript\nNumber.isFinite(value);\n```\n","src":null,"test":""},{"name":"isFunction","manifest":{"fnSignature":"_.isFunction(value)","lodashLink":"https://lodash.com/docs/4.17.15#isFunction","summary":"Checks if `value` is classified as a `Function` object."},"description":"```javascript\ntypeof value === 'function';\n```\n\nNote that `typeof Function.prototype` is also `'function'`. While it may be overkill, you can use a helper function like the following to exclude `Function.prototype`.\n\n```javascript\nfunction isFunction(value) {\n  const protoOf = Object.getPrototypeOf;\n  return (\n    typeof value === 'function' &&\n    protoOf(protoOf(value)) !== null // Make sure Function.prototype was not passed in\n  )\n}\n```\n","src":null,"test":""},{"name":"isInteger","manifest":{"fnSignature":"_.isInteger(value)","lodashLink":"https://lodash.com/docs/4.17.15#isInteger","summary":"Checks if `value` is an integer."},"description":"```javascript\nNumber.isInteger(value);\n```\n","src":null,"test":""},{"name":"isLength","manifest":{"fnSignature":"_.isLength(value)","lodashLink":"https://lodash.com/docs/4.17.15#isLength","summary":"Checks if `value` is a valid array-like length."},"description":"```javascript\nNumber.isInteger(value) && value >= 0;\n```\n","src":null,"test":"function isLength(value) {\n  return Number.isInteger(value) && value >= 0;\n}\n\ndescribe('isLength()', () => {\n  it('returns true on positive integers', () => {\n    expect(isLength(2)).toBe(true);\n  });\n\n  it('returns true on the number 0', () => {\n    expect(isLength(0)).toBe(true);\n  });\n\n  it('returns false on strings', () => {\n    expect(isLength('2')).toBe(false);\n  });\n\n  it('returns false with Infinity', () => {\n    expect(isLength(Infinity)).toBe(false);\n  });\n\n  it('returns false with NaN', () => {\n    expect(isLength(NaN)).toBe(false);\n  });\n\n  it('returns false with floats', () => {\n    expect(isLength(2.3)).toBe(false);\n  });\n\n  it('returns false with large numbers (as those are represented as floats)', () => {\n    expect(isLength(2e999)).toBe(false);\n  });\n});\n"},{"name":"isMap","manifest":{"fnSignature":"_.isMap(value)","lodashLink":"https://lodash.com/docs/4.17.15#isMap","summary":"Checks if `value` is classified as a `Map` object."},"description":"To check if your value is an instance of `Map`:\n\n```javascript\nvalue instanceof Map;\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nIt's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:\n\n```javascript\nObject.getPrototypeOf(value) === Map.prototype;\n```\n\nBoth of the above type-detection mechanisms have a couple of flaws:\n1. they don't work with cross-realm values. For example, if you receive an instance of a `Map` from across an iframe boundary, that instance's prototype would link to the iframe's `Map` class, not your `Map` class, and both of the above checks would fail to recognize it as a `Map`.\n2. They will state that `Object.create(Map.prototype)` is a `Map`, but it's not. It's just a regular object who's prototype has been set to `Map.prototype`.\n\nBoth of these issues can be solved with a helper function like this:\n\n```javascript\n// An isMap() check that supports cross-realm Maps.\nfunction isMap(value) {\n  try {\n    // If you call a Map method, like .get(),\n    // with a \"this\" value that's anything\n    // other than a Map, a TypeError is thrown.\n    Map.prototype.get.call(value, undefined);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nIf you additionally need to ensure your are not receiving a `Map` instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace `return true;` with the following:\n\n```javascript\n// A Map's prototype's chain should be\n// value -> Map.prototype -> Object.prototype -> null\n// If it's not, then we're dealing with a Map subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n```\n\nLodash's `_.isMap()` also supports cross-realm `Map` checks, but it uses a less robust algorithm that can be easily fooled. For example, if you run Lodash in the browser, the following will return the wrong answer.\n\n```javascript\n_.isMap({ get [Symbol.toStringTag]() { return 'Map' } }); // true\n```\n\nIn Node, Lodash will instead use `require('util').types.isMap(value)` for it's implementation, which you are also welcome to use if you know your code will only run in Node. This solution will also return `true` for subclasses.\n\nSome very early JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:\n* [istypes](https://github.com/jasnell/proposal-istypes)\n* [Pattern matching's built-in matchers](https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1)\n","src":null,"test":""},{"name":"isNaN","manifest":{"fnSignature":"_.isNaN(value)","lodashLink":"https://lodash.com/docs/4.17.15#isMap","summary":"Checks if `value` is NaN. **Note:** This method is based on `Number.isNaN` and is not the same as global `isNaN` which returns `true` for `undefined` and other non-number values."},"description":"```javascript\nNumber.isNaN(value);\n```\n\nNote that `Number.isNaN()` differs from the global `isNaN()` function in that the global `isNaN()` can only be used with numeric values. Non-numeric values will be coerced into numbers, potentially yielding wrong answers.\n\n```javascript\nisNaN(undefined); // true\nNumber.isNaN(undefined); // false\n```\n","src":null,"test":""},{"name":"isNative","manifest":{"fnSignature":"_.isNative(value)","lodashLink":"https://lodash.com/docs/4.17.15#isNative","summary":"Checks if `value` is a pristine native function."},"description":"```javascript\nfunction isNative(value) {\n  if (typeof value !== 'function') {\n    return false;\n  }\n\n  const nativeFnPattern = /^function.*?\\(\\) \\{ \\[native code\\] \\}$/;\n  const valueAsString = Function.prototype.toString.call(value);\n  return nativeFnPattern.test(valueAsString);\n}\n```\n\nSome good things to know about both this implementation and Lodash's `_.isNative()`:\n* The return value of `yourNonNativeFunction.bind()` is considered a native function.\n* Not all of Node's built-in functions will be considered native, for example, in Node 18, `Function.prototype.toString.call(setTimeout)` will return the source code for the function instead of the regular `function setTimeout() { [native code] }`. This is likely due to the fact that many of Node's standard library functions are implemented in JavaScript itself.\n\nOn [Lodash's website](https://lodash.com/docs/4.17.15#isNative) you'll also see a warning about how their `_.isNative()` functions are unable to tell the difference between a core.js function and a native one, so if it detects that you are using core.js, their `_.isNative()` will always throw. The above `isNative()` is also unable to tell the difference between a core.js polyfilled function and a native one.\n\nEvery code snippet provided in Snap.js is operating under the assumption that the standard library is pristine and untouched, and the above `isNative()` operates under the same assumption. As long as no one is monkey-patching the standard library, the `isNative()` function will work with any modern JavaScript engine just fine and can't be spoofed. The reason Core.js is capable of getting around these checks is because it monkey-patches `Function.prototype.toString` and replaces it with its own implementation. If you're worried about running in an environment where monkey-patching might be happening, the correct way to handle this (for any of the snap.js functions, and any code you write in general) is to locally cache the built-in functions you need when your code first loads. Then, as long as your library is imported before any monkey-patching happens, your code won't be affected by the monkey-patching at all. If your library loads after monkey patching has happened, then all bets are off - you just have to trust that your host was responsible with how they've been messing with the globals.\n\nHere's an example of how you can make the `isNative()` function in a more robust manner, so that if this module loads before core-js (or any other library that messes with the globals), it'll still work just fine. (Writing robust code as shown above adds a big toll on the readability and maintainability of your codebase - only use techniques like this when it's actually necessary).\n\n```javascript\nconst callBind = fn => fn.call.bind(fn);\n\nconst functionToString = callBind(Function.prototype.toString);\nconst regExpTest = callBind(RegExp.prototype.test);\n\nfunction isNative(value) {\n  if (typeof value !== 'function') {\n    return false;\n  }\n\n  const nativeFnPattern = /^function.*?\\(\\) \\{ \\[native code\\] \\}$/;\n  const valueAsString = functionToString(value);\n  return regExpTest(nativeFnPattern, valueAsString);\n}\n```\n\nLodash actually follows this robust code pattern throughout its library, it has just chosen to additionally check for the presence of core.js and throw an error if it found that core.js was loaded, just in case core.js loaded before lodash.\n","src":null,"test":""},{"name":"isNil","manifest":{"fnSignature":"_.isNil(value)","lodashLink":"https://lodash.com/docs/4.17.15#isNil","summary":"Checks if `value` is `null` or `undefined`."},"description":"```javascript\nvalue == null;\n```\n\nIn general, you should never use loose equality (`==`) in JavaScript, however, many people like to make the comparison against `null` an exception to this rule because it's a convenient way to check for either `null` or `undefined` - a fairly common operation.\n\nAlternatively, if you wish to tailor to an audience who may be unfamiliar with the `== null` trick, the following would be the most explicit and easy-to-read way to go.\n\n```javascript\nvalue === null || value === undefined;\n```\n\nThere's also some who like using the nullish coalescing operator (`??`) to get similar behavior.\n\n```javascript\n(value ?? null) === null;\n```\n","src":null,"test":""},{"name":"isNull","manifest":{"fnSignature":"_.isNull(value)","lodashLink":"https://lodash.com/docs/4.17.15#isNull","summary":"Checks if `value` is `null`."},"description":"```javascript\nvalue === null\n```\n","src":null,"test":""},{"name":"isNumber","manifest":{"fnSignature":"_.isNumber(value)","lodashLink":"https://lodash.com/docs/4.17.15#isNumber","summary":"Checks if `value` is classified as a `Number` primitive or object. **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified as numbers, use the `_.isFinite` method."},"description":"To check if a value is a number primitive:\n\n```javascript\ntypeof value === 'number';\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nLodash will also check if the value is a number object. In practice, such objects should never be found in your codebase, and if someone ever tries to hand such an object to you you really ought to treat it the same way you would treat any other bad input (throw an error, or if you aren't explicitly trying to check for bad inputs just let your library fall over, the same way it would with any other bad input).\n\nTo check if something is specifically a number object (and not a primitive), use the following:\n\n```javascript\nvalue instanceof Number;\n```\n\nThis, however, doesn't work cross realm (i.e. a number object created from inside an iframe would fail this check). It also would incorrectly state that `Object.create(Number.prototype)` is a number object, when in reality, it's just a normal object who's prototype is set to `Number.prototype`. If you need to worry about these kinds of issues, use the following solution instead:\n\n```javascript\n// An isNumber() check that supports cross-realm Number instances.\n// This will check if `value` is a number primitive or object.\n// Returns `true` for values that inherit from `Number` as well.\nfunction isNumber(value) {\n  try {\n    // If you call this method with a \"this\" value that's anything\n    // other than a Number primitive or object, a TypeError is thrown.\n    Number.prototype.valueOf.call(value);\n    // Makes sure Number.prototype was not passed in.\n    const protoOf = Object.getPrototypeOf;\n    return protoOf(protoOf(value)) !== null;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nLodash's `_.isNumber()` also supports cross-realm Number object checks, but it uses a less robust algorithm that can be easily fooled. For example, the following will return the wrong answer.\n\n```javascript\n_.isNumber({ get [Symbol.toStringTag]() { return 'Number' } }); // true\n```\n\nIf you're exclusively using Node, you can use `require('util').types.isNumberObject(value)` to specifically check if the value is a number object (not a primitive). This solution will also return `true` for both subclasses and `Number.prototype`.\n","src":null,"test":""},{"name":"isObject","manifest":{"fnSignature":"_.isObject(value)","lodashLink":"https://lodash.com/docs/4.17.15#isObject","summary":"Checks if `value` is the language type of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)"},"description":"All of these solutions are equivalent. Pick the one you find to be the most readable.\n\n```javascript\nconst isObject = value => value === Object(value);\n\nconst isObject = value => ['object', 'function'].includes(typeof value) && value !== null;\n\nconst isObject = value => typeof value === 'function' || (typeof value === 'object' && value !== null);\n```","src":null,"test":""},{"name":"isObjectLike","manifest":{"fnSignature":"_.isObjectLike(value)","lodashLink":"https://lodash.com/docs/4.17.15#isObjectLike","summary":"Checks if `value` is object-like. A value is object-like if it's not `null` and has a `typeof` result of \"object\"."},"description":"```javascript\nconst isObjectLike = value => typeof value === 'object' && value !== null;\n```\n\n`_.isObjectLike()` is really the same thing as `_.isObject()` except that it excludes functions. You could be more explicit about this by naming the function something like `isObjectButNotFunction()`, or by spelling this out in code at the usage site as follows:\n\n```javascript\nconst isObject = value => value === Object(value);\n\nif (isObject(value) && typeof value !== 'function') { ... }\n```\n","src":null,"test":""},{"name":"isPlainObject","manifest":{"fnSignature":"_.isPlainObject(value)","lodashLink":"https://lodash.com/docs/4.17.15#isPlainObject","summary":"Checks if `value` is a plain object, that is, an object created by the `Object` constructor or one with a `[[Prototype]]` of `null`."},"description":"To check if your value is a \"plain object\" like `{ x: 2 }`\n\n```javascript\nvalue != null && [null, Object.prototype].includes(Object.getPrototypeOf(value));\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nThe above type-detection mechanisms has the flaw that it does not work with cross-realm values. For example, if you receive an object from across an iframe boundary, that object's prototype would link to the iframe's `Object`, not your `Object`, and the above checks would fail to recognize it as a plain object. A cross-realm compatible solution could look something like this (depending how spoof-proof you want it to be):\n\n```javascript\nfunction isPlainObject(value) {\n  if (value == null) {\n    return false;\n  }\n\n  const protoOf = Object.getPrototypeOf;\n  if (protoOf(value) === null) {\n    return true;\n  }\n\n  const objectConstructorAsString = 'function Object() { [native code] }';\n  return (\n    protoOf(protoOf(value)) === null &&\n    typeof protoOf(value).constructor === 'function' &&\n    Function.prototype.toString.call(protoOf(value).constructor) === objectConstructorAsString\n  );\n}\n```\n\nUnfortunately you can't have an is-plain-object check that's both cross-realm-compatible and spoof-proof. The algorithm presented above can be spoofed as follows:\n\n```javascript\nclass SpecialClass {\n  static {\n    Object.setPrototypeOf(SpecialClass.prototype, null)\n    // This doesn't literally change the class's constructor,\n    // it just changes an informational property to be a lie.\n    SpecialClass.prototype.constructor = Object;\n  }\n}\n\nisPlainObject(new SpecialClass()); // true\n```\n\nEven Lodash's algorithm can be spoofed.\n\n```javascript\nclass SpecialClass {\n  static {\n    SpecialClass.prototype.constructor = Object;\n  }\n}\n\n_.isPlainObject(new SpecialClass()); // true\n```\n\nSome very early JavaScript proposals may provide support for cross-realm type checking:\n* [istypes](https://github.com/jasnell/proposal-istypes)\n* [Pattern matching's built-in matchers](https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1)\n","src":null,"test":""},{"name":"isRegExp","manifest":{"fnSignature":"_.isRegExp(value)","lodashLink":"https://lodash.com/docs/4.17.15#isRegExp","summary":"Checks if `value` is classified as a `RegExp` object."},"description":"To check if your value is a regular expression instance:\n\n```javascript\nvalue instanceof RegExp;\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nIt's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:\n\n```javascript\nObject.getPrototypeOf(value) === RegExp.prototype;\n```\n\nBoth of the above type-detection mechanisms have a couple of flaws:\n1. they don't work with cross-realm values. For example, if you receive an instance of `RegExp` from across an iframe boundary, that instance's prototype would link to the iframe's `RegExp` class, not your `RegExp` class, and both of the above checks would fail to recognize it as an RegExp instance.\n2. They will state that `Object.create(RegExp.prototype)` is a regular expression instance, but it's not. It's just a regular object who's prototype has been set to `RegExp.prototype`.\n\nBoth of these issues can be solved with a helper functions such as this:\n\n```javascript\nclass StringifyError extends Error {}\n\n// An isRegExp() check that supports cross-realm RegExp instances.\n// This solution is loosely inspired by https://github.com/inspect-js/is-regex's implementation.\nfunction isRegExp(value) {\n  // An argument that throws when stringified will be used\n  // to prevent exec() from completing and updating value.lastIndex.\n  const badArgument = {\n    toString() { throw new StringifyError(); }\n  }\n\n  try {\n    // Calling the `.exec()` method,\n    // with a \"this\" value that's anything\n    // other than a RegExpr will throw a TypeError.\n    RegExp.prototype.exec.call(value, badArgument);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    } else if (error instanceof StringifyError) {\n      return true;\n    } else {\n      throw error;\n    }\n  }\n}\n```\n\nIf you additionally need to ensure your are not receiving a `RegExp` instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace `return true;` with the following:\n\n```javascript\n// A RegExp's prototype's chain should be\n// value -> RegExp.prototype -> Object.prototype -> null\n// If it's not, then we're dealing with a RegExp subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n```\n\nLodash's `_.isRegExp()` also supports cross-realm `RegExp` checks, but it uses a less robust algorithm that can be easily fooled. For example, if you run Lodash in the browser, the following will return the wrong answer.\n\n```javascript\n_.isRegExp({ get [Symbol.toStringTag]() { return 'RegExp' } }); // true\n```\n\nIn Node, Lodash will instead use `require('util').types.isRegExp(value)` for it's implementation, which you are also welcome to use if you know your code will only run in Node. This solution will also return `true` for subclasses.\n\nSome very early JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:\n* [istypes](https://github.com/jasnell/proposal-istypes)\n* [Pattern matching's built-in matchers](https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1)\n","src":null,"test":""},{"name":"isSafeInteger","manifest":{"fnSignature":"_.isSafeInteger(value)","lodashLink":"https://lodash.com/docs/4.17.15#isSafeInteger","summary":"Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754 double precision number which isn't the result of a rounded unsafe integer."},"description":"```javascript\nNumber.isSafeInteger(value);\n```\n","src":null,"test":""},{"name":"isSet","manifest":{"fnSignature":"_.isSet(value)","lodashLink":"https://lodash.com/docs/4.17.15#isSet","summary":"Checks if `value` is classified as a `Set` object."},"description":"To check if your value is an instance of `Set`:\n\n```javascript\nvalue instanceof Set;\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nIt's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:\n\n```javascript\nObject.getPrototypeOf(value) === Set.prototype;\n```\n\nBoth of the above type-detection mechanisms have a couple of flaws:\n1. they don't work with cross-realm values. For example, if you receive an instance of a `Set` from across an iframe boundary, that instance's prototype would link to the iframe's `Set` class, not your `Set` class, and both of the above checks would fail to recognize it as a `Set`.\n2. They will state that `Object.create(Set.prototype)` is a `Set`, but it's not. It's just a regular object who's prototype has been set to `Set.prototype`.\n\nBoth of these issues can be solved with a helper function like this:\n\n```javascript\n// An isSet() check that supports cross-realm Sets.\nfunction isSet(value) {\n  try {\n    // If you call a Set method, like .size(),\n    // with a \"this\" value that's anything\n    // other than a Set, a TypeError is thrown.\n    Set.prototype.has.call(value, undefined);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nIf you additionally need to ensure your are not receiving a `Set` instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace `return true;` with the following:\n\n```javascript\n// A Set's prototype's chain should be\n// value -> Set.prototype -> Object.prototype -> null\n// If it's not, then we're dealing with a Set subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n```\n\nLodash's `_.isSet()` also supports cross-realm `Set` checks, but it uses a less robust algorithm that can be easily fooled. For example, if you run Lodash in the browser, the following will return the wrong answer.\n\n```javascript\n_.isSet({ get [Symbol.toStringTag]() { return 'Set' } }); // true\n```\n\nIn Node, Lodash will instead use `require('util').types.isSet(value)` for it's implementation, which you are also welcome to use if you know your code will only run in Node. This solution will also return `true` for subclasses.\n\nSome very early JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:\n* [istypes](https://github.com/jasnell/proposal-istypes)\n* [Pattern matching's built-in matchers](https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1)\n","src":null,"test":""},{"name":"isString","manifest":{"fnSignature":"_.isString(value)","lodashLink":"https://lodash.com/docs/4.17.15#isString","summary":"Checks if `value` is classified as a `string` primitive or object."},"description":"To check if a value is a string primitive:\n\n```javascript\ntypeof value === 'string';\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nLodash will also check if the value is a string object. In practice, such objects should never be found in your codebase, and if someone ever tries to hand such an object to you you really ought to treat it the same way you would treat any other bad input (throw an error, or if you aren't explicitly trying to check for bad inputs just let your library fall over, the same way it would with any other bad input).\n\nTo check if something is specifically a string object (and not a primitive), use the following:\n\n```javascript\nvalue instanceof Boolean;\n```\n\nThis, however, doesn't work cross realm (i.e. a string object created from inside an iframe would fail this check). It also would incorrectly state that `Object.create(String.prototype)` is a string object, when in reality, it's just a normal object who's prototype is set to `String.prototype`. If you need to worry about these kinds of issues, use the following solution instead:\n\n```javascript\n// An isString() check that supports cross-realm String instances.\n// This will check if `value` is a string primitive or object.\n// Returns `true` for values that inherit from `String` as well.\nfunction isString(value) {\n  try {\n    // If you call this method with a \"this\" value that's anything\n    // other than a boolean primitive or object, a TypeError is thrown.\n    String.prototype.toString.call(value);\n    // Makes sure String.prototype was not passed in.\n    const protoOf = Object.getPrototypeOf;\n    return protoOf(protoOf(value)) !== null;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nLodash's `_.isString()` also supports cross-realm `String` object checks, but it uses a less robust algorithm that can be easily fooled. For example, the following will return the wrong answer.\n\n```javascript\n_.isString({ get [Symbol.toStringTag]() { return 'String' } }); // true\n```\n\nIf you're exclusively using Node, you can use `require('util').types.isStringObject(value)` to specifically check if the value is a string object (not a primitive). This solution will also return `true` for both subclasses and `Boolean.prototype`.","src":null,"test":""},{"name":"isSymbol","manifest":{"fnSignature":"_.isSymbol(value)","lodashLink":"https://lodash.com/docs/4.17.15#isSymbol","summary":"Checks if `value` is classified as a `symbol` primitive or object."},"description":"To check if a value is a symbol primitive:\n\n```javascript\ntypeof value === 'symbol';\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nLodash will also check if the value is a symbol object. In practice, such objects should never be found in your codebase, and if someone ever tries to hand such an object to you you really ought to treat it the same way you would treat any other bad input (throw an error, or if you aren't explicitly trying to check for bad inputs just let your library fall over, the same way it would with any other bad input).\n\nTo check if something is specifically a symbol object (and not a primitive), use the following:\n\n```javascript\nvalue instanceof Symbol;\n```\n\nThis, however, doesn't work cross realm (i.e. a symbol object created from inside an iframe would fail this check). It also would incorrectly state that `Object.create(Symbol.prototype)` is a symbol object, when in reality, it's just a normal object who's prototype is set to `Symbol.prototype`. If you need to worry about these kinds of issues, use the following solution instead:\n\n```javascript\n// An isSymbol() check that supports cross-realm Symbol instances.\n// This will check if `value` is a symbol primitive or object.\nfunction isSymbol(value) {\n  try {\n    // If you call this method with a \"this\" value that's anything\n    // other than a boolean primitive or object, a TypeError is thrown.\n    Symbol.prototype.valueOf.call(value);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nLodash's `_.isSymbol()` also supports cross-realm `Symbol` object checks, but it uses a less robust algorithm that can be easily fooled. For example, the following will return the wrong answer.\n\n```javascript\n_.isSymbol({ get [Symbol.toStringTag]() { return 'Symbol' } }); // true\n```\n\nIf you're exclusively using Node, you can use `require('util').types.isSymbolObject(value)` to specifically check if the value is a string object (not a primitive).","src":null,"test":""},{"name":"isTypedArray","manifest":{"fnSignature":"_.isTypedArray(value)","lodashLink":"https://lodash.com/docs/4.17.15#isTypedArray","summary":"Checks if `value` is classified as a typed array."},"description":"All concrete type array classes (like `Int8Array` and `Uint32Array`) inherit from the same abstract superclass `TypedArray`. This superclass isn't directly available on the global object, but it's not too hard to get your hands on it. You can use the `TypedArray` superclass to check if a value is a typed array as follows:\n\n```javascript\nfunction isTypedArray(value) {\n  // Get the super class of all typed arrays.\n  const TypedArray = Object.getPrototypeOf(Int8Array);\n\n  return value instanceof TypedArray;\n}\n\nisTypedArray(new Int8Array()); // true\nisTypedArray(new Uint32Array()); // true\n```\n\nFor the vast majority of scenarios the above should be good enough, but it does technically have a couple of flaws:\n1. they don't work with cross-realm values. For example, if you receive an instance of an `Int8Array` from across an iframe boundary, that instance's prototype would link to the iframe's `TypedArray` class, not your `TypedArray` class, and both of the above checks would fail to recognize it as a typed array.\n2. They will state that `Object.create(TypedArray.prototype)` is a `TypedArray`, but it's not. It's just a regular object who's prototype has been set to `TypedArray.prototype`.\n\nBoth of these issues can be solved with a helper function like this:\n\n```javascript\n// An isTypedArray() check that supports cross-realm typed arrays.\nfunction isTypedArray(value) {\n  const TypedArray = Object.getPrototypeOf(Int8Array);\n  try {\n    // If you call a TypedArray method, like .at(),\n    // with a \"this\" value that's anything\n    // other than a typed array, a TypeError is thrown.\n    TypedArray.prototype.at.call(value, 0);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nIt's generally considered a bad practice to subclass built-ins, but if you suspect that one of the concrete typed array classes might getting subclassed and handed to you, and you wish to exclude subclasses from your check, you'd also need to walk up the prototype chain. You can modify the above example and replace `return true;` with the following:\n\n```javascript\n// A typed array prototype's chain should be\n// value -> concrete class prototype (like Int8Array.prototype) -> TypedArray.prototype -> Object.prototype -> null\n// If it's not, then we're dealing with a subclass of a concrete typed array.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(protoOf(value)))) === null;\n```\n\nLodash's `_.isTypedArray()` also supports cross-realm typed array checks, but it uses a less robust algorithm that can be easily fooled. For example, if you run Lodash in the browser, the following will return the wrong answer.\n\n```javascript\n_.isTypedArray({ length: 0, get [Symbol.toStringTag]() { return 'Uint8Array' } }); // true\n```\n\nIn Node, Lodash will instead use `require('util').types.isTypedArray(value)` for it's implementation, which you are also welcome to use if you know your code will only run in Node. This solution will also return `true` for subclasses.\n\nSome very early JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:\n* [istypes](https://github.com/jasnell/proposal-istypes)\n* [Pattern matching's built-in matchers](https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1)\n","src":null,"test":""},{"name":"isUndefined","manifest":{"fnSignature":"_.isUndefined(value)","lodashLink":"https://lodash.com/docs/4.17.15#isUndefined","summary":"Checks if `value` is `undefined`."},"description":"```javascript\nvalue === undefined;\n```\n\nAt one point in time it was often considered a good practice to compare against `void 0` instead of `undefined`, as `undefined` was just a property on the window object that could be overwritten to be any value while `void 0` (which returns the undefined value) can not be overwritten since it is syntax. The ability to globally overwrite the `undefined` value was changed in ES5, removing this concern in modern browsers. Even back then, this concern was largely over-hyped - yes you can override the value of `undefined`, but you can also override `Array`, `Math`, `Object`, `Function`, `setTimeout`, and so on - if the code you write doesn't try to defend against these globals being overwritten, then it should not try to defend against `undefined` being overwritten either.\n\nSide rant: In case you didn't know, `void` is _not_ a function, it is a prefix operator with the same precedence as `!`, `await`, `typeof`, and so on. You don't try to pretend `await` is a function by always adding parentheses after it, do you? (`await(doSomeAsyncTask())`)? No. And you really don't need to do it with `void` either. Is there harm in pretending a prefix operator is a function? In general, yes, because it makes order of operations confusing - if we pretend that `await` is a function, then you might end up writing code such as `await(getUser(id)).username` that looks reasonable, except it's not going to work - `getUser(...)` is going to return a promise, and then it's going to try to access the `username` property on that promise _before_ the `await` happens, which is not what the author intended. Is it bad to pretend that `void`, specifically, is a function instead of an operator. Well, technically no, there's no reasonable code that you would write using `void` where order of operations would get confusing, at least in the language as it stands today. But, the point is, `void` is an operator, not a function, and there's no reason to pretend it's something that it's not.\n","src":null,"test":""},{"name":"isWeakMap","manifest":{"fnSignature":"_.isWeakMap(value)","lodashLink":"https://lodash.com/docs/4.17.15#isWeakMap","summary":"Checks if `value` is classified as a `WeakMap` object."},"description":"To check if your value is an instance of `WeakMap`:\n\n```javascript\nvalue instanceof WeakMap;\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nIt's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:\n\n```javascript\nObject.getPrototypeOf(value) === WeakMap.prototype;\n```\n\nBoth of the above type-detection mechanisms have a couple of flaws:\n1. they don't work with cross-realm values. For example, if you receive an instance of a `WeakMap` from across an iframe boundary, that instance's prototype would link to the iframe's `WeakMap` class, not your `WeakMap` class, and both of the above checks would fail to recognize it as a `WeakMap`.\n2. They will state that `Object.create(WeakMap.prototype)` is a `WeakMap`, but it's not. It's just a regular object who's prototype has been set to `WeakMap.prototype`.\n\nBoth of these issues can be solved with a helper function like this:\n\n```javascript\n// An isWeakMap() check that supports cross-realm WeakMaps.\nfunction isWeakMap(value) {\n  try {\n    // If you call a WeakMap method, like .get(),\n    // with a \"this\" value that's anything\n    // other than a WeakMap, a TypeError is thrown.\n    WeakMap.prototype.get.call(value, undefined);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nIf you additionally need to ensure your are not receiving a `WeakMap` instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace `return true;` with the following:\n\n```javascript\n// A WeakMap's prototype's chain should be\n// value -> WeakMap.prototype -> Object.prototype -> null\n// If it's not, then we're dealing with a WeakMap subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n```\n\nLodash's `_.isWeakMap()` also supports cross-realm `WeakMap` checks, but it uses a less robust algorithm that can be easily fooled. For example, the following will return the wrong answer.\n\n```javascript\n_.isWeakMap({ get [Symbol.toStringTag]() { return 'WeakMap' } }); // true\n```\n\nIf you're exclusively using Node, you can use `require('util').types.isWeakMap(value)` to specifically check if the value is a WeakMap. This solution will also return `true` for subclasses.\n\nSome very early JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:\n* [istypes](https://github.com/jasnell/proposal-istypes)\n* [Pattern matching's built-in matchers](https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1)\n","src":null,"test":""},{"name":"isWeakSet","manifest":{"fnSignature":"_.isWeakSet(value)","lodashLink":"https://lodash.com/docs/4.17.15#isWeakSet","summary":"Checks if `value` is classified as a `WeakSet` object."},"description":"To check if your value is an instance of `WeakSet`:\n\n```javascript\nvalue instanceof WeakSet;\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nIt's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:\n\n```javascript\nObject.getPrototypeOf(value) === WeakSet.prototype;\n```\n\nBoth of the above type-detection mechanisms have a couple of flaws:\n1. they don't work with cross-realm values. For example, if you receive an instance of a `WeakSet` from across an iframe boundary, that instance's prototype would link to the iframe's `WeakSet` class, not your `WeakSet` class, and both of the above checks would fail to recognize it as a `WeakSet`.\n2. They will state that `Object.create(WeakSet.prototype)` is a `WeakSet`, but it's not. It's just a regular object who's prototype has been set to `WeakSet.prototype`.\n\nBoth of these issues can be solved with a helper function like this:\n\n```javascript\n// An isWeakSet() check that supports cross-realm WeakSets.\nfunction isWeakSet(value) {\n  try {\n    // If you call a WeakSet method, like .has(),\n    // with a \"this\" value that's anything\n    // other than a WeakSet, a TypeError is thrown.\n    WeakSet.prototype.has.call(value, undefined);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nIf you additionally need to ensure your are not receiving a `WeakSet` instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace `return true;` with the following:\n\n```javascript\n// A WeakSet's prototype's chain should be\n// value -> WeakSet.prototype -> Object.prototype -> null\n// If it's not, then we're dealing with a WeakSet subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n```\n\nLodash's `_.isWeakSet()` also supports cross-realm `WeakSet` checks, but it uses a less robust algorithm that can be easily fooled. For example, the following will return the wrong answer.\n\n```javascript\n_.isWeakSet({ get [Symbol.toStringTag]() { return 'WeakSet' } }); // true\n```\n\nIf you're exclusively using Node, you can use `require('util').types.isWeakSet(value)` to specifically check if the value is a WeakSet. This solution will also return `true` for subclasses.\n\nSome very early JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:\n* [istypes](https://github.com/jasnell/proposal-istypes)\n* [Pattern matching's built-in matchers](https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1)\n","src":null,"test":""},{"name":"lt","manifest":{"fnSignature":"_.lt(value, other)","lodashLink":"https://lodash.com/docs/4.17.15#lt","summary":"Checks if `value` is less than `other`."},"description":"```javascript\nvalue < other\n```\n\nOne reason `_.lt()` exists, is because it's a ready-made function, that can easily be passed into other functions, like this:\n\n```javascript\n> _.zipWith([1, 2, 3], [3, 2, 1], _.lt)\n[true, false, false]\n```\n\nWhen Lodash was first born, the only alternative at the time would be to create an entire function, using the `function` keyword.\n\n```javascript\n_.zipWith([1, 2, 3], [3, 2, 1], function (a, b) {\n  return a < b;\n})\n```\n\nSince then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.\n\n```javascript\n_.zipWith([1, 2, 3], [3, 2, 1], (a, b) => a < b)\n```\n","src":null,"test":""},{"name":"lte","manifest":{"fnSignature":"_.lte(value, other)","lodashLink":"https://lodash.com/docs/4.17.15#lte","summary":"Checks if `value` is less than or equal to `other`."},"description":"```javascript\nvalue <= other\n```\n\nOne reason `_.lte()` exists, is because it's a ready-made function, that can easily be passed into other functions, like this:\n\n```javascript\n> _.zipWith([1, 2, 3], [3, 2, 1], _.lte)\n[true, true, false]\n```\n\nWhen Lodash was first born, the only alternative at the time would be to create an entire function, using the `function` keyword.\n\n```javascript\n_.zipWith([1, 2, 3], [3, 2, 1], function (a, b) {\n  return a <= b;\n})\n```\n\nSince then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.\n\n```javascript\n_.zipWith([1, 2, 3], [3, 2, 1], (a, b) => a <= b)\n```\n","src":null,"test":""},{"name":"toFinite","manifest":{"fnSignature":"_.toFinite(value)","lodashLink":"https://lodash.com/docs/4.17.15#toFinite","summary":"Converts `value` to a finite number."},"description":"```javascript\nfunction toFinite(value) {\n  if (Number.isNaN(value)) {\n    // Alternatively, you can choose to return NaN here.\n    // Or do what Lodash does and return 0.\n    // Or take out this check and not provide any explicit NaN handling code.\n    throw new Error('Can not convert NaN to a finite number.');\n  }\n\n  if (value === -Infinity) return -Number.MAX_VALUE;\n  if (value === Infinity) return Number.MAX_VALUE;\n  return value;\n}\n```\n\nThe above implementation expects `value` to be a number. If you expect arguments of other types, then refer to tips in [the `_.toNumber()` entry](#!/nolodash/toNumber) for converting arbitrary values into numbers.\n","src":null,"test":""},{"name":"toInteger","manifest":{"fnSignature":"_.toInteger(value)","lodashLink":"https://lodash.com/docs/4.17.15#toInteger","summary":"Converts `value` to an integer."},"description":"```javascript\nMath.trunc(value)\n```\n\nThis does differ from Lodash's implementation in one minor way - `_.toInteger(NaN)` will return `0` while `Math.trunc(NaN)` will return `NaN`. If you need `NaN` to convert to `0`, consider checking if `value` is `NaN` using `Number.isNaN()` before calling `Math.trunc()`.\n\nBoth `Math.trunc()` and `_.toInteger()` will return `Infinity` and `-Infinity` as-is, even though these values aren't integers. If you need different behavior, you will need to check for infinity up front (e.g. with `!Number.isFinite(value)`).\n\nIf `value` is not a number, you may wish to explicitly convert it into one before-hand instead of relying on `Math.trunc()` to implicitly convert it for you. You can refer to [the `_.toNumber()` entry](#!/nolodash/toNumber) for tips on converting a string into a number.\n","src":null,"test":""},{"name":"toLength","manifest":{"fnSignature":"_.toLength(value)","lodashLink":"https://lodash.com/docs/4.17.15#toLength","summary":"Converts `value` to an integer suitable for use as the length of an array-like object."},"description":"```javascript\n// The maximum array size is the largest 32bit integer (2**32 - 1).\nconst MAX_ARRAY_SIZE = 4294967295;\n\nfunction toLength(value) {\n  if (Number.isNaN(value)) {\n    // Alternatively, you can choose to return NaN here.\n    // Or do what Lodash does and return 0.\n    // Or take out this check and not provide any explicit NaN handling code.\n    throw new Error('Can not convert NaN to a safe integer');\n  }\n\n  if (value < 0) return 0;\n  if (value > MAX_ARRAY_SIZE) return MAX_ARRAY_SIZE;\n  return Math.trunc(value);\n}\n```\n\nThe above implementation expects `value` to be a number. If you expect arguments of other types, then refer to tips in [the `_.toNumber()` entry](#!/nolodash/toNumber) for converting arbitrary values into numbers.\n","src":null,"test":""},{"name":"toNumber","manifest":{"fnSignature":"_.toNumber(value)","lodashLink":"https://lodash.com/docs/4.17.15#toNumber","summary":"Converts `value` to a number."},"description":"```javascript\nNumber(value)\n// or\n+value\n```\n\nBoth `Number()` and the `+` unary operator behave the exact same, so either can be chosen. These can be used to convert a variety of different values, including bigint, booleans, strings, etc.\n\nIf you are converting a string to a number, you will likely want to additionally compare your string against a regular expression to make sure it is in the format you expect it to be in. The following are some strings that `Number()` will happily parse for you, that you might want to prevent with your regular expression:\n* Strings containing numbers with leading and/or trailing spaces (e.g. `Number('  23  ') === 23`)\n* Decimal number (e.g. `Number('2.3') === 2.3` or `Number('2.3E+5') === 2.3E+5`)\n* Scientific notation (e.g. `Number('2e3') === 2e3`)\n* Numbers in different basis (e.g. `Number('0x2a') === 0x2a`, `Number('0o47') === 0o47`, or `Number('0b101') === 0b101`)\n* Empty strings and white-space-only strings (e.g. `Number(' \\t \\n ') === 0`)\n* Numbers with a sign (e.g. `Number('-2') === -2` or `Number('+2') === +2`)\n* Infinity and -Infinity? (e.g. `Number('-Infinity') === -Infinity`)\n* Leading zeros? (e.g. `Number('012') === 12`)\n\nAs a concrete example, if you are receiving user input, and you only want to allow integer inputs (and you are ok with leading zeros), you can use a function like the following to get your desired behavior:\n\n```javascript\nfunction parseUserInput(value) {\n  // Ensures the string only contains digits and nothing else.\n  if (!value.match(/^\\d+$/)) {\n    throw new Error('Invalid user input');\n  }\n\n  const parsedValue = Number(value);\n\n  if (Number.isNaN(parsedValue)) {\n    throw new Error('Invalid user input');\n  }\n\n  return parsedValue;\n}\n```\n\n## What about parseInt() and parseFloat()?\n\nYou are welcome to use either of these functions as well for string-to-number conversions. These two functions follow their own different algorithms for parsing numbers that may or may not align with what you need. One unfortunate design decision to be aware of with these functions is the fact that as soon as they come across an invalid character, instead of returning an error value (`NaN`), they just parse what they can and return a number. This means, for example, `parseInt('2e7')` will unintuitively return the number `2`, because it doesn't know how to parse the `e`. All this really means is that it is even more important to use some up-front checking with a regular expression to ensure your string is formatted the way you would expect before handing the string off to `parseInt()` or `parseFloat()` to parse. It is also for this reason that I prefer using `Number()` over `parseInt()`/`parseFloat()` - `Number()` is less likely to surprise you with an unexpected result.\n","src":null,"test":""},{"name":"toSafeInteger","manifest":{"fnSignature":"_.toSafeInteger(value)","lodashLink":"https://lodash.com/docs/4.17.15#toSafeInteger","summary":"Converts `value` to a safe integer. A safe integer can be compared and represented correctly."},"description":"```javascript\nfunction toSafeInteger(value) {\n  if (Number.isNaN(value)) {\n    // Alternatively, you can choose to return NaN here.\n    // Or do what Lodash does and return 0.\n    // Or take out this check and not provide any explicit NaN handling code.\n    throw new Error('Can not convert NaN to a safe integer');\n  }\n\n  if (value < Number.MIN_SAFE_INTEGER) return Number.MIN_SAFE_INTEGER;\n  if (value > Number.MAX_SAFE_INTEGER) return Number.MAX_SAFE_INTEGER;\n  return Math.trunc(value);\n}\n```\n\nThe above implementation expects `value` to be a number. If you expect arguments of other types, then refer to tips in [the `_.toNumber()` entry](#!/nolodash/toNumber) for converting arbitrary values into numbers.\n","src":null,"test":""}]},{"categoryHeading":"Math","entries":[{"name":"add","manifest":{"fnSignature":"_.add(augend, addend)","lodashLink":"https://lodash.com/docs/4.17.15#add","summary":"Adds two numbers."},"description":"```javascript\naugend + addend;\n```\n\nOne reason `_.add()` exists, is because it's a ready-made function, that can easily be passed into other functions, like this:\n\n```javascript\n> _.reduce([2, 3, 4], _.add);\n9\n```\n\nWhen Lodash was first born, the only alternative at the time would be to create an entire function, using the `function` keyword.\n\n```javascript\n_.reduce([2, 3, 4], function (a, b) {\n  return a + b;\n});\n```\n\nSince then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.\n\n```javascript\n_.reduce([2, 3, 4], (a, b) => a + b);\n```\n","src":null,"test":""},{"name":"ceil","manifest":{"fnSignature":"_.ceil(number, precision?)","lodashLink":"https://lodash.com/docs/4.17.15#ceil","summary":"Computes `number` rounded up to `precision`."},"description":"If you don't need to use the optional precision argument, then you can simply use the following:\n\n```javascript\nMath.ceil(number);\n```\n\nOtherwise:\n\n```javascript\nfunction ceil(number, precision=0) {\n  const factor = 10**precision;\n  return Math.ceil(number * factor) / factor;\n}\n```","src":null,"test":""},{"name":"divide","manifest":{"fnSignature":"_.divide(dividend, divisor)","lodashLink":"https://lodash.com/docs/4.17.15#divide","summary":"Divide two numbers."},"description":"```javascript\naugend / addend;\n```\n\nOne reason `_.divide()` exists, is because it's a ready-made function, that can easily be passed into other functions, like this:\n\n```javascript\n> _.reduce([100, 2, 5], _.divide);\n10\n```\n\nWhen Lodash was first born, the only alternative at the time would be to create an entire function, using the `function` keyword.\n\n```javascript\n_.reduce([100, 2, 5], function (a, b) {\n  return a / b;\n});\n```\n\nSince then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.\n\n```javascript\n_.reduce([100, 2, 5], (a, b) => a / b);\n```\n","src":null,"test":""},{"name":"floor","manifest":{"fnSignature":"_.floor(number, precision?)","lodashLink":"https://lodash.com/docs/4.17.15#floor","summary":"Computes `number` rounded down to `precision`."},"description":"If you don't need to use the optional precision argument, then you can simply use the following:\n\n```javascript\nMath.floor(number);\n```\n\nOtherwise:\n\n```javascript\nfunction floor(number, precision=0) {\n  const factor = 10**precision;\n  return Math.floor(number * factor) / factor;\n}\n```","src":null,"test":""},{"name":"max","manifest":{"fnSignature":"_.max(array)","lodashLink":"https://lodash.com/docs/4.17.15#max","summary":"Computes the maximum value of array. If array is empty or falsey, undefined is returned."},"description":"```javascript\nMath.max(...array);\n```\n\nThere's a couple of very minor differences in behavior between Lodash's `_.max()`, and JavaScript's native `Math.max()` (apart from the fact that you have to spread your array into JavaScript's version).\n\n1. In Lodash's version, if you provide a falsey value, `undefined` will be returned. In JavaScript, if you try to spread a falsey value into `Math.max()`, you'll get a runtime error, because falsey values aren't iterable. In practice, this difference shouldn't matter much - you should know the types of values you're trying to use, and if you suspect that it might be falsey, just check for that before calling `Math.max()`, instead of checking if the result is undefined after calling `_.max()`.\n\n2. In Lodash's version, if you provide an empty array, `undefined` is returned. In JavaScript, if you spread an empty array, or you provide no arguments, `-Infinity` is returned. JavaScript's `-Infinity`, while, at first, may sound odd, can actually be a useful return value. It allows you to cleanly write many algorithms capable of operating on empty arrays, without having to explicitly check if the array is empty. Not everyone likes to write algorithms this way, but `Math.max()` gives you the option when it's wanted.","src":null,"test":""},{"name":"maxBy","manifest":{"fnSignature":"_.maxBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#maxBy","summary":"This method is like `_.max` except that it accepts `iteratee` which is invoked for each element in `array` to generate the criterion by which the value is ranked."},"description":"```javascript\nfunction maxBy(array, iteratee) {\n  if (array.length === 0) {\n    return undefined;\n  }\n\n  return array\n    .map(value => ({ value, score: iteratee(value) }))\n    .reduce((best, cur) => cur.score > best.score ? cur : best)\n    .value;\n}\n```\n","src":null,"test":""},{"name":"mean","manifest":{"fnSignature":"_.mean(array)","lodashLink":"https://lodash.com/docs/4.17.15#mean","summary":"Computes the mean of the values in array."},"description":"```javascript\nfunction mean(array) {\n  return array.reduce((a, b) => a + b) / array.length;\n}\n```\n","src":null,"test":""},{"name":"meanBy","manifest":{"fnSignature":"_.meanBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#meanBy","summary":"This method is like `_.mean` except that it accepts `iteratee` which is invoked for each element in `array` to generate the value to be averaged."},"description":"We will use a plain JavaScript implementation of `_.mean()` to solve this problem.\n\n```javascript\nfunction mean(array) {\n  return array.reduce((a, b) => a + b) / array.length;\n}\n\n// Uses `iteratee` on each element of the array, to convert them to\n// new values, before taking the mean.\nmean(array.map(iteratee));\n```\n","src":null,"test":""},{"name":"min","manifest":{"fnSignature":"_.min(array)","lodashLink":"https://lodash.com/docs/4.17.15#min","summary":"Computes the minimum value of `array`. If `array` is empty or falsey, `undefined` is returned."},"description":"```javascript\nMath.min(...array);\n```\n\nThere's a couple of very minor differences in behavior between Lodash's `_.min()`, and JavaScript's native `Math.min()` (apart from the fact that you have to spread your array into JavaScript's version).\n\n1. In Lodash's version, if you provide a falsey value, `undefined` will be returned. In JavaScript, if you try to spread a falsey value into `Math.min()`, you'll get a runtime error, because falsey values aren't iterable. In practice, this difference shouldn't matter much - you should know the types of values you're trying to use, and if you suspect that it might be falsey, just check for that before calling `Math.min()`, instead of checking if the result is undefined after calling `_.min()`.\n\n2. In Lodash's version, if you provide an empty array, `undefined` is returned. In JavaScript, if you spread an empty array, or you provide no arguments, `Infinity` is returned. JavaScript's `Infinity`, while, at first, may sound odd, can actually be a useful return value. It allows you to cleanly write many algorithms capable of operating on empty arrays, without having to explicitly check if the array is empty. Not everyone likes to write algorithms this way, but `Math.min()` gives you the option when it's wanted.","src":null,"test":""},{"name":"minBy","manifest":{"fnSignature":"_.minBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#minBy","summary":"This method is like `_.min` except that it accepts `iteratee` which is invoked for each element in `array` to generate the criterion by which the value is ranked."},"description":"```javascript\nfunction minBy(array, iteratee) {\n  if (array.length === 0) {\n    return undefined;\n  }\n\n  return array\n    .map(value => ({ value, score: iteratee(value) }))\n    .reduce((best, cur) => cur.score < best.score ? cur : best)\n    .value;\n}\n```\n","src":null,"test":""},{"name":"multiply","manifest":{"fnSignature":"_.multiply(multiplier, multiplicand)","lodashLink":"https://lodash.com/docs/4.17.15#multiply","summary":"Multiply two numbers."},"description":"```javascript\nmultiplier * multiplicand;\n```\n\nOne reason `_.multiply()` exists, is because it's a ready-made function, that can easily be passed into other functions, like this:\n\n```javascript\n> _.reduce([2, 3, 4], _.multiply);\n24\n```\n\nWhen Lodash was first born, the only alternative at the time would be to create an entire function, using the `function` keyword.\n\n```javascript\n_.reduce([2, 3, 4], function (a, b) {\n  return a * b;\n});\n```\n\nSince then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.\n\n```javascript\n_.reduce([2, 3, 4], (a, b) => a * b);\n```\n","src":null,"test":""},{"name":"round","manifest":{"fnSignature":"_.round(number, precision?)","lodashLink":"https://lodash.com/docs/4.17.15#round","summary":"Computes `number` rounded to `precision`."},"description":"If you don't need to use the optional precision argument, then you can simply use the following:\n\n```javascript\nMath.round(number);\n```\n\nOtherwise:\n\n```javascript\nfunction round(number, precision=0) {\n  const factor = 10**precision;\n  return Math.round(number * factor) / factor;\n}\n```\n","src":null,"test":""},{"name":"subtract","manifest":{"fnSignature":"_.subtract(minuend, subtrahend)","lodashLink":"https://lodash.com/docs/4.17.15#subtract","summary":"Subtract two numbers."},"description":"```javascript\nminuend - subtrahend;\n```\n\nOne reason `_.subtract()` exists, is because it's a ready-made function, that can easily be passed into other functions, like this:\n\n```javascript\n> _.reduce([10, 3, 4], _.subtract);\n3\n```\n\nWhen Lodash was first born, the only alternative at the time would be to create an entire function, using the `function` keyword.\n\n```javascript\n_.reduce([10, 3, 4], function (a, b) {\n  return a - b;\n});\n```\n\nSince then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.\n\n```javascript\n_.reduce([10, 3, 4], (a, b) => a - b);\n```\n","src":null,"test":""},{"name":"sum","manifest":{"fnSignature":"_.sum(array)","lodashLink":"https://lodash.com/docs/4.17.15#sum","summary":"Computes the sum of the values in `array`."},"description":"If you want an empty array to throw an error:\n\n```javascript\narray.reduce((a, b) => a + b);\n```\n\nIf you want an empty array to cause `0` to be returned:\n\n```javascript\narray.reduce((a, b) => a + b, 0);\n```\n","src":null,"test":""},{"name":"sumBy","manifest":{"fnSignature":"_.sumBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#sumBy","summary":"This method is like `_.sum` except that it accepts `iteratee` which is invoked for each element in `array` to generate the value to be summed."},"description":"Simply map over your array with `iteratee`, before trying to sum it:\n\n```javascript\narray\n  .map(iteratee)\n  .reduce((a, b) => a + b);\n```\n","src":null,"test":""}]},{"categoryHeading":"Number","entries":[{"name":"clamp","manifest":{"fnSignature":"_.clamp(number, lower?, upper)","lodashLink":"https://lodash.com/docs/4.17.15#clamp","summary":"Clamps number within the inclusive `lower` and `upper` bounds."},"description":"```javascript\nMath.max(Math.min(number, upper), lower);\n```\n","src":null,"test":""},{"name":"inRange","manifest":{"fnSignature":"_.inRange(number, start?, end)","lodashLink":"https://lodash.com/docs/4.17.15#clamp","summary":"Checks if `n` is between `start` and up to, but not including, `end`. If `start` is greater than `end` the params are swapped to support negative ranges."},"description":"To simply check if a number is between two others, use the following:\n\n```javascript\nstart <= number && number < end;\n```\n\nIf you're uncertain which of the two numbers are lower, use the following:\n\n```javascript\nfunction inRange(number, start, end) {\n  const bounds = start < end\n    ? [start, end]\n    : [end, start];\n\n  return bounds[0] <= number && number < bounds[1];\n}\n```\n","src":null,"test":""},{"name":"random","manifest":{"fnSignature":"_.random(lower?, upper?, floating?)","lodashLink":"https://lodash.com/docs/4.17.15#random","summary":"Produces a random number between the inclusive `lower` and `upper` bounds. If `floating` is true, or either `lower` or `upper` are floats, a floating-point number is returned instead of an integer."},"description":"## For random floats\n\nIf you want a random float between 0 and `upper`:\n\n```javascript\nMath.random() * upper;\n```\n\nIf you want a random float between `lower` and `upper`:\n\n```javascript\nlower + Math.random() * (upper - lower);\n```\n\n## For random integers\n\nAll of these examples will treat `upper` as exclusive, not inclusive. If you want it to be inclusive like it is in Lodash (i.e. you want it to be possible for the upper bound to be returned), add one to `upper`.\n\nIf you want a random integer between 0 and `upper`:\n\n```javascript\nMath.floor(Math.random() * upper);\n```\n\nIf you want a random integer between lower and upper:\n\n```javascript\nlower + Math.floor(Math.random() * (upper - lower));\n```\n","src":null,"test":""}]},{"categoryHeading":"Object","entries":[{"name":"assign","manifest":{"fnSignature":"_.assign(object, ...sources)","lodashLink":"https://lodash.com/docs/4.17.15#assign","summary":"Assigns own enumerable string keyed properties of source objects to the destination object."},"description":"```javascript\nObject.assign(object, sourceObj1, sourceObj2);\n```\n\nOr, if all you want to do is merge objects together, and you don't wish to mutate anything, you can use the spread syntax.\n\n```javascript\n{ ...sourceObj1, ...sourceObj2 };\n```","src":null,"test":""},{"name":"assignIn","manifest":{"fnSignature":"_.assignIn(object, ...sources)","lodashLink":"https://lodash.com/docs/4.17.15#assignIn","summary":"This method is like `_.assign` except that it iterates over own and inherited source properties."},"description":"```javascript\nfunction assignIn(object, ...sources) {\n  for (const source of sources) {\n    for (const key in source) {\n      object[key] = source[key];\n    }\n  }\n\n  return object;\n}\n```\n\nIt's very likely that you don't actually need this function. The only way this function is different from `_.assign()` (or `Object.assign()`), is that it'll also copy over non-enumerable inherited fields. But...\n1. Class syntax will automatically make all methods on the prototype chain non-enumerable, which means the `assignIn()` function won't copy them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n2. Why are you even trying to copy both the data and the inherited methods off of an object? If you want one object to share the same methods as another object, consider using normal inheritance.\n\nPerhaps there's some niche use-cases for this sort of function that arise from fairly abnormal and tricky uses of the JavaScript prototype, but, for day-to-day development, it's best to stay away from this function. If you just want to copy data over from one object to another, please look at `_.assign()` instead.\n","src":null,"test":""},{"name":"assignInWith","manifest":{"fnSignature":"_.assignInWith(object, ...sources, customizer)","lodashLink":"https://lodash.com/docs/4.17.15#assignInWith","summary":"This method is like `_.assignIn` except that it accepts `customizer` which is invoked to produce the assigned values. If `customizer` returns `undefined`, assignment is handled by the method instead."},"description":"```javascript\nfunction assignInWith(object, sources, customizer) {\n  for (const source of sources) {\n    for (const key in source) {\n      const customizerResult = customizer(object[key], value, key, object, source);\n      object[key] = customizerResult !== undefined ? customizerResult : source[key];\n    }\n  }\n\n  return object;\n}\n```\n\nIt's very likely that you don't actually need this function. The only way this function is different from `_.assignWith()`, is that it'll also copy over non-enumerable inherited fields. But class syntax will automatically make all methods on the prototype chain non-enumerable, which means the `assignInWith()` function won't copy them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n\nPerhaps there's some niche use-cases for this sort of function that arise from fairly abnormal and tricky uses of the JavaScript prototype, but, for day-to-day development, it's best to stay away from this function. If you just want to copy data over from one object to another with a customizer function (and don't need to worry about inherited fields), please look at the JavaScript equivalent to `_.assignWith()` instead.\n","src":null,"test":""},{"name":"assignWith","manifest":{"fnSignature":"_.assignWith(object, ...sources, customizer?)","lodashLink":"https://lodash.com/docs/4.17.15#assignWith","summary":"This method is like `_.assign` except that it accepts `customizer` which is invoked to produce the assigned values. If `customizer` returns `undefined`, assignment is handled by the method instead."},"description":"A complete implementation would look like this:\n\n```javascript\nfunction assignWith(object, sources, customizer) {\n  for (const source of sources) {\n    for (const [key, value] of Object.entries(source)) {\n      const customizerResult = customizer(object[key], value, key, object, source);\n      object[key] = customizerResult !== undefined ? customizerResult : source[key];\n    }\n  }\n\n  return object;\n}\n```\n\nHowever, it's possible that all you really need to do is map over your source objects before merging them, like this:\n\n```javascript\n// Merge your sources together, then map over each entry, updating them as you map over them.\nconst updatedEntries = Object.entries({ ...source1, ...source2, ...source3 })\n  .map(([key, value]) => [key, ...operate on `value` however you want...]);\n\n// Construct a new object from the mapped entries\nconst updatedSource = Object.fromEntries(updatedEntries);\n\n// If needed, assign the updated entries to `object`, mutating it so it contains this new data.\nObject.assign(object, updatedSource);\n```\n","src":null,"test":""},{"name":"at","manifest":{"fnSignature":"_.at(object, paths?)","lodashLink":"https://lodash.com/docs/4.17.15#at","summary":"Creates an array of values corresponding to `paths` of `object`."},"description":"We will use a plain JavaScript implementation of `_.get()` to solve this problem.\n\n```javascript\nfunction get(object, path, defaultValue = undefined) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  if (path.length === 0) {\n    return object;\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return defaultValue;\n  }\n\n  return get(object[head], tail, defaultValue);\n}\n\n// Maps over the paths array, fetching each field value from `object` corresponding to that path.\npaths.map(path => get(object, path));\n```\n\nOne of the primary reasons Lodash's `_.get()` function was commonly used, was as a way to easily access a nested property without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined, and the [nullish coalescing operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing) to provide a default value.\n\nFor example, these two are the same:\n\n```javascript\n_.get(obj, 'a.b', null);\n\nobj?.a?.b ?? null;\n```\n\nNote that the support for string paths in the above `get()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.get()` and `_.at()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"create","manifest":{"fnSignature":"_.create(prototype, properties?)","lodashLink":"https://lodash.com/docs/4.17.15#create","summary":"Creates an object that inherits from the `prototype` object. If a `properties` object is given, its own enumerable string keyed properties are assigned to the created object."},"description":"If you just need to create an object that inherits from another object:\n\n```javascript\nObject.create(prototype)\n```\n\nIf you also need to assign some fields to the newly created object, either of these options work:\n\n```javascript\nObject.assign(Object.create(prototype), properties);\n\nObject.create(prototype, Object.getOwnPropertyDescriptors(properties));\n```\n","src":null,"test":""},{"name":"defaults","manifest":{"fnSignature":"_.defaults(object, ...sources)","lodashLink":"https://lodash.com/docs/4.17.15#defaults","summary":"Assigns own and inherited enumerable string keyed properties of source objects to the destination object for all destination properties that resolve to `undefined`. Source objects are applied from left to right. Once a property is set, additional values of the same property are ignored."},"description":"There's a handful of different patterns that can be used when you need to apply default values to your object. Each of these methods will handle `null`, `undefined`, and absent properties differently.\n\n1. Destructuring with defaults\n\nDefaults will be applied if the properties on `object` are absent or set to `undefined`.\n\n```javascript\nfunction addDefaultValues(object) {\n  const {\n    prop1 = 'default 1',\n    prop2 = 'default 2',\n    prop3 = 'default 3',\n  } = object;\n\n  return { prop1, prop2, prop3 };\n}\n```\n\n2. Using the nullish coalescing operator (`??`)\n\nDefaults will be applied if the properties on `object` are absent, set to `undefined`, or set to `null`.\n\n```javascript\nconst result = {\n  prop1: object.prop1 ?? 'default 1',\n  prop2: object.prop2 ?? 'default 2',\n  prop3: object.prop3 ?? 'default 3',\n};\n```\n\n3. Spreading a defaults object with your target object\n\nDefaults will only be applied if the properties on `object` are absent.\n\n```javascript\nconst defaults = {\n  prop1: 'default 1',\n  prop2: 'default 2',\n  prop3: 'default 3',\n};\n\n// Note that if you happen to have multiple objects with defaults, you can easily\n// spread them all together here.\nconst result = { ...defaults, ...object };\n```\n\nIf you already have an object containing default values, option 3 fits the nicest, but it can't be used as-is if you need the defaults to be applied against `undefined` and/or `null` fields. This can be handled by removing `undefined`/`null` from `object` before applying default values, as follows:\n\n```javascript\n// The behavior of this function can easily be tweaked if, for example,\n// you also wish to remove `null` fields from an object.\nfunction removeUndefinedProps(object) {\n  const filteredEntries = Object.entries(object)\n    .filter(([key, value]) => value !== undefined);\n\n  return Object.fromEntries(filteredEntries);\n}\n\nconst result = { ...defaults, ...removeUndefinedProps(object) };\n```\n\nNote that the Lodash implementation would pick both own and inherited properties from the default objects, while this third pattern of spreading objects does not. In practice, this shouldn't matter much because 1. Generally, your default objects won't have inherited fields, and 2. Even if they did, if those inherited fields are set up \"properly\" (i.e. the same way the class syntax automatically does for you), they should also be non-enumerable, and Lodash's `_.defaults()` does not pick non-enumerable fields from the defaults object.\n","src":null,"test":""},{"name":"defaultsDeep","manifest":{"fnSignature":"_.defaultsDeep(object, ...sources)","lodashLink":"https://lodash.com/docs/4.17.15#defaultsDeep","summary":"This method is like `_.defaults` except that it recursively assigns default properties."},"description":"There's a handful of different patterns that can be used when you need to apply default values deeply to your object. Each of these methods will handle `null`, `undefined`, and absent properties differently.\n\n1. Destructuring with defaults\n\nDefaults will be applied if the properties on `object` are absent or set to `undefined`.\n\n```javascript\nfunction addDefaultValues(object) {\n  const {\n    prop1 = 'default 1',\n    subObj = {\n      prop2 = 'default 2',\n      prop3 = 'default 3',\n    } = {},\n  } = object;\n\n  return { prop1, subObj: { prop2, prop3 } };\n}\n```\n\n2. Using the nullish coalescing operator (`??`)\n\nDefaults will be applied if the properties on `object` are absent, set to `undefined`, or set to `null`.\n\n```javascript\nconst result = {\n  prop1: object.prop1 ?? 'default 1',\n  subObj: {\n    prop2: object.subObj?.prop2 ?? 'default 2',\n    prop3: object.subObj?.prop3 ?? 'default 3',\n  },\n};\n```\n\n3. Spreading a defaults object with your target object\n\nDefaults will only be applied if the properties on `object` are absent.\n\n```javascript\nconst defaults = {\n  prop1: 'default 1',\n};\n\nconst subObjDefault = {\n  prop2: 'default 2',\n  prop3: 'default 3',\n};\n\nconst result = {\n  ...defaults,\n  ...object,\n  subObj: {\n    ...subObjDefaults,\n    ...object.subObj ?? {},\n  },\n};\n```\n\nIf you already have an object containing default values, option 3 fits the nicest, but it can't be used as-is if you need the defaults to be applied against `undefined` and/or `null` fields. This can be handled by removing `undefined`/`null` from `object` before applying default values, as follows:\n\n```javascript\n// The behavior of this function can easily be tweaked if, for example,\n// you also wish to remove `null` fields from an object.\nfunction removeUndefinedProps(object) {\n  const filteredEntries = Object.entries(object)\n    .filter(([key, value]) => value !== undefined);\n\n  return Object.fromEntries(filteredEntries);\n}\n\nconst result = {\n  ...defaults,\n  ...removeUndefinedProps(object),\n  subObj: {\n    ...subObjDefaults,\n    ...removeUndefinedProps(object.subObj ?? {}),\n  },\n};\n```\n\nFinally, if you don't feel any of these patterns will fit your use-case very well, you can use the following helper function, which mimics `_.defaultsDeep()`.\n\n```javascript\nconst isObject = value => ['object', 'function'].includes(typeof value) && value !== null;\n\n// NOTE: This mutates `object`.\nfunction defaultsDeep(object, ...sources) {\n  for (const source of sources) {\n    for (const [key, value] of Object.entries(source)) {\n      if (object[key] === undefined) {\n        object[key] = value;\n      } else if (isObject(value) && isObject(source[key])) {\n        defaultsDeep(object[key], value);\n      }\n    }\n  }\n\n  return object;\n}\n```\n\nNote that the Lodash implementation would pick both own and inherited properties from the default objects, while this third pattern of spreading objects does not. In practice, this shouldn't matter much because 1. Generally, your default objects won't have inherited fields, and 2. Even if they did, if those inherited fields are set up \"properly\" (i.e. the same way the class syntax automatically does for you), they should also be non-enumerable, and Lodash's `_.defaultsDeep()` does not pick non-enumerable fields from the defaults object.\n","src":null,"test":""},{"name":"findKey","manifest":{"fnSignature":"_.findKey(object, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#findKey","summary":"This method is like `_.find` except that it returns the key of the first element predicate returns truthy for instead of the element itself."},"description":"```javascript\nObject.entries(object)\n  .find(([key, value]) => predicate(value))?.[0];\n```\n","src":null,"test":""},{"name":"findLastKey","manifest":{"fnSignature":"_.findLastKey(object, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#findLastKey","summary":"This method is like `_.findKey` except that it iterates over elements of a collection in the opposite order."},"description":"```javascript\nObject.entries(object)\n  .findLast(([key, value]) => predicate(value))?.[0];\n```\n\nPlease don't actually use this solution.\n\nObjects are supposed to be treated as unordered collections. Yes, it's technically true that the JavaScript committee has standardized a stable ordering for object properties, but they only did this so your JavaScript programs will run exactly the same, no matter which engine they run on. They don't provide any tools to modify the ordering of an object (like, \"move this property, so that it's second in iteration order, instead of last\"), and the lack of these types of tools exist for a reason - they don't want you to write code that relies on the order, nor does anyone trying to read and understand your code. Conceptually, objects are supposed to be unordered, please treat them that way. Because of this, there's no reason to iterate over an object from the end to the beginning, you should be able to just use `_.findKey()` instead of `_.findLastKey()`.","src":null,"test":""},{"name":"forIn","manifest":{"fnSignature":"_.forIn(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#forIn","summary":"Iterates over own and inherited enumerable string keyed properties of an object and invokes iteratee for each property. Iteratee functions may exit iteration early by explicitly returning `false`."},"description":"```javascript\nfor (const key in object) {\n  const value = object[key];\n  ...\n}\n```\n\nIt's very likely that you don't actually want this behavior. The only way this solution different from the solutions for `_.forOwn()`, is that it'll also iterate over non-enumerable inherited properties. But...\n1. Class syntax will automatically make all methods on the prototype chain non-enumerable, which means the for-in loop won't iterate over them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n2. It's long been considered a good practice whenever using a for-in loop, to also check if the property you're iterating over is non-inherited, by nesting an `if (Object.prototype.hasOwnProperty.call(object, key)) { ... }` check into your loop. This was done, among other reasons, to guard against the case where someone may have improperly mutated `Object.prototype`, and added an enumerable property to it. This `for-in` + `is-own` check isn't seen as much in the wild anymore, because the language has since come out with a better way to iterate over non-inherited keys, which is discussed in the `_.forOwn()` entry.\n\nFor day-to-day development, it's best to stay away from the raw for-in loop. If you just want to iterate over object keys, and don't want to worry about inherited fields, look at `_.forOwn()` instead.\n","src":null,"test":""},{"name":"forInRight","manifest":{"fnSignature":"_.forInRight(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#forInRight","summary":"This method is like `_.forIn` except that it iterates over properties of `object` in the opposite order."},"description":"```javascript\nconst keys = [];\nfor (const key in object) {\n  keys.push(key);\n}\nkeys.reverse();\n\nfor (const key of keys) {\n  const value = object[key];\n  ...\n}\n```\n\nPlease don't actually use this solution.\n\nObjects are supposed to be treated as unordered collections. Yes, it's technically true that the JavaScript committee has standardized a stable ordering for object properties, but they only did this so your JavaScript programs will run exactly the same, no matter which engine they run on. They don't provide any tools to modify the ordering of an object (like, \"move this property, so that it's second in iteration order, instead of last\"), and the lack of these types of tools exist for a reason - they don't _want_ you to write code that relies on the order, nor does anyone trying to read and understand your code. Conceptually, objects are supposed to be unordered, please treat them that way. Because of this, there's no reason to iterate over an object from the end to the beginning, you should be able to just use `_.forIn()` instead of `_.forInRight()`.\n\nExcept, both `_.forIn()` and `_.forInRight()` have another problem.\n\nIt's very likely that you don't actually want to iterate over the enumerable, inherited properties, because:\n1. Class syntax will automatically make all methods on the prototype chain non-enumerable, which means the for-in loop won't iterate over them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n2. It's long been considered a good practice whenever using a for-in loop, to also check if the property you're iterating over is non-inherited, by nesting an `if (Object.prototype.hasOwnProperty.call(object, key)) { ... }` check into your loop. This was done, among other reasons, to guard against the case where someone may have improperly mutated `Object.prototype`, and added an enumerable property to it. This `for-in` + `is-own` check isn't seen as much in the wild anymore, because the language has since come out with a better way to iterate over non-inherited keys, which is discussed in the `_.forOwn()` entry.\n\nIf you just want to iterate over object keys, and don't want to worry about inherited properties or the ordering of keys, look at `_.forOwn()` instead.\n","src":null,"test":""},{"name":"forOwn","manifest":{"fnSignature":"_.forOwn(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#forOwn","summary":"Iterates over own enumerable string keyed properties of an object and invokes `iteratee` for each property. Iteratee functions may exit iteration early by explicitly returning `false`."},"description":"If you wish to iterate over both keys and values:\n\n```javascript\nfor (const [key, value] of Object.entries(object)) {\n  ...\n}\n```\n\nIf, instead, you just want values, you can use `Object.values(object)`.\n\n```javascript\nfor (const value of Object.values(object)) {\n  ...\n}\n```\n\nAnd if you just want keys, you can use `Object.keys(object)`.\n\n```javascript\nfor (const key of Object.keys(object)) {\n  ...\n}\n```\n\nYou'll find the `.forEach()` method to be very popular in the JavaScript community as well.\n\n```javascript\nObject.entries(object).forEach(([key, value]) => {\n\n});\n```\n\nUsing `.forEach()` will certainly feel closer to Lodash's `_.forOwn()`, but it does have a number of drawbacks:\n* You can't use `break` in a `.forEach()`. (You can mimic `continue` via an early return).\n* `.forEach()` doesn't provide proper support for `await`. If you need to run tasks in parallel, use `await Promise.all(items.map(...))`, and if you want to run tasks in a series, you can just use a for-of loop.\n* `.forEach()` doesn't work with generators. You can't `yield` from inside a `.forEach()`.\n* `.forEach()` only works with arrays, and any other collection that happens to implement the `.forEach()` function. `for-of` works with all iterators, including strings, the legacy `arguments` object, your own iterators made via generator functions, etc.\n* `for-of` is newer than `.forEach()` and was intended to be the better version of `.forEach()`. It's a shame it's still struggling to gain traction.\n","src":null,"test":""},{"name":"forOwnRight","manifest":{"fnSignature":"_.forOwnRight(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#forOwnRight","summary":"This method is like `_.forOwn` except that it iterates over properties of `object` in the opposite order."},"description":"```javascript\nfor (const [key, value] of Object.entries(object).reverse()) {\n  ...\n}\n```\n\nPlease don't actually use this solution.\n\nObjects are supposed to be treated as unordered collections. Yes, it's technically true that the JavaScript committee has standardized a stable ordering for object properties, but they only did this so your JavaScript programs will run exactly the same, no matter which engine they run on. They don't provide any tools to modify the ordering of an object (like, \"move this property, so that it's second in iteration order, instead of last\"), and the lack of these types of tools exist for a reason - they don't _want_ you to write code that relies on the order, nor does anyone trying to read and understand your code. Conceptually, objects are supposed to be unordered, please treat them that way. Because of this, there's no reason to iterate over an object from the end to the beginning, you should be able to just use `_.forOwn()` instead of `_.forOwnRight()`.\n","src":null,"test":""},{"name":"functions","manifest":{"fnSignature":"_.functions(object)","lodashLink":"https://lodash.com/docs/4.17.15#functions","summary":"Creates an array of function property names from own enumerable properties of `object`."},"description":"```javascript\nfunction functions(object) {\n  const result = [];\n  for (const [key, value] of Object.entries(object)) {\n    if (typeof value === 'function') {\n      result.push(key);\n    }\n  }\n\n  return result;\n}\n```\n","src":null,"test":""},{"name":"functionsIn","manifest":{"fnSignature":"_.functionsIn(object)","lodashLink":"https://lodash.com/docs/4.17.15#functionsIn","summary":"Creates an array of function property names from own and inherited enumerable properties of object."},"description":"```javascript\nfunction functionsIn(object) {\n  const result = [];\n  for (const key in object) {\n    if (typeof object[key] === 'function') {\n      result.push(key);\n    }\n  }\n\n  return result;\n}\n```\n\nIt's very likely that you don't actually need this function. The only way this function is different from `_.functions()`, is that it'll also search for non-enumerable inherited fields. But class syntax will automatically make all methods on the prototype chain non-enumerable, which means the `functionsIn()` function won't look for them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable, i.e. if the methods were attached to the prototype \"properly\", the `functionsIn()` implementation wouldn't be able to find anything on there anyways, since they'd all be marked as non-enumerable.\n\nPerhaps there's some niche use-cases for this sort of function, that arise from using the prototype in abnormal or legacy ways, but, for day-to-day development, it's best to stay away from this function. If you just want to search for non-inherited function names, use `_.functions()` instead. If you need to get all non-enumerable, inherited method names, first double check how you're designing your program to see if, perhaps, there's a better way to approach the problem, and if not, you can use `Object.getOwnPropertyNames()` to get non-inherited, non-enumerable properties in combination with manually walking up the prototype chain to achieve your desired effect.\n","src":null,"test":""},{"name":"get","manifest":{"fnSignature":"_.get(object, path, defaultValue?)","lodashLink":"https://lodash.com/docs/4.17.15#get","summary":"Gets the value at `path` of `object`. If the resolved value is `undefined`, the `defaultValue` is returned in its place."},"description":"```javascript\nfunction get(object, path, defaultValue = undefined) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  if (path.length === 0) {\n    return object;\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return defaultValue;\n  }\n\n  return get(object[head], tail, defaultValue);\n}\n```\n\nOne of the primary reasons Lodash's `_.get()` function was commonly used, was as a way to easily access a nested property without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined, and the [nullish coalescing operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing) to provide a default value.\n\nFor example, these two are effectively the same:\n\n```javascript\n_.get(obj, 'a.b', null);\n\nobj?.a?.b ?? null;\n```\n\nNote that the support for string paths in the above `get()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.get()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"has","manifest":{"fnSignature":"_.has(object, path)","lodashLink":"https://lodash.com/docs/4.17.15#has","summary":"Checks if path is a direct property of object."},"description":"If you have a simple key, then `Object.hasOwn()` can be used to check if it's a non-inherited property.\n\n```javascript\nObject.hasOwn({}, 'toString'); // false\nObject.hasOwn({ toString() { return '{}' } }, 'toString'); // true\n```\n\nIf you have an array of path keys you wish to travel down, or perhaps, a string containing nested property access (like `x.y.z`), use this:\n\n```javascript\nfunction has(object, path) {\n  // Optional nested-property string support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  const [head, ...tail] = path;\n  if (!Object.hasOwn(object, head)) {\n    return false;\n  }\n\n  if (tail.length === 0) {\n    return true;\n  }\n\n  return has(object[head], tail);\n}\n```\n\nNote that the support for nested string paths in the above `has()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.has()` isn't all that different in this regard. If you really need support for nested string paths, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability. Just provide the path you desire as an array instead.\n\nIf you don't have dynamic strings being provided to you, and you don't need to do the \"is-not-inherited\" checks, then you can simply use the `in` operator with \"optional chaining\" (`?.`) to check for the existence of a nested property.\n\n```javascript\n'z' in object?.x?.y;\n```\n","src":null,"test":""},{"name":"hasIn","manifest":{"fnSignature":"_.hasIn(object, path)","lodashLink":"https://lodash.com/docs/4.17.15#hasIn","summary":"Checks if `path` is a direct or inherited property of `object`."},"description":"If you have a simple key, then the `in` operator can be used to check if the property is found in the object.\n\n```javascript\n'x' in { x: 2 }; // true\n'toString' in { x: 2 }; // true - `in` checks for inherited properties as well\n```\n\nIf you have an array of path keys you wish to travel down, or perhaps, a string containing nested property access (like `x.y.z`), use this:\n\n```javascript\nfunction hasIn(object, path) {\n  // Optional nested-property string support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return false;\n  }\n\n  if (tail.length === 0) {\n    return true;\n  }\n\n  return hasIn(object[head], tail);\n}\n```\n\nOne of the primary reasons Lodash's `_.hasIn()` function was commonly used, was as a way to easily check if a nested property existed, without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined.\n\nFor example, these two are the same:\n\n```javascript\n_.hasIn(obj, 'a.b.c');\n\n'c' in obj?.a?.b;\n```\n\nNote that the support for nested string paths in the above `hasIn()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.hasIn()` isn't all that different in this regard. If you really need support for nested string paths, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability. Just provide the path you desire as an array instead.\n","src":null,"test":""},{"name":"invert","manifest":{"fnSignature":"_.invert(object)","lodashLink":"https://lodash.com/docs/4.17.15#invert","summary":"Creates an object composed of the inverted keys and values of object. If object contains duplicate values, subsequent values overwrite property assignments of previous values."},"description":"```javascript\nfunction invert(obj) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    newObj[value] = key;\n  }\n  return newObj;\n}\n```\n","src":null,"test":""},{"name":"invertBy","manifest":{"fnSignature":"_.invertBy(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#invertBy","summary":"This method is like `_.invert` except that the inverted object is generated from the results of running each element of `object` thru `iteratee`. The corresponding inverted value of each inverted key is an array of keys responsible for generating the inverted value."},"description":"```javascript\nfunction invertBy(obj, iteratee=x=>x) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const newValue = iteratee(value);\n    newObj[newValue] ??= [];\n    newObj[newValue].push(key);\n  }\n  return newObj;\n}\n```\n","src":null,"test":""},{"name":"invoke","manifest":{"fnSignature":"_.invoke(object, path, ...args)","lodashLink":"https://lodash.com/docs/4.17.15#invoke","summary":"Invokes the method at `path` of `object`."},"description":"```javascript\nfunction invoke(object, path, ...args) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return undefined;\n  }\n\n  if (tail.length === 0) {\n    return object[head](...args);\n  }\n\n  return invoke(object[head], tail, ...args);\n}\n```\n\nBe aware that, like Lodash's `_.invoke()`, the above implementation doesn't do anything to guard against prototype look-ups, for example, `invoke({}, 'toString')` will work, and will return the string `'[object Object]'`. To guard against this, use `if (!(Object.hasOwn(head, object)))` instead of `if(!(head in object))`.\n\nOne of the primary reasons Lodash's `_.invoke()` function was commonly used, was as a way to easily invoke a function nested in an object without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined.\n\nFor example, these two are effectively the same:\n\n```javascript\n_.invoke(obj, 'subObj.fn', 2, 4);\n\nobj?.subObj?.fn?.(2, 4);\n```\n\nNote that the support for string paths in the above `invoke()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.invoke()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"keys","manifest":{"fnSignature":"_.keys(object)","lodashLink":"https://lodash.com/docs/4.17.15#keys","summary":"Creates an array of the own enumerable property names of `object`."},"description":"```javascript\nObject.keys(object);\n```\n","src":null,"test":""},{"name":"keysIn","manifest":{"fnSignature":"_.keysIn(object)","lodashLink":"https://lodash.com/docs/4.17.15#keysIn","summary":"Creates an array of the own and inherited enumerable property names of `object`."},"description":"```javascript\nfunction keysIn(object) {\n  const keys = [];\n  for (let key in object) {\n    keys.push(key);\n  }\n\n  return keys;\n}\n```\n\nIt's very likely that you don't actually need this function. The only way this function is different from `_.keys()` (or `Object.keys()`), is that it'll also grab over non-enumerable inherited keys. But class syntax will automatically make all methods on the prototype chain non-enumerable, which means the `keysIn()` function won't consider those inherited methods anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n\nPerhaps there's some niche use-cases for this sort of function, that arise from using the prototype in abnormal or legacy ways, but, for day-to-day development, it's best to stay away from this function. If you just want to get the non-inherited keys from an object, use `Object.keys(object)` instead.\n","src":null,"test":""},{"name":"mapKeys","manifest":{"fnSignature":"_.mapKeys(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#mapKeys","summary":"The opposite of `_.mapValues`; this method creates an object with the same values as `object` and keys generated by running each own enumerable string keyed property of `object` thru `iteratee`."},"description":"```javascript\nfunction mapKeys(obj, iteratee) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const newKey = iteratee(value, key, obj);\n    newObj[newKey] = value;\n  }\n\n  return newObj;\n}\n```\n","src":null,"test":""},{"name":"mapValues","manifest":{"fnSignature":"_.mapValues(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#mapValues","summary":"Creates an object with the same keys as `object` and values generated by running each own enumerable string keyed property of `object` thru `iteratee`."},"description":"```javascript\nfunction mapValues(obj, iteratee) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    newObj[key] = iteratee(value, key, obj);\n  }\n\n  return newObj;\n}\n```\n","src":null,"test":""},{"name":"merge","manifest":{"fnSignature":"_.merge(object, ...sources)","lodashLink":"https://lodash.com/docs/4.17.15#merge","summary":"This method is like `_.assign` except that it recursively merges own and inherited enumerable string keyed properties of source objects into the destination object. Source properties that resolve to `undefined` are skipped if a destination value exists. Source objects are applied from left to right. Subsequent sources overwrite property assignments of previous sources."},"description":"If you know the shape of the objects you're wishing to merge, you can just use the spread syntax, like this:\n\n```javascript\nconst result = {\n  ...object1,\n  ...object2,\n  subObject: {\n    ...object1.subObject,\n    ...object2.subObject,\n  },\n};\n```\n\nOtherwise, the following `merge()` function can be used to roughly mirror Lodash's `_.merge()`.\n\n```javascript\nconst isObject = value => ['object', 'function'].includes(typeof value) && value !== null;\n\n// A \"plain\" object is an object who's a direct instance of Object\n// (or, who has a null prototype).\nconst isPlainObject = value => {\n  if (!isObject(value)) return false;\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n};\n\n// NOTE: This mutates `object`.\n// It also may mutate anything that gets attached to `object` during the merge.\nfunction merge(object, ...sources) {\n  for (const source of sources) {\n    for (const [key, value] of Object.entries(source)) {\n      if (value === undefined) {\n        continue;\n      }\n\n      // These checks are a week attempt at mimicking the various edge-case behaviors\n      // that Lodash's `_.merge()` exhibits. Feel free to simplify and\n      // remove checks that you don't need.\n      if (!isPlainObject(value) && !Array.isArray(value)) {\n        object[key] = value;\n      } else if (Array.isArray(value) && !Array.isArray(object[key])) {\n        object[key] = value;\n      } else if (!isObject(object[key])) {\n        object[key] = value;\n      } else {\n        merge(object[key], value)\n      }\n    }\n  }\n\n  return object;\n}\n```\n\nThe Lodash implementation would pick both own and inherited properties from the default objects, while this implementation does not. In practice, this shouldn't matter much because 1. Generally, your default objects won't have inherited fields, and 2. Even if they did, if those inherited fields are set up \"properly\" (i.e. the same way the class syntax automatically does for you), they should also be non-enumerable, and Lodash's `_.merge()` does not pick non-enumerable fields from the defaults object.\n\nThe implementation above also does not support circular references. There's a handful of different ways you could support circular references depending on your needs:\n* Don't bother checking for them at all (what the above implementation does)\n* Check for them on the source objects and throw an error if you encounter one (another good option)\n* When traversing a `source` object, stop before using a source node that you've seen before (what `lodash` was probably trying to do).\n* When traversing a `source` object, if you encounter a node in `source` that you have seen before, merge its immediate properties but do not recurse into it anymore (what `lodash` does).\n* When traversing a `source` object, stop if you find yourself trying to merge a source node to the same target node a second time. (This is arguably the most correct algorithm)\n\nIn practice, it's not common to need support for circular references, so you will probably be fine just leaving out support or throwing an error if you detect a circular reference.\n\nIf all you want to do is deeply merge some plain objects, and you don't need to worry about odd scenarios, like \"what happens when I merge an array with a number\", or, \"how does a Map instance get merged with a plain object\", then an implementation like this should be sufficient.\n\n```javascript\nconst isObject = value => ['object', 'function'].includes(typeof value) && value !== null;\n\n// NOTE: This mutates `object`.\n// It also may mutate anything that gets attached to `object` during the merge.\nfunction merge(object, ...sources) {\n  if (!isObject(object)) {\n    throw new Error(`Expected ${object} to be an object.`)\n  }\n\n  for (const source of sources) {\n    for (const [key, value] of Object.entries(source)) {\n      if (value === undefined) {\n        continue;\n      }\n\n      if (object[key] === undefined) {\n        object[key] = value;\n      } else {\n        merge(object[key], value)\n      }\n    }\n  }\n\n  return object;\n}\n```\n","src":null,"test":""},{"name":"mergeWith","manifest":{"fnSignature":"_.mergeWith(object, ...sources, customizer)","lodashLink":"https://lodash.com/docs/4.17.15#mergeWith","summary":"This method is like `_.merge` except that it accepts `customizer` which is invoked to produce the merged values of the destination and source properties. If `customizer` returns `undefined`, merging is handled by the method instead."},"description":"```javascript\nconst isObject = value => ['object', 'function'].includes(typeof value) && value !== null;\n\n// A \"plain\" object is an object who's a direct instance of Object\n// (or, who has a null prototype).\nconst isPlainObject = value => {\n  if (!isObject(value)) return false;\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n};\n\n// NOTE: This mutates `object`.\n// It also may mutate anything that gets attached to `object` during the merge.\nfunction mergeWith(object, sources, customizer) {\n  for (const source of sources) {\n    for (const [key, value] of Object.entries(source)) {\n      const mergedValue = customizer(object[key], value, key, object, source);\n      if (mergedValue !== undefined) {\n        object[key] = mergedValue;\n        continue;\n      }\n      // Otherwise, fall back to default behavior\n\n      if (value === undefined) {\n        continue;\n      }\n\n      // These checks are a week attempt at mimicking the various edge-case behaviors\n      // that Lodash's `_.merge()` exhibits. Feel free to simplify and\n      // remove checks that you don't need.\n      if (!isPlainObject(value) && !Array.isArray(value)) {\n        object[key] = value;\n      } else if (Array.isArray(value) && !Array.isArray(object[key])) {\n        object[key] = value;\n      } else if (!isObject(object[key])) {\n        object[key] = value;\n      } else {\n        mergeWith(object[key], value, customizer)\n      }\n    }\n  }\n\n  return object;\n}\n```\n\nLodash implementation will pick both own and inherited properties from the default objects, while this implementation does not. In practice, this shouldn't matter much because 1. Generally, your default objects won't have inherited fields, and 2. Even if they did, if those inherited fields are set up \"properly\" (i.e. the same way the class syntax automatically does for you), they should also be non-enumerable, and Lodash's `_.merge()` does not pick non-enumerable fields from the defaults object.\n\nIn Lodash, the customizer function would be called with a sixth \"stack\" argument. Some probing shows that it's an instance of an internal \"Stack\" class that provides some methods which, presumably, can be used to gather information about the objects you're merging. Due to the fact that this seems to be a rather complex feature that's entirely undocumented, it'll be assumed that the vast majority of users do not use this parameter, and so it's functionality won't be recreated here either.\n\nThe implementation above also does not support circular references. There's a handful of different ways you could support circular references depending on your needs:\n* Don't bother checking for them at all (what the above implementation does)\n* Check for them on the source objects and throw an error if you encounter one (another good option)\n* When traversing a `source` object, stop before using a source node that you've seen before (what `lodash` was probably trying to do).\n* When traversing a `source` object, if you encounter a node in `source` that you have seen before, merge its immediate properties but do not recurse into it anymore (what `lodash` does).\n* When traversing a `source` object, stop if you find yourself trying to merge a source node to the same target node a second time. (This is arguably the most correct algorithm)\n\nIn practice, it's not common to need support for circular references, so you will probably be fine just leaving out support or throwing an error if you detect a circular reference.","src":null,"test":""},{"name":"omit","manifest":{"fnSignature":"_.omit(object, ...paths)","lodashLink":"https://lodash.com/docs/4.17.15#omit","summary":"This method is like `_.merge` except that it accepts `customizer` which is invoked to produce the merged values of the destination and source properties. If `customizer` returns `undefined`, merging is handled by the method instead."},"description":"If the properties you wish to omit are known in advance, you can use destructuring to omit them (possibly putting this in a helper function, to avoid polluting your scope with unnecessary variables).\n\n```javascript\n// `partialObject` will contain everything that's in `object`,\n// except, `propA` and `propB` will be omitted.\nconst { propA, propB, ...partialObject } = object;\n```\n\nIf you need to also omit nested properties, a similar pattern can still be followed.\n\n```javascript\n// omit properties from `object`\nconst { propA, propB, nestedObj, ...partialObject } = object;\n\n// omit properties from `object.nestedObj`\nconst { nestedPropA, ...partialNestedObject } = nestedObj;\n\n// Combine the two partial objects, to build the final result.\nconst result = { ...partialObject, partialNestedObject };\n```\n\nIf you don't know the keys you need to remove in advance, the following helper function can be utilized.\n\n```javascript\nfunction omit(object, keys_) {\n  const keys = new Set(keys_);\n  const newObject = {};\n  for (const [key, value] of Object.entries(object)) {\n    if (!keys.has(key)) {\n      newObject[key] = value;\n    }\n  }\n\n  return newObject;\n}\n```\n\nThere is an early [Object.omit() proposal](https://github.com/tc39/proposal-object-pick-or-omit), which, if implemented, would provide functionality similar to the above helper function.\n\nIf you need a version of the omit function that can omit nested properties, you can use this:\n\n```javascript\nconst isObject = value => ['object', 'function'].includes(typeof value) && value !== null;\n\nfunction omit(object, keys) {\n  const newObject = Array.isArray(object) ? [ ...object ] : { ...object };\n\n  for (const key of keys) {\n    let keyPath;\n    if (typeof key === 'string') {\n      // Optional string-path support.\n      // You can remove this key.split() stuff, and simply use `keyPath = [key];`\n      // if you don't need it.\n      keyPath = key.split(/[.\\[\\]\\\"]+/).filter(x => x);\n    } else if (Array.isArray(key)) {\n      keyPath = key;\n    } else {\n      throw new Error(`Received a key ${key}, which is of an invalid type.`);\n    }\n\n    const [head, ...tail] = keyPath;\n    if (tail.length === 0) {\n      delete newObject[key];\n    } else if (isObject(newObject[head]) || Array.isArray(newObject[head])) {\n      newObject[head] = omit(newObject[head], [tail]);\n    }\n  }\n\n  return newObject;\n}\n```\n\nIf you're only passing in a handful of keys at a time, the above implementation should work just fine, but if you think your keys array may become fairly large, you may need to do some work to optimize the above implementation a bit.\n\nNote that the support for string paths (e.g. keys like `key.nestedKey`) in the above `omit()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.omit()` isn't all that different in this regard. If you really need support for string-path inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability.\n\nNote that none of these implementations will actually copy non-enumerable properties from the prototype chain like Lodash's `_.omit()`. It's very likely that you don't actually want this kind of behavior anyways. Generally, all properties found on the prototype chain should be marked as enumerable (this is the default for class syntax) - this is standard practice, and there's really no reason to create a prototype with non-enumerable properties, with the possible exception of dealing with classes that were created before the class syntax came out, where the authors didn't want to put in the work of manually marking each method on the prototype as non-enumerable (it wasn't a common thing to do back in the day, even if it would have technically been more proper).\n","src":null,"test":""},{"name":"omitBy","manifest":{"fnSignature":"_.omitBy(object, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#omitBy","summary":"The opposite of `_.pickBy`; this method creates an object composed of the own and inherited enumerable string keyed properties of `object` that `predicate` doesn't return truthy for."},"description":"```javascript\nfunction omitBy(object, predicate) {\n  const newObject = {};\n  for (const [key, value] of Object.entries(object)) {\n    if (!predicate(value, key)) {\n      newObject[key] = value;\n    }\n  }\n\n  return newObject;\n}\n```\n\n`_.omitBy(object, x => <condition>)` is exactly the same as `_.pickBy(object, x => !<condition>)`. This means, you only really need one of these helper functions, not both.\n\nThere is also an early [Object.omit() proposal](https://github.com/tc39/proposal-object-pick-or-omit), which, if implemented, would provide functionality similar to the above helper function.\n\nNote that this implementation will not actually copy non-enumerable properties from the prototype chain like Lodash's `_.omitBy()`. It's very likely that you don't actually want this kind of behavior anyways. Generally, all properties found on the prototype chain should be marked as enumerable (this is the default for class syntax) - this is standard practice, and there's really no reason to create a prototype with non-enumerable properties, with the possible exception of dealing with classes that were created before the class syntax came out, where the authors didn't want to put in the work of manually marking each method on the prototype as non-enumerable (it wasn't a common thing to do back in the day, even if it would have technically been more proper).\n","src":null,"test":""},{"name":"pick","manifest":{"fnSignature":"_.pick(object, ...paths)","lodashLink":"https://lodash.com/docs/4.17.15#pick","summary":"Creates an object composed of the picked `object` properties."},"description":"If the properties you wish to pick are known in advance, you can use destructuring to pick them (possibly putting this in a helper function, to avoid polluting your scope with unnecessary variables).\n\n```javascript\nconst { propA, propB } = object;\nconst newObject = { propA, propB };\n```\n\nIf you need to also omit nested properties, a similar pattern can still be followed.\n\n```javascript\n// omit properties from `object`\nconst { propA, propB, nestedObj, ...partialObject } = object;\n\n// omit properties from `object.nestedObj`\nconst { nestedPropA, ...partialNestedObject } = nestedObj;\n\n// Combine the two partial objects, to build the final result.\nconst result = { ...partialObject, partialNestedObject };\n```\n\nIf you don't know the keys you need to pick in advance, the following helper function can be utilized.\n\n```javascript\nfunction pick(object, keys) {\n  const newObject = {};\n  for (const key of keys) {\n    if (key in object) {\n      if (key in object) {\n        newObject[key] = object[key];\n      }\n    }\n  }\n\n  return newObject;\n}\n```\n\nThere is an early [Object.pick() proposal](https://github.com/tc39/proposal-object-pick-or-omit), which, if implemented, would provide functionality similar to the above helper function.\n\nIf you need a version of the pick function that can pick nested properties, you can use this:\n\n```javascript\nconst isObject = value => ['object', 'function'].includes(typeof value) && value !== null;\n\nfunction pick(object, keys) {\n  if (object == null) {\n    return {};\n  }\n  const newObject = {};\n\n  for (const key of keys) {\n    let keyPath;\n    if (typeof key === 'string') {\n      // Optional string-path support.\n      // You can remove this key.split() stuff, and simply use `keyPath = [key];`\n      // if you don't need it.\n      keyPath = key.split(/[.\\[\\]\\\"]+/).filter(x => x);\n    } else if (Array.isArray(key)) {\n      keyPath = key;\n    } else {\n      throw new Error(`Received a key ${key}, which is of an invalid type.`);\n    }\n\n    const [head, ...tail] = keyPath;\n    if (!(head in object)) {\n      continue;\n    } else if (tail.length === 0) {\n      newObject[key] = object[key];\n    } else if (isObject(object[head]) || Array.isArray(object[head])) {\n      newObject[head] = {\n        ...newObject[head] ?? {},\n        ...pick(object[head], [tail])\n      };\n    }\n  }\n\n  return newObject;\n}\n```\n\nIf you're only passing in a handful of keys at a time, the above implementation should work just fine, but if you think your keys array may become fairly large, you may need to do some work to optimize the above implementation a bit.\n\nNote that the support for string paths (e.g. keys like `key.nestedKey`) in the above `pick()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.pick()` isn't all that different in this regard. If you really need support for string-path inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability.\n\nIn all of these implementations, you'll be able to pick own properties and inherited properties. This can lead to issues if you accept arbitrary untrusted user input in your keys array. For example, even though the object passed into `pick({}, [untrustedUserInput])` is empty, you can still pick inherited methods off of it, e.g. if untrustedUserInput is set to `'toString'`, you'd pick the `'toString'` method off of the empty object.","src":null,"test":""},{"name":"pickBy","manifest":{"fnSignature":"_.pickBy(object, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#pickBy","summary":"Creates an object composed of the object properties `predicate` returns truthy for. "},"description":"```javascript\nfunction pickBy(object, predicate) {\n  const newObject = {};\n  for (const [key, value] of Object.entries(object)) {\n    if (predicate(value, key)) {\n      newObject[key] = value;\n    }\n  }\n\n  return newObject;\n}\n```\n\nThere is also an early [Object.pick() proposal](https://github.com/tc39/proposal-object-pick-or-omit), which, if implemented, would provide functionality similar to the above helper function.\n\nNote that this implementation will not actually copy non-enumerable properties from the prototype chain like Lodash's `_.pickBy()`. It's very likely that you don't actually want this kind of behavior anyways. Generally, all properties found on the prototype chain should be marked as enumerable (this is the default for class syntax) - this is standard practice, and there's really no reason to create a prototype with non-enumerable properties, with the possible exception of dealing with classes that were created before the class syntax came out, where the authors didn't want to put in the work of manually marking each method on the prototype as non-enumerable (it wasn't a common thing to do back in the day, even if it would have technically been more proper).\n","src":null,"test":""},{"name":"result","manifest":{"fnSignature":"_.result(object, path, defaultValue?)","lodashLink":"https://lodash.com/docs/4.17.15#result","summary":"This method is like `_.get` except that if the resolved value is a function it's invoked with the `this` binding of its parent object and its result is returned."},"description":"```javascript\nfunction result(object, path, defaultValue = undefined) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return defaultValue;\n  }\n\n  if (tail.length === 0) {\n    return object[head]();\n  }\n\n  return result(object[head], tail, defaultValue);\n}\n```\n\nOne of the primary reasons Lodash's `_.result()` function was commonly used, was as a way to easily invoke a function nested in an object without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined, and the [nullish coalescing operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing) to provide a default value.\n\nFor example, these two are effectively the same:\n\n```javascript\n_.result(obj, 'subObj.fn', 'fallback');\n\nobj?.subObj?.fn?.() ?? 'fallback';\n```\n\nNote that the support for string paths in the above `result()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.result()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"set","manifest":{"fnSignature":"_.set(object, path, value)","lodashLink":"https://lodash.com/docs/4.17.15#set","summary":"Sets the value at `path` of `object`. If a portion of `path` doesn't exist, it's created. Arrays are created for missing index properties while objects are created for all other missing properties."},"description":"```javascript\nfunction set(object, path, value) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str => str[0] === '\"' && str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x => x)\n      .map(x => !isNaN(Number(x)) ? Number(x) : x)\n      .map(x => typeof x === 'string' && isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = value;\n    return object;\n  }\n\n  if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  set(object[head], tail, value);\n  return object;\n}\n```\n\nOne of the primary reasons Lodash's `_.set()` function was commonly used, was as a way to easily update a nested property without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined.\n\nFor example, these two accomplish the same objective:\n\n```javascript\n_.set(obj, 'a.b.c', true);\n\nif (obj?.a?.b) {\n  obj.a.b.c = true;\n}\n```\n\nNote that the support for string paths in the above `set()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.set()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"setWith","manifest":{"fnSignature":"_.setWith(object, path, value, customizer?)","lodashLink":"https://lodash.com/docs/4.17.15#setWith","summary":"This method is like `_.set` except that it accepts `customizer` which is invoked to produce the objects of `path`. If `customizer` returns `undefined` path creation is handled by the method instead."},"description":"```javascript\nfunction setWith(object, path, value, customizer) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str => str[0] === '\"' && str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x => x)\n      .map(x => !isNaN(Number(x)) ? Number(x) : x)\n      .map(x => typeof x === 'string' && isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = value;\n    return object;\n  }\n\n  let pathSegment = customizer(object[head], head, object);\n\n  if (pathSegment !== undefined) {\n    object[head] = pathSegment;\n  } else if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  setWith(object[head], tail, value, customizer);\n  return object;\n}\n```\n\nNote that the support for string paths in the above `setWith()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.setWith()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability, since you can always provide an array of keys to form a path, instead of a dot-separated string.\n","src":null,"test":""},{"name":"toPairs","manifest":{"fnSignature":"_.toPairs(object)","lodashLink":"https://lodash.com/docs/4.17.15#toPairs","summary":"Creates an array of own enumerable string keyed-value pairs for `object` which can be consumed by `_.fromPairs`. If object is a map or set, its entries are returned."},"description":"If you have a normal object, use `Object.entries(object);`.\n\nIf you have a map, use `[...map]`.\n\nAnd, while it's not all that useful, you can get the contents of a set, formatted in pairs the same way Lodash's `_.toPairs()` does it, as follows:\n\n```javascript\n[...set].map(value => [value, value]);\n```\n","src":null,"test":""},{"name":"toPairsIn","manifest":{"fnSignature":"_.toPairsIn(object)","lodashLink":"https://lodash.com/docs/4.17.15#toPairsIn","summary":"Creates an array of own and inherited enumerable string keyed-value pairs for `object` which can be consumed by `_.fromPairs`. If `object` is a map or set, its entries are returned."},"description":"If you have a normal object, the following:\n\n```javascript\nfunction toPairsIn(object) {\n  const pairs = [];\n  for (let key in object) {\n    pairs.push([key, object[key]]);\n  }\n\n  return pairs;\n}\n```\n\nIf you have a map, use `[...map]`.\n\nAnd, while it's not all that useful, you can get the contents of a set, formatted in pairs the same way Lodash's `_.toPairs()` does it, as follows:\n\n```javascript\n[...set].map(value => [value, value]);\n```\n\nIt's very likely that you don't actually need the above `toPairsIn()` function. The only way this function is different from `_.toPairs()` (or `Object.entries()`), is that it'll also operate on non-enumerable inherited fields. But class syntax will automatically make all methods on the prototype chain non-enumerable, which means the `toPairsIn()` function won't operate on them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n\nPerhaps there's some niche use-cases for this sort of function that arise from fairly abnormal and tricky uses of the JavaScript prototype, but, for day-to-day development, it's best to stay away from this function. If you just want to get a list of non-inherited pairs (entries), please look at `_.toPairs()` instead.\n","src":null,"test":""},{"name":"transform","manifest":{"fnSignature":"_.transform(object)","lodashLink":"https://lodash.com/docs/4.17.15#transform","summary":"An alternative to `_.reduce`; this method transforms `object` to a new `accumulator` object which is the result of running each of its own enumerable string keyed properties thru `iteratee`, with each invocation potentially mutating the `accumulator` object. If `accumulator` is not provided, a new object with the same `[[Prototype]]` will be used."},"description":"Using `_.transform()` really isn't any different from using the built-in `array.reduce()` method, except for a couple of minor things.\n\n1. If you're dealing with objects, you need to use `Object.entries(yourObject)` to turn it into an array of tuples first.\n2. With `array.reduce()`, you need to always return the accumulator\n\nWhat this looks like in practice, using an example from Lodash's website.\n\n```javascript\n_.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n  (result[value] || (result[value] = [])).push(key);\n}, {});\n// => { '1': ['a', 'c'], '2': ['b'] }\n\n// Note the use of `Object.entries()` (point 1) here.\nObject.entries({ 'a': 1, 'b': 2, 'c': 1 }).reduce((result, [key, value]) => {\n  (result[value] || (result[value] = [])).push(key);\n  return result; // Note how we return the accumulator (point 2) here.\n}, {});\n```\n\nA simple for loop will work just as well, if that's your preference.\n\n```javascript\nconst result = {};\nfor (const [key, value] of Object.entries({ 'a': 1, 'b': 2, 'c': 1 })) {\n  (result[value] || (result[value] = [])).push(key);\n}\n```","src":null,"test":""},{"name":"unset","manifest":{"fnSignature":"_.unset(object, path)","lodashLink":"https://lodash.com/docs/4.17.15#unset","summary":"Removes the property at `path` of `object`."},"description":"```javascript\nfunction unset(object, path) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str => str[0] === '\"' && str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x => x)\n      .map(x => !isNaN(Number(x)) ? Number(x) : x)\n      .map(x => typeof x === 'string' && isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    delete object[head];\n  } else if (head in object) {\n    unset(object[head], tail);\n  }\n\n  return object;\n}\n```\n\nOne of the primary reasons Lodash's `_.unset()` function was commonly used, was as a way to easily delete a nested property without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined.\n\nFor example, these two are the same:\n\n```javascript\n_.unset(obj, 'a.b');\n\ndelete obj?.a?.b;\n```\n\nNote that the support for string paths in the above `unset()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.unset()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"update","manifest":{"fnSignature":"_.set(object, path, value)","lodashLink":"https://lodash.com/docs/4.17.15#set","summary":"Sets the value at `path` of `object`. If a portion of `path` doesn't exist, it's created. Arrays are created for missing index properties while objects are created for all other missing properties."},"description":"```javascript\nfunction update(object, path, updater) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str => str[0] === '\"' && str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x => x)\n      .map(x => !isNaN(Number(x)) ? Number(x) : x)\n      .map(x => typeof x === 'string' && isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = updater();\n    return object;\n  }\n\n  if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  update(object[head], tail, updater);\n  return object;\n}\n```\n\nOne of the primary reasons Lodash's `_.update()` function was commonly used, was as a way to easily update a nested property without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined.\n\nFor example, these two accomplish the same objective:\n\n```javascript\n_.update(obj, 'a.b.c', () => new Something());\n\nif (obj?.a?.b) {\n  obj.a.b.c = new Something();\n}\n```\n\nNote that the support for string paths in the above `update()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.update()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"updateWith","manifest":{"fnSignature":"_.updateWith(object, path, updater, customizer?)","lodashLink":"https://lodash.com/docs/4.17.15#set","summary":"This method is like `_.update` except that it accepts `customizer` which is invoked to produce the objects of `path`. If `customizer` returns `undefined` path creation is handled by the method instead."},"description":"```javascript\nfunction updateWith(object, path, updater, customizer) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str => str[0] === '\"' && str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x => x)\n      .map(x => !isNaN(Number(x)) ? Number(x) : x)\n      .map(x => typeof x === 'string' && isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = updater();\n    return object;\n  }\n\n  let pathSegment = customizer(object[head], head, object);\n\n  if (pathSegment !== undefined) {\n    object[head] = pathSegment;\n  } else if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  updateWith(object[head], tail, updater, customizer);\n  return object;\n}\n```\n\nNote that the support for string paths in the above `updateWith()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.updateWith()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"values","manifest":{"fnSignature":"_.values(object)","lodashLink":"https://lodash.com/docs/4.17.15#values","summary":"Creates an array of the own enumerable string keyed property values of `object`."},"description":"```javascript\nObject.values(object);\n```\n","src":null,"test":""},{"name":"valuesIn","manifest":{"fnSignature":"_.valuesIn(object)","lodashLink":"https://lodash.com/docs/4.17.15#valuesIn","summary":"Creates an array of the own and inherited enumerable string keyed property values of `object`."},"description":"```javascript\nfunction valuesIn(object) {\n  const values = [];\n  for (let key in object) {\n    values.push(object[key]);\n  }\n\n  return values;\n}\n```\n\nIt's very likely that you don't actually need the above `valuesIn()` function. The only way this function is different from `_.values()` (or `Object.values()`), is that it'll also operate on non-enumerable inherited fields. But class syntax will automatically make all methods on the prototype chain non-enumerable, which means the `valuesIn()` function won't operate on them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n\nPerhaps there's some niche use-cases for this sort of function that arise from fairly abnormal and tricky uses of the JavaScript prototype, but, for day-to-day development, it's best to stay away from this function. If you just want to get an object's non-inherited property values, please look at `_.values()` instead.\n","src":null,"test":""}]},{"categoryHeading":"String","entries":[{"name":"camelCase","manifest":{"fnSignature":"_.camelCase(string)","lodashLink":"https://lodash.com/docs/4.17.15#camelCase","summary":"Converts `string` to camel case."},"description":"```javascript\nfunction camelCase(string) {\n  const capitalize = ([first='', ...rest]) => first.toUpperCase() + rest.join('').toLowerCase();\n  const [firstWord, ...remainingWords] = string.split(' ');\n  return [\n    firstWord.toLowerCase(),\n    ...remainingWords.map(capitalize),\n  ].join('');\n}\n```\n\nThe above generates the word list by simply splitting on space characters. Refer to [the entry for `_.words()`](#!/nolodash/words) for alternative ways to extract words from text (which includes information on dealing with different languages).\n\nRefer to the [`_.capitalize()` entry](#!/nolodash/capitalize) to learn more about the design behind the capitalize function being used.\n\nIf you need to support internationalization, swap `.toUpperCase()`/`.toLowerCase()` with [`.toLocalUpperCase()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleUpperCase)/[`.toLocaleLowerCase()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase), and, if needed, provide the target language as an argument to these functions. This solution isn't perfect - read [this great post for a more nuanced exploration on internationalization and casing](https://stackoverflow.com/a/53930826/7696223).\n\nFor reference, Lodash's algorithm is implemented roughly as follows:\n* [Deburr](#!/nolodash/deburr) the string (which mostly means that accent marks are removed from characters).\n* Removes apostrophes (the ' and ’ characters).\n* Split the string into words using the algorithm that powers [`_.words()`](#!/nolodash/words).\n* Runs the first letter of each word (except the first) through `.toUpperCase()`, and runs the rest of the characters through `.toLowerCase()`.\n","src":null,"test":"describe('camelCase()', () => {\n  function camelCase(string) {\n    const capitalize = ([first = '', ...rest]) => first.toUpperCase() + rest.join('').toLowerCase();\n    const [firstWord, ...remainingWords] = string.split(' ');\n    return [\n      firstWord.toLowerCase(),\n      ...remainingWords.map(capitalize),\n    ].join('');\n  }\n\n  it('converts text into camel case', () => {\n    expect(camelCase('HELLO aWeSoMe world')).toEqual('helloAwesomeWorld');\n  });\n\n  it('handles an empty string', () => {\n    expect(camelCase('')).toEqual('');\n  });\n});\n"},{"name":"capitalize","manifest":{"fnSignature":"_.capitalize(string)","lodashLink":"https://lodash.com/docs/4.17.15#capitalize","summary":"Converts the first character of `string` to upper case and the remaining to lower case."},"description":"```javascript\nfunction capitalize([first='', ...rest]) {\n  return first.toUpperCase() + rest.join('').toLowerCase();\n}\n```\n\nThe above implementation is carefully implemented to rely on the iterator protocol to split the string into separate characters (destructuring syntax uses the iterator protocol under the hood). This is done because iteration will properly split a string into characters while string indexing and slicing can cause you to accidentally split a string in between a character (e.g. `const firstChar = '🚀🚀'[0];` produces an invalid character while `const [firstChar] = '🚀🚀';` will properly retrieve the first character as `🚀`).\n\nIf you need to support internationalization, swap `.toUpperCase()`/`.toLowerCase()` with [`.toLocalUpperCase()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleUpperCase)/[`.toLocaleLowerCase()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase), and, if needed, provide the target language as an argument to these functions. This solution isn't perfect - read [this great post for a more nuanced exploration on internationalization and casing](https://stackoverflow.com/a/53930826/7696223).\n","src":null,"test":"describe('capitalize()', () => {\n  function capitalize([first = '', ...rest]) {\n    return first.toUpperCase() + rest.join('').toLowerCase();\n  }\n\n  it('It converts the first character to upper case and the remaining to lower case', () => {\n    expect(capitalize('a b C')).toEqual('A b c');\n  });\n\n  it('works on empty strings', () => {\n    expect(capitalize('')).toEqual('');\n  });\n\n  // I would have a test case that shows how it can properly uppercase a multi-code-unit character,\n  // but I'm not actually aware of any specific scenarios that would show the different.\n  // Upper casing an entire character vs upper casing the first first part of a character usually yields the same results,\n  // but languages are weird, and I'm sure there's scenarios where the two differ.\n});\n"},{"name":"deburr","manifest":{"fnSignature":"_.deburr(string)","lodashLink":"https://lodash.com/docs/4.17.15#deburr","summary":"Deburrs `string` by converting [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement#Character_table) and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A) letters to basic Latin letters and [removing combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks)."},"description":"```javascript\n// Credit for this implementation:\n// https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript/37511463#37511463\nfunction deburr(string) {\n  return string.normalize('NFKD').replace(/\\p{Diacritic}/gu, '');\n}\n```\n\nThis will [normalize a unicode string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize) using the standard \"Compatibility Decomposition\" algorithm, which will cause accent characters to be represented as separate code point from its base character. Afterwords, all stray accent characters are removed with the `.replace()` call.\n\nThe NFKD \"compatibility normalization\" algorithm will also normalize multiple characters that are supposed to represent the same abstract character, for example, a D in a circle (\"Ⓓ\") will be normalized into a normal \"D\". A circled C (\"Ⓒ\") would likewise be normalized into a \"C\", however, the copyright symbol (\"©\") (which is a different code point from a circled C) will not be normalized into a \"C\", because, conceptually, the copyright symbol isn't intended to simply be a variation on the character \"C\".\n\nDepending on your use-case, you may find the NFD \"Canonical Decomposition\" algorithm to be a more appropriate choice. This algorithm will only normalize characters that are literally the same but have multiple representations. For example, the \"ñ\" character is a single code point while the \"ñ\" character is an \"n\" followed by a tilde modifier - since these are just two different ways to represent the exact same character, they'll be normalized by the \"Canonical Decomposition\" algorithm into the decomposed variant - the \"n\" followed by a tilde modifier.\n\n[Learn more about normalization algorithms, including other available algorithms on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize).\n\nThe above `deburr()` implementation isn't exactly the same as Lodash's. Lodash implemented its `deburr()` function before `.normalize()` was available. It opted to use a large look-up table to convert one unicode character into another, and some of the choices it made was different from what `.normalize()` chose to do.\n\nBefore reaching for `deburr()`, try looking around to see if there's a more specific solution to handle your use-case. Are you wanting to sort unicode strings? Consider using [Intl.Collator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Collator) instead. Are you wanting to just do length-checking? Consider [using `.normalize()` with the \"NFC\" or \"NFKC\" algorithm instead](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize#form). In general, it could be good to google around to see if there are solutions available for your more specific problems. `deburr()` is a very blunt solution that could cause your text to be mangled in less-than-ideal ways.\n","src":null,"test":"describe('deburr() with NFKD', () => {\n  function deburr(string) {\n    return string.normalize('NFKD').replace(/\\p{Diacritic}/gu, '');\n  }\n\n  it('deburrs accented characters that do not use combination marks', () => {\n    // This \"ñ\" is of length 1 - it only uses a single code point to represent the character.\n    expect(deburr('ñ')).toEqual('n');\n  });\n\n  it('deburrs combination marks', () => {\n    // This \"ñ\" is of length 2 - it encodes the \"n\" with one code point and the combining tilde with another.\n    expect(deburr('ñ')).toEqual('n');\n  });\n\n  it('deburrs compatible characters', () => {\n    // A \"D\" and a \"D\" inside of a circle are considered compatible.\n    expect(deburr('Ⓓ')).toEqual('D');\n  });\n});\n\ndescribe('deburr() with NFD', () => {\n  function deburr(string) {\n    return string.normalize('NFD').replace(/\\p{Diacritic}/gu, '');\n  }\n\n  it('deburrs accented characters that do not use combination marks', () => {\n    // This \"ñ\" is of length 1 - it only uses a single code point to represent the character.\n    expect(deburr('ñ')).toEqual('n');\n  });\n\n  it('deburrs combination marks', () => {\n    // This \"ñ\" is of length 2 - it encodes the \"n\" with one code point and the combining tilde with another.\n    expect(deburr('ñ')).toEqual('n');\n  });\n\n  it('does not deburr compatible characters', () => {\n    // A \"D\" and a \"D\" inside of a circle are considered compatible,\n    // but we aren't using the compatible deburring algorithm,\n    // so the string should be left alone.\n    expect(deburr('Ⓓ')).toEqual('Ⓓ');\n  });\n});\n"},{"name":"endsWith","manifest":{"fnSignature":"_.endsWith(string, target, position?)","lodashLink":"https://lodash.com/docs/4.17.15#endsWith","summary":"Checks if `string` ends with the given target string."},"description":"```javascript\n'abc'.endsWith('bc') // => true\n```\n\nIf you search from a particular location, use the following:\n\n```javascript\nconst end = 3;\n'abcde'.slice(0, end).endsWith('bc'); // => true\n```\n","src":null,"test":""},{"name":"escape","manifest":{"fnSignature":"_.escape(string)","lodashLink":"https://lodash.com/docs/4.17.15#escape","summary":"Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in string to their corresponding HTML entities."},"description":"```javascript\nfunction escapeHtmlChars(string) {\n  return string\n    .replaceAll('&', '&amp;')\n    .replaceAll('<', '&lt;')\n    .replaceAll('>', '&gt;')\n    .replaceAll('\"', '&quot;')\n    .replaceAll(\"'\", '&#39;');\n}\n```\n\nPlease be careful when using functions like this as improper usage can result in XSS vunerabilities. The following is a quick guideline on how this `escapeHtmlChars()` function should and should not be used.\n\n```javascript\n// ✓ - It is safe to use escaped user input between most HTML tags.\n// (Just don't put it inside something silly like the <script> tag).\n`<p>${escapeHtmlChars(untrustedUserInput)}</p>`\n\n// ✓ - It is generally safe to use escaped user input inside of HTML attributes.\n// (Just don't put it inside something silly like onclick=\"...\")\n`<div data-author=\"${escapeHtmlChars(untrustedUserInput)}\">...</div>`\n\n// ✕ - Attribute values should always be quoted when they are being populated\n// with user-supplied data.\n`<img data-author=${escapeHtmlChars(untrustedUserInput)}>`\n\n// ✕ - Using escapeHtmlChars() isn't enough if you want to place\n// the value where a URL is expected. This is because HTML\n// supports fake protocols like `javascript:` that, when used, will execute\n// arbitrary code.\n`<img src=\"${escapeHtmlChars(untrustedUserInput)}\">`\n```\n\nFor a deep dive on how to prevent XSS attacks, I would recommend [this guide on escaping characters for various different contexts](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n\n## Don't use escapeHtmlChars() unless you have to\n\nDo you _really_ need an `escape()` function? Or would an alternative, less-error-prone solution work instead? There are valid reasons to need a function like `_.escape()`, but there are also some coding styles that force you to use it much more often than necessary. For example, perhaps you like to build your webpages via string interpolation and `.innerHTML`, such as in the following:\n\n```javascript\ndocument.body.innerHTML = `<p>${_.escape(userSuppliedString)}</p>`;\n```\n\nThis has the appearance of being simple and concise, but managing when and how to use `_.escape()` can be error-prone. There are a number of alternative solutions out there that remove many of these pitfalls (but not all, so you still need to look out for XSS vunerabilities no matter how you code). For example, you can use the browser APIs to manually build up your HTML instead of using string manipulation + `.innerHTML`.\n\n```javascript\nconst paragraph = document.createElement('p');\n// .innerText will automatically escape HTML characters for you.\nparagraph.innerText = userSuppliedString;\ndocument.body.replaceWith(paragraph);\n```\n\nIf you find this APIs to be cumbersome to use, you may enjoy [a little helper function](#!/utils/el) to make using it more tolerable.\n\nOr you can consider installing a third-party tool such as [Handlebars](https://handlebarsjs.com/guide/) for a simple templating library or [Lit](https://lit.dev/) for a mini framework.\n\nOr if you don't want to add an installation step to your project, you can copy some or all of the [Snap Framework](#!/framework) (The `html` template tag is especially useful for solving this problem).\n\nAll of these options will provide ways to auto-escape user-input for you, allowing you to focus more on UI building and less on data sanitization.\n","src":null,"test":"function escapeHtmlChars(string) {\n  return string\n    .replaceAll('&', '&amp;')\n    .replaceAll('<', '&lt;')\n    .replaceAll('>', '&gt;')\n    .replaceAll('\"', '&quot;')\n    .replaceAll(\"'\", '&#39;');\n}\n\ndescribe('escapeHtmlChars()', () => {\n  it('escapes all characters', () => {\n    const res = escapeHtmlChars('&<>\"\\'');\n    expect(res).toEqual('&amp;&lt;&gt;&quot;&#39;');\n  });\n\n  it('escapes all instances', () => {\n    const res = escapeHtmlChars('&<&<&');\n    expect(res).toEqual('&amp;&lt;&amp;&lt;&amp;');\n  });\n\n  it(\"doesn't panic on the empty string\", () => {\n    expect(escapeHtmlChars('')).toEqual('');\n  });\n});\n"},{"name":"kebabCase","manifest":{"fnSignature":"_.kebabCase(string)","lodashLink":"https://lodash.com/docs/4.17.15#kebabCase","summary":"Converts `string` to kebab case."},"description":"A bare-bones implementation can be done as follows:\n\n```javascript\nstring.toLowerCase().replaceAll(' ', '-')\n\n// 'Hello World'.toLowerCase().replaceAll(' ', '-')\n// => 'hello-world'\n```\n\nThe above assumes that each word is separated by a single space. The `' '` string can be swapped for a regular expression, such as `/\\s+/g`, to cause it to separate words based on any grouping of whitespace instead.\n\nFor other ways to separate a string into words, refer to [the entry for `_.words()`](#!/nolodash/words), which includes internationalization-related information as well. After separating a string into a list of words, simply do `<list of words>.join('-').toLowerCase()` on the result to create your snake case text (or use [`.toLocaleLowerCase()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase) to make it i18n-compatible)\n\nFor reference, Lodash's algorithm is implemented roughly as follows:\n* [Deburr](#!/nolodash/deburr) the string (which mostly means that accent marks are removed from characters).\n* Removes apostrophes (the ' and ’ characters).\n* Split the string into words using the algorithm that powers [`_.words()`](#!/nolodash/words).\n* lower case each word with `.toLowerCase()`.\n* Joins the words back together with a `-` character.\n","src":null,"test":"describe('snakeCase()', () => {\n  function snakeCase(string) {\n    const words = string.split(/\\s+/);\n    return words.map(word => word.toLowerCase()).join(' ');\n  }\n\n  it('converts the words from the supplied string into lower-case', () => {\n    expect(snakeCase('HELLO    aWeSoMe\\nworld')).toEqual('hello awesome world');\n  });\n\n  it('handles an empty string', () => {\n    expect(snakeCase('')).toEqual('');\n  });\n});\n"},{"name":"lowerCase","manifest":{"fnSignature":"_.lowerCase(string)","lodashLink":"https://lodash.com/docs/4.17.15#lowerCase","summary":"Converts `string`, as space separated words, to lower case."},"description":"```javascript\nfunction lowerCase(string) {\n  const words = string.split(/\\s+/);\n  return words.map(word => word.toLowerCase()).join(' ');\n}\n```\n\nThe above generates the word list by simply splitting on whitespace characters. Refer to [the entry for `_.words()`](#!/nolodash/words) for alternative ways to extract words from text (which includes information on dealing with different languages).\n\nIf you need to support internationalization, swap `.toLowerCase()` with [`.toLocalLowerCase()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase), and, if needed, provide the target language as an argument to these functions. This solution isn't perfect - read [this great post for a more nuanced exploration on internationalization and casing](https://stackoverflow.com/a/53930826/7696223).\n\nFor reference, Lodash's algorithm is implemented roughly as follows:\n* [Deburr](#!/nolodash/deburr) the string (which mostly means that accent marks are removed from characters).\n* Removes apostrophes (the ' and ’ characters).\n* Split the string into words using the algorithm that powers [`_.words()`](#!/nolodash/words).\n* Lower case each word with `.toLowerCase()`.","src":null,"test":"describe('lowerCase()', () => {\n  function lowerCase(string) {\n    const words = string.split(/\\s+/);\n    return words.map(word => word.toLowerCase()).join(' ');\n  }\n\n  it('converts the words from the supplied string into lower-case', () => {\n    expect(lowerCase('HELLO    aWeSoMe\\nworld')).toEqual('hello awesome world');\n  });\n\n  it('handles an empty string', () => {\n    expect(lowerCase('')).toEqual('');\n  });\n});\n"},{"name":"lowerFirst","manifest":{"fnSignature":"_.lowerFirst(string)","lodashLink":"https://lodash.com/docs/4.17.15#lowerFirst","summary":"Converts the first character of `string` to lower case."},"description":"I'm not entirely sure what the use-case is behind this function aside from trying to provide a lowercase version of every uppercasing-related function available. But it can be done as follows:\n\n```javascript\nfunction lowerFirst([first='', ...rest]) {\n  return first.toLowerCase() + rest.join('');\n}\n```\n\nThe above implementation is carefully implemented to rely on the iterator protocol to split the string into separate characters (destructuring syntax uses the iterator protocol under the hood). This is done because iteration will properly split a string into characters while string indexing and slicing can cause you to accidentally split a string in between a character (e.g. `const firstChar = '🚀🚀'[0];` produces an invalid character while `const [firstChar] = '🚀🚀';` will properly retrieve the first character as `🚀`).\n\nIf you need to support internationalization, swap `.toLowerCase()` with [`.toLocalLowerCase()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase), and, if needed, provide the target language as an argument. This solution isn't perfect - read [this great post for a more nuanced exploration on internationalization and casing](https://stackoverflow.com/a/53930826/7696223).\n","src":null,"test":"describe('lowerFirst()', () => {\n  function lowerFirst([first = '', ...rest]) {\n    return first.toLowerCase() + rest.join('');\n  }\n\n  it('It only converts the first character to lower case', () => {\n    expect(lowerFirst('a b C')).toEqual('a b C');\n  });\n\n  it('does not touch the string if the first character can not be converted to lower-case', () => {\n    expect(lowerFirst('+a')).toEqual('+a');\n  });\n\n  it('works on empty strings', () => {\n    expect(lowerFirst('')).toEqual('');\n  });\n\n  // I would have a test case that shows how it can properly lowercase a multi-code-unit character,\n  // but I'm not actually aware of any specific scenarios that would show the different.\n  // Lower casing an entire character vs lower casing the first first part of a character usually yields the same results,\n  // but languages are weird, and I'm sure there's scenarios where the two differ.\n});\n"},{"name":"pad","manifest":{"fnSignature":"_.pad(string, length, chars?)","lodashLink":"https://lodash.com/docs/4.17.15#pad","summary":"Pads `string` on the left and right sides if it's shorter than `length`. Padding characters are truncated if they can't be evenly divided by `length`."},"description":"```javascript\nfunction pad(string, length, chars=' ') {\n  const charsToAdd = Math.max(0, length - string.length);\n  const leftPadLength = string.length + Math.floor(charsToAdd / 2);\n  return string.padStart(leftPadLength, chars).padEnd(length, chars);\n}\n```\n","src":null,"test":""},{"name":"padEnd","manifest":{"fnSignature":"_.padEnd(string, length, chars?)","lodashLink":"https://lodash.com/docs/4.17.15#padEnd","summary":"Pads `string` on the right side if it's shorter than `length`. Padding characters are truncated if they exceed `length`."},"description":"```javascript\nstring.padEnd(length, chars)\n```\n","src":null,"test":""},{"name":"padStart","manifest":{"fnSignature":"_.padStart(string, length, chars?)","lodashLink":"https://lodash.com/docs/4.17.15#padStart","summary":"Pads `string` on the left side if it's shorter than `length`. Padding characters are truncated if they exceed `length`."},"description":"```javascript\nstring.padStart(length, chars)\n```\n","src":null,"test":""},{"name":"parseInt","manifest":{"fnSignature":"_.parseInt(string, radix?)","lodashLink":"https://lodash.com/docs/4.17.15#parseInt","summary":"Converts `string` to an integer of the specified radix."},"description":"```javascript\nparseInt(string, radix)\n```\n\nBe aware that `parseInt()` may exhibit some surprising and undesirable behaviors, for example, if it's unable to parse a portion of a string, it'll discard the rest and parse what it can, leading to strings such as `parseInt('2e7')` resulting in `2` being returned.\n\nFor a larger discussion on string-to-number conversion, see [the doc entry for `_.toNumber()`](#!/nolodash/toNumber).\n","src":null,"test":""},{"name":"repeat","manifest":{"fnSignature":"_.repeat(string, n)","lodashLink":"https://lodash.com/docs/4.17.15#repeat","summary":"Repeats the given string `n` times."},"description":"```javascript\nstring.repeat(n)\n```\n","src":null,"test":""},{"name":"replace","manifest":{"fnSignature":"_.replace(string, pattern, replacement)","lodashLink":"https://lodash.com/docs/4.17.15#replace","summary":"Replaces matches for `pattern` in `string` with `replacement`."},"description":"If you want to replace all occurrences:\n\n```javascript\nstring.replaceAll(pattern, replacement)\n\n// -- Examples --\n\n'a-b-c'.replaceAll('-', '.') // => 'a.b.c'\n'a-b-c'.replaceAll(/-/g, '.') // => 'a.b.c'\n\n// If the g flag is unset, an error will be thrown\n'a-b-c'.replaceAll(/-/, '.') // => TypeError!\n```\n\nIf you only want to replace the first occurrence:\n\n```javascript\nstring.replace(pattern, replacement)\n\n// -- Examples --\n\n'a-b-c'.replace('-', '.') // => 'a.b-c'\n'a-b-c'.replace(/-/, '.') // => 'a.b-c'\n\n// If the g flag is set, it will actually replace all\n// occurrences, just like .replaceAll()\n'a-b-c'.replace(/-/g, '.') // => 'a-b-c'\n```\n\nLodash's `_.replace()` will behave like `string.replaceAll()` when you give it a string `pattern`, in that it'll replace all occurrences of that string, and it will behave like `string.replace()` if you give it a regular expression pattern, in that it'll replace all occurrences if the global flag is set, otherwise it will only replace the first occurrence.\n","src":null,"test":""},{"name":"snakeCase","manifest":{"fnSignature":"_.snakeCase(string)","lodashLink":"https://lodash.com/docs/4.17.15#snakeCase","summary":"Converts `string` to snake case."},"description":"A bare-bones implementation can be done as follows:\n\n```javascript\nstring.toLowerCase().replaceAll(' ', '_')\n\n// 'Hello World'.toLowerCase().replaceAll(' ', '_')\n// => 'hello_world'\n```\n\nThe above assumes that each word is separated by a single space. The `' '` string can be swapped for a regular expression, such as `/\\s+/g`, to cause it to separate words based on any grouping of whitespace instead.\n\nFor other ways to separate a string into words, refer to [the entry for `_.words()`](#!/nolodash/words), which includes internationalization-related information as well. After separating a string into a list of words, simply do `<list of words>.join('_').toLowerCase()` on the result to create your snake case text (or use [`.toLocaleLowerCase()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase) to make it i18n-compatible)\n\nFor reference, Lodash's algorithm is implemented roughly as follows:\n* [Deburr](#!/nolodash/deburr) the string (which mostly means that accent marks are removed from characters).\n* Removes apostrophes (the ' and ’ characters).\n* Split the string into words using the algorithm that powers [`_.words()`](#!/nolodash/words).\n* lower case each word with `.toLowerCase()`.\n* Joins the words back together with a `_` character.\n","src":null,"test":"describe('snakeCase()', () => {\n  function snakeCase(string) {\n    const words = string.split(/\\s+/);\n    return words.map(word => word.toLowerCase()).join(' ');\n  }\n\n  it('converts the words from the supplied string into lower-case', () => {\n    expect(snakeCase('HELLO    aWeSoMe\\nworld')).toEqual('hello awesome world');\n  });\n\n  it('handles an empty string', () => {\n    expect(snakeCase('')).toEqual('');\n  });\n});\n"},{"name":"split","manifest":{"fnSignature":"_.split(string, separator, limit?)","lodashLink":"https://lodash.com/docs/4.17.15#split","summary":"Splits `string` by `separator`."},"description":"```javascript\nstring.split(separator, limit)\n```\n","src":null,"test":""},{"name":"startCase","manifest":{"fnSignature":"_.startCase(string)","lodashLink":"https://lodash.com/docs/4.17.15#startCase","summary":"Converts `string` to start case."},"description":"```javascript\nfunction startCase(string) {\n  const capitalize = ([first='', ...rest]) => first.toUpperCase() + rest.join('');\n  return string.split(' ').map(capitalize).join(' ');\n}\n```\n\nThe above generates the word list by simply splitting on space characters. Refer to [the entry for `_.words()`](#!/nolodash/words) for alternative ways to extract words from text (which includes information on dealing with different languages).\n\nRefer to the [`_.capitalize()` entry](#!/nolodash/capitalize) to learn more about the design behind the capitalize function being used. The `capitalize()` implementation used above is slightly different from `_.capitalize()` in that it doesn't lowercase the rest of the string, in order to align with Lodash's behavior for `_.startCase()`.\n\nIf you need to support internationalization, swap `.toUpperCase()`/`.toLowerCase()` with [`.toLocalUpperCase()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleUpperCase)/[`.toLocaleLowerCase()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase), and, if needed, provide the target language as an argument to these functions. This solution isn't perfect - read [this great post for a more nuanced exploration on internationalization and casing](https://stackoverflow.com/a/53930826/7696223).\n\nFor reference, Lodash's algorithm is implemented roughly as follows:\n* [Deburr](#!/nolodash/deburr) the string (which mostly means that accent marks are removed from characters).\n* Removes apostrophes (the ' and ’ characters).\n* Split the string into words using the algorithm that powers [`_.words()`](#!/nolodash/words).\n* Runs the first letter of each word through `.toUpperCase()`.\n* Joins the words back together with a space.\n","src":null,"test":"describe('startCase()', () => {\n  function startCase(string) {\n    const capitalize = ([first = '', ...rest]) => first.toUpperCase() + rest.join('');\n    return string.split(' ').map(capitalize).join(' ');\n  }\n\n  it('converts text into start case', () => {\n    expect(startCase('HELLO aWeSoMe world')).toEqual('HELLO AWeSoMe World');\n  });\n\n  it('handles an empty string', () => {\n    expect(startCase('')).toEqual('');\n  });\n});\n"},{"name":"startsWith","manifest":{"fnSignature":"_.startsWith(string, target, position?)","lodashLink":"https://lodash.com/docs/4.17.15#startsWith","summary":"Checks if `string` starts with the given target string."},"description":"```javascript\n'abc'.startsWith('ab') // => true\n```\n\nIf you search from a particular location, use the following:\n\n```javascript\nconst start = 2;\n'abcde'.slice(start).startsWith('cd'); // => true\n```\n","src":null,"test":""},{"name":"toLower","manifest":{"fnSignature":"_.toLower(string)","lodashLink":"https://lodash.com/docs/4.17.15#toLower","summary":"Converts string, as a whole, to lower case."},"description":"```javascript\nstring.toLowerCase()\n``` \n\nIf you need to be language-sensitive, use [`toLocaleLowerCase()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase) instead, and supply the chosen locale as an argument.\n","src":null,"test":""},{"name":"toUpper","manifest":{"fnSignature":"_.toUpper(string)","lodashLink":"https://lodash.com/docs/4.17.15#toUpper","summary":"Converts string, as a whole, to upper case."},"description":"```javascript\nstring.toUpperCase()\n```\n\nIf you need to be language-sensitive, use [`toLocaleUpperCase()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleUpperCase) instead, and supply the chosen locale as an argument.\n","src":null,"test":""},{"name":"trim","manifest":{"fnSignature":"_.trim(string, chars?)","lodashLink":"https://lodash.com/docs/4.17.15#trim","summary":"Removes leading and trailing whitespace or specified characters from `string`."},"description":"If you simply want to remove whitespace from both ends of the string, use the following:\n\n```javascript\nstring.trim()\n```\n\nIf you want to specify which characters to trim, use the following:\n\n```javascript\n/*# METADATA\n[\n  {\n    \"id\": \"unicodeSupport\",\n    \"type\": \"radio\",\n    \"message\": \"Do you need proper unicode/i18n support?\",\n    \"default\": \"no\",\n    \"options\": {\n      \"no\": \"No - I only plan on trimming ASCII strings containing English text.\",\n      \"yes\": \"Yes - I'd like to be able to properly support accent marks, emojis, etc, with an i18n-sensitive solution.\"\n    }\n  }\n]\n#*/\n\n//# CONFIG { \"unicodeSupport\": \"no\" }\n\nfunction trim(str, chars) {\n  let left = 0;\n  while (left < str.length && chars.includes(str[left])) {\n    left++;\n  }\n\n  let right = str.length - 1;\n  while (right >= left && chars.includes(str[right])) {\n    right--;\n  }\n\n  return str.slice(left, right + 1);\n}\n\n// Normal usage:\n// trim('-_-abc-_-', '_-') // => 'abc'\n\n// Characters that don't fit in 16 bits,\n// such as \"👋🏿\", can cause unexpected behavior.\n// trim('👋🏿hi!👍🏿', '👋🏿') // => 'hi!👍'\n\n//# CONFIG { \"unicodeSupport\": \"yes\" }\n\n// Set this to your preferred locale,\n// or set it to `undefined` to use the runtime's default locale.\nconst LOCALE = 'en';\nconst segmenter = new Intl.Segmenter(LOCALE);\nconst collator = new Intl.Collator(LOCALE)\n\nfunction trim(str, chars) {\n  const charList = [...segmenter.segment(chars)]\n    .map(({ segment }) => segment);\n\n  let left = 0;\n  let right = 0;\n  let onlySeenTrimmableChars = true;\n  for (const { segment, index } of segmenter.segment(str)) {\n    const isTrimmable = charList.some(\n      char => collator.compare(char, segment) === 0\n    );\n    if (onlySeenTrimmableChars && isTrimmable) {\n      left = index + segment.length;\n    }\n    if (!isTrimmable) {\n      onlySeenTrimmableChars = false;\n      right = index + segment.length;\n    }\n  }\n\n  return str.slice(left, right);\n}\n\n// Normal usage:\n// trim('-_-abc-_-', '_-') // => 'abc'\n\n// Characters that don't fit in 16 bits,\n// such as \"👋🏿\", will work as expected.\n// trim('👋🏿hi!👍🏿', '👋🏿') // => 'hi!👍🏿'\n```\n\nLodash provides some unicode support with its `_.trim()` implementation, but it isn't as robust as using the native `Intl` APIs that the unicode-aware variant of the above solution utilizes.\n","src":null,"test":""},{"name":"trimEnd","manifest":{"fnSignature":"_.trimEnd(string, chars?)","lodashLink":"https://lodash.com/docs/4.17.15#trimEnd","summary":"Removes trailing whitespace or specified characters from `string`."},"description":"If you simply want to remove whitespace from the end of the string, use the following:\n\n```javascript\nstring.trimEnd()\n```\n\nIf you want to specify which characters to trim, use the following:\n\n```javascript\n/*# METADATA\n[\n  {\n    \"id\": \"unicodeSupport\",\n    \"type\": \"radio\",\n    \"message\": \"Do you need proper unicode/i18n support?\",\n    \"default\": \"no\",\n    \"options\": {\n      \"no\": \"No - I only plan on trimming ASCII strings containing English text.\",\n      \"yes\": \"Yes - I'd like to be able to properly support accent marks, emojis, etc, with an i18n-sensitive solution.\"\n    }\n  }\n]\n#*/\n\n//# CONFIG { \"unicodeSupport\": \"no\" }\n\nfunction trimEnd(str, chars) {\n  const strArray = [...str];\n  while (strArray.length > 0 && chars.includes(strArray.at(-1))) {\n    strArray.pop();\n  }\n\n  return strArray.join('');\n}\n\n// Normal usage:\n// trimEnd('-_-abc-_-', '_-') // => '-_-abc'\n\n// Characters that don't fit in 16 bits,\n// such as \"👋🏿\", can cause unexpected behavior.\n// trimEnd('hi!👍🏿', '👋🏿') // => 'hi!👍'\n\n//# CONFIG { \"unicodeSupport\": \"yes\" }\n\n// Set this to your preferred locale,\n// or set it to `undefined` to use the runtime's default locale.\nconst LOCALE = 'en';\nconst segmenter = new Intl.Segmenter(LOCALE);\nconst collator = new Intl.Collator(LOCALE)\n\nfunction trimEnd(str, chars) {\n  const charList = [...segmenter.segment(chars)]\n    .map(({ segment }) => segment);\n\n  let right = 0;\n  for (const { segment, index } of segmenter.segment(str)) {\n    const isTrimmable = charList.some(\n      char => collator.compare(char, segment) === 0\n    );\n\n    if (!isTrimmable) {\n      right = index + segment.length;\n    }\n  }\n\n  return str.slice(0, right);\n}\n\n// Normal usage:\n// trimEnd('-_-abc-_-', '_-') // => '-_-abc'\n\n// Characters that don't fit in 16 bits,\n// such as \"👋🏿\", will work as expected.\n// trimEnd('hi!👍🏿', '👋🏿') // => 'hi!👍🏿'\n```\n\nLodash provides some unicode support with its `_.trim()` implementation, but it isn't as robust as using the native `Intl` APIs that the unicode-aware variant of the above solution utilizes.\n","src":null,"test":""},{"name":"trimStart","manifest":{"fnSignature":"_.trimStart(string, chars?)","lodashLink":"https://lodash.com/docs/4.17.15#trimStart","summary":"Removes leading whitespace or specified characters from `string`."},"description":"If you simply want to remove whitespace from the start of the string, use the following:\n\n```javascript\nstring.trimStart()\n```\n\nIf you want to specify which characters to trim, use the following:\n\n```javascript\n/*# METADATA\n[\n  {\n    \"id\": \"unicodeSupport\",\n    \"type\": \"radio\",\n    \"message\": \"Do you need proper unicode/i18n support?\",\n    \"default\": \"no\",\n    \"options\": {\n      \"no\": \"No - I only plan on trimming ASCII strings containing English text.\",\n      \"yes\": \"Yes - I'd like to be able to properly support accent marks, emojis, etc, with an i18n-sensitive solution.\"\n    }\n  }\n]\n#*/\n\n//# CONFIG { \"unicodeSupport\": \"no\" }\n\nfunction trimStart(str, chars) {\n  let left = 0;\n  while (left < str.length && chars.includes(str[left])) {\n    left++;\n  }\n\n  return str.slice(left);\n}\n\n// Normal usage:\n// trimStart('-_-abc-_-', '_-') // => 'abc-_-'\n\n// Characters that don't fit in 16 bits,\n// such as \"👋🏿\", can cause unexpected behavior.\n// trimStart('👋🏽hi!', '👋🏿') // => '�hi!'\n\n//# CONFIG { \"unicodeSupport\": \"yes\" }\n\n// Set this to your preferred locale,\n// or set it to `undefined` to use the runtime's default locale.\nconst LOCALE = 'en';\nconst segmenter = new Intl.Segmenter(LOCALE);\nconst collator = new Intl.Collator(LOCALE)\n\nfunction trimStart(str, chars) {\n  const charList = [...segmenter.segment(chars)]\n    .map(({ segment }) => segment);\n\n  let left = 0;\n  for (const { segment, index } of segmenter.segment(str)) {\n    const isTrimmable = charList.some(\n      char => collator.compare(char, segment) === 0\n    );\n\n    if (!isTrimmable) {\n      break;\n    }\n\n    left = index + segment.length;\n  }\n\n  return str.slice(left);\n}\n\n// Normal usage:\n// trimStart('-_-abc-_-', '_-') // => 'abc-_-'\n\n// Characters that don't fit in 16 bits,\n// such as \"👋🏿\", will work as expected.\n// trimStart('👋🏽hi!', '👋🏿') // => '👋🏽hi!'\n```\n\nLodash provides some unicode support with its `_.trimStart()` implementation, but it isn't as robust as using the native `Intl` APIs that the unicode-aware variant of the above solution utilizes.\n","src":null,"test":""},{"name":"truncate","manifest":{"fnSignature":"_.truncate(string, options)","lodashLink":"https://lodash.com/docs/4.17.15#truncate","summary":"Truncates `string` if it's longer than the given maximum string length. The last characters of the truncated string are replaced with the omission string which defaults to \"...\"."},"description":"A basic implementation that does not support the `separator` parameter can be achieved as follows:\n\n```javascript\nfunction truncate(string, { length, omission = '...' }) {\n  if (string.length <= length) {\n    return string;\n  }\n\n  return string.slice(0, length - omission.length) + omission;\n}\n```\n\nA more complete implementation that supports truncating at a string or regular expression separator can be implemented as follows:\n\n```javascript\nfunction truncate(string, { length, separator = '', omission = '...' }) {\n  if (string.length <= length) {\n    return string;\n  }\n\n  // Largest size you can slice `string` while remaining in the `length` restriction.\n  const maxSliceLength = length - omission.length;\n\n  if (typeof separator === 'string') {\n    let index = string.lastIndexOf(separator, maxSliceLength);\n    if (index === -1) {\n      index = maxSliceLength;\n    }\n    return string.slice(0, index) + omission;\n  } else if (separator instanceof RegExp) {\n    let bestMatch = undefined;\n    for (const match of string.matchAll(separator)) {\n      if (match.index <= maxSliceLength) {\n        bestMatch = match;\n      }\n    }\n\n    const index = bestMatch?.index ?? maxSliceLength;\n    return string.slice(0, index) + omission;\n  } else {\n    throw new Error('Invalid separator type received.');\n  }\n}\n```\n\nOne difference with the above implementation and Lodash's version is that a separator regular expression must have the \"g\" flag set. If you have a regular expression on hand that does not have the `g` flag set, and you would like it to, you can convert it as follows:\n\n```javascript\nconst regexWithGlobalFlag = regex.global\n  ? regex\n  : new RegExp(regex.source, regex.flags + 'g');\n```\n\nIf you're wanting to truncate a string before displaying it in the browser, you may wish to instead use the `text-overflow: ellipsis` rule on the container holding to text. This rule is able to smartly truncate the text just before it would overflow out of the container, as opposed to truncating based on character count (remember that different characters can have different widths). To make the text-overflow property work, you'll also need to limit the container's size (e.g. by setting the `width` rule), set `overflow: hidden`, and set `white-space: nowrap`.\n","src":null,"test":"describe('truncate() without separator support', () => {\n  function truncate(string, { length, omission = '...' }) {\n    if (string.length <= length) {\n      return string;\n    }\n  \n    return string.slice(0, length - omission.length) + omission;\n  }\n\n  it('does not truncate a string that is within the length limit', () => {\n    expect(truncate('abcde', { length: 6 })).toEqual('abcde');\n    expect(truncate('abcde', { length: 5 })).toEqual('abcde');\n    expect(truncate('abcde', { length: 4 })).not.toEqual('abcde');\n  });\n\n  it('appends the omission string when truncating', () => {\n    expect(truncate('abcde', { length: 4 })).toEqual('a...');\n    expect(truncate('abcde', { length: 4, omission: '…' })).toEqual('abc…');\n  });\n})\n\ndescribe('truncate() with separator support', () => {\n  function truncate(string, { length, separator = '', omission = '...' }) {\n    if (string.length <= length) {\n      return string;\n    }\n  \n    // Largest size you can slice `string` while remaining in the `length` restriction.\n    const maxSliceLength = length - omission.length;\n  \n    if (typeof separator === 'string') {\n      let index = string.lastIndexOf(separator, maxSliceLength);\n      if (index === -1) {\n        index = maxSliceLength;\n      }\n      return string.slice(0, index) + omission;\n    } else if (separator instanceof RegExp) {\n      let bestMatch = undefined;\n      for (const match of string.matchAll(separator)) {\n        if (match.index <= maxSliceLength) {\n          bestMatch = match;\n        }\n      }\n  \n      const index = bestMatch?.index ?? maxSliceLength;\n      return string.slice(0, index) + omission;\n    } else {\n      throw new Error('Invalid separator type received.');\n    }\n  }\n\n  it('does not truncate a string that is within the length limit', () => {\n    expect(truncate('abcde', { length: 6 })).toEqual('abcde');\n    expect(truncate('abcde', { length: 5 })).toEqual('abcde');\n    expect(truncate('abcde', { length: 4 })).not.toEqual('abcde');\n  });\n\n  it('appends the omission string when truncating', () => {\n    expect(truncate('abcde', { length: 4 })).toEqual('a...');\n    expect(truncate('abcde', { length: 4, omission: '…' })).toEqual('abc…');\n  });\n\n  it('can truncate using a string separator', () => {\n    expect(truncate('abcd~=efgh~=ijklmn', { separator: '~=', length: 'abcd~=efgh~=i...'.length })).toEqual('abcd~=efgh...');\n    expect(truncate('abcd~=efgh~=ijklmn', { separator: '~=', length: 'abcd~=efgh~=...'.length })).toEqual('abcd~=efgh...');\n    expect(truncate('abcd~=efgh~=ijklmn', { separator: '~=', length: 'abcd~=efgh~...'.length })).toEqual('abcd~=efgh...');\n    expect(truncate('abcd~=efgh~=ijklmn', { separator: '~=', length: 'abcd~=efgh...'.length })).toEqual('abcd~=efgh...');\n    expect(truncate('abcd~=efgh~=ijklmn', { separator: '~=', length: 'abcd~=efg...'.length })).toEqual('abcd...');\n  });\n\n  it('falls back to truncating anywhere if the string separator fails to find a match', () => {\n    expect(truncate('abcdefg', { separator: ' ', length: 5 })).toEqual('ab...');\n  });\n\n  it('can truncate using a regular expression separator', () => {\n    expect(truncate('abcd~=efgh~=ijklmn', { separator: /[~=]+/g, length: 'abcd~=efgh~=i...'.length })).toEqual('abcd~=efgh...');\n    expect(truncate('abcd~=efgh~=ijklmn', { separator: /[~=]+/g, length: 'abcd~=efgh~=...'.length })).toEqual('abcd~=efgh...');\n    expect(truncate('abcd~=efgh~=ijklmn', { separator: /[~=]+/g, length: 'abcd~=efgh~...'.length })).toEqual('abcd~=efgh...');\n    expect(truncate('abcd~=efgh~=ijklmn', { separator: /[~=]+/g, length: 'abcd~=efgh...'.length })).toEqual('abcd~=efgh...');\n    expect(truncate('abcd~=efgh~=ijklmn', { separator: /[~=]+/g, length: 'abcd~=efg...'.length })).toEqual('abcd...');\n  });\n\n  it('falls back to truncating anywhere if the regular expression separator fails to find a match', () => {\n    expect(truncate('abcdefg', { separator: / /g, length: 5 })).toEqual('ab...');\n  });\n})\n"},{"name":"unescape","manifest":{"fnSignature":"_.unescape(string)","lodashLink":"https://lodash.com/docs/4.17.15#unescape","summary":"The inverse of _.escape; this method converts the HTML entities &amp;, &lt;, &gt;, &quot;, and &#39; in string to their corresponding characters."},"description":"If you wish to unescape all HTML-encoded characters and you're in a browser environment, you can use the following:\n\n```javascript\nfunction unescapeHtmlChars(string) {\n  const doc = new DOMParser().parseFromString(string, 'text/html');\n  return doc.documentElement.textContent;\n}\n```\n\nIf your JavaScript is not running in a browser, you can instead use a library such as [jsdom](https://www.npmjs.com/package/jsdom) to mimic the DOM and provide the same kind of API, or you can use a lighter-weight package that only provides this HTML-character-unescaping functionality and nothing else, such as [html-entities](https://www.npmjs.com/package/html-entities).\n\nLodash's `_.unescape()` function does not unescape all HTML characters, only those that get escaped when using `_.escape()`, which means using its implementation would be insufficient in most situations. Nevertheless, if you are wanting an implementation like Lodash's, you can use the following:\n\n```javascript\nfunction unescapeHtmlChars(string) {\n  // Unecoding \"&\" needs to be done last.\n  // If it is done first, something like \"&amp;lt;\" would incorrectly\n  // get unencoded to \"<\", when it should be \"&lt;\"\n  return string\n    .replaceAll('&lt;', '<')\n    .replaceAll('&gt;', '>')\n    .replaceAll('&quot;', '\"')\n    .replaceAll('&#39;', \"'\")\n    .replaceAll('&amp;', '&');\n}\n```\n\n## Don't use unescapeHtmlChars() unless you have to\n\nThe use of `unescapeHtmlChars()` may (or may not) indicate an issue with how you're storing and transfering data. Escaping HTML characters is an operation that is generally done the moment before you insert it into your page. If this pattern is followed, you will generally have an unescaped version of your string on-hand as well, which removes the need for using an `unescapeHtmlChars()` function. [Further information about when to escape your HTML characters](https://security.stackexchange.com/questions/32394/when-to-escape-user-input/32396#32396).\n","src":null,"test":"function unescapeHtmlChars(string) {\n  // Unecoding \"&\" needs to be done last.\n  // If it is done first, something like \"&amp;lt;\" would incorrectly\n  // get unencoded to \"<\", when it should be \"&lt;\"\n  return string\n    .replaceAll('&lt;', '<')\n    .replaceAll('&gt;', '>')\n    .replaceAll('&quot;', '\"')\n    .replaceAll('&#39;', \"'\")\n    .replaceAll('&amp;', '&');\n}\n\ndescribe('unescape()', () => {\n  it('unescapes all characters', () => {\n    const res = unescapeHtmlChars('&amp;&lt;&gt;&quot;&#39;');\n    expect(res).toEqual('&<>\"\\'');\n  });\n\n  it('unescapes all instances', () => {\n    const res = unescapeHtmlChars('&amp;&lt;&amp;&lt;&amp;');\n    expect(res).toEqual('&<&<&');\n  });\n\n  it(\"doesn't panic on the empty string\", () => {\n    expect(unescapeHtmlChars('')).toEqual('');\n  });\n\n  it('does not double-unescape characters', () => {\n    const res = unescapeHtmlChars('&amp;lt;');\n    // Should equal \"&lt;\", not \"<\"\n    expect(res).toEqual('&lt;');\n  });\n});\n"},{"name":"upperCase","manifest":{"fnSignature":"_.upperCase(string)","lodashLink":"https://lodash.com/docs/4.17.15#upperCase","summary":"Converts `string`, as space separated words, to upper case."},"description":"```javascript\nfunction upperCase(string) {\n  const words = string.split(/\\s+/);\n  return words.map(word => word.toUpperCase()).join(' ');\n}\n```\n\nThe above generates the word list by simply splitting on whitespace characters. Refer to [the entry for `_.words()`](#!/nolodash/words) for alternative ways to extract words from text (which includes information on dealing with different languages).\n\nIf you need to support internationalization, swap `.toUpperCase()` with [`.toLocalUpperCase()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleUpperCase), and, if needed, provide the target language as an argument to these functions. This solution isn't perfect - read [this great post for a more nuanced exploration on internationalization and casing](https://stackoverflow.com/a/53930826/7696223).\n\nFor reference, Lodash's algorithm is implemented roughly as follows:\n* [Deburr](#!/nolodash/deburr) the string (which mostly means that accent marks are removed from characters).\n* Removes apostrophes (the ' and ’ characters).\n* Split the string into words using the algorithm that powers [`_.words()`](#!/nolodash/words).\n* upper case each word with `.toUpperCase()`.","src":null,"test":"describe('upperCase()', () => {\n  function upperCase(string) {\n    const words = string.split(/\\s+/);\n    return words.map(word => word.toUpperCase()).join(' ');\n  }\n\n  it('converts the words from the supplied string into upper-case', () => {\n    expect(upperCase('HELLO    aWeSoMe\\nworld')).toEqual('HELLO AWESOME WORLD');\n  });\n\n  it('handles an empty string', () => {\n    expect(upperCase('')).toEqual('');\n  });\n});\n"},{"name":"upperFirst","manifest":{"fnSignature":"_.upperFirst(string)","lodashLink":"https://lodash.com/docs/4.17.15#upperFirst","summary":"Converts the first character of `string` to upper case."},"description":"```javascript\nfunction upperFirst([first='', ...rest]) {\n  return first.toUpperCase() + rest.join('');\n}\n```\n\nThe above implementation is carefully implemented to rely on the iterator protocol to split the string into separate characters (destructuring syntax uses the iterator protocol under the hood). This is done because iteration will properly split a string into characters while string indexing and slicing can cause you to accidentally split a string in between a character (e.g. `const firstChar = '🚀🚀'[0];` produces an invalid character while `const [firstChar] = '🚀🚀';` will properly retrieve the first character as `🚀`).\n\nIf you need to support internationalization, swap `.toUpperCase()` with [`.toLocalUpperCase()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleUpperCase), and, if needed, provide the target language as an argument. This solution isn't perfect - read [this great post for a more nuanced exploration on internationalization and casing](https://stackoverflow.com/a/53930826/7696223).\n","src":null,"test":"describe('upperFirst()', () => {\n  function upperFirst([first = '', ...rest]) {\n    return first.toUpperCase() + rest.join('');\n  }\n\n  it('It only converts the first character to upper case', () => {\n    expect(upperFirst('a b C')).toEqual('A b C');\n  });\n\n  it('does not touch the string if the first character can not be converted to upper-case', () => {\n    expect(upperFirst('+a')).toEqual('+a');\n  });\n\n  it('works on empty strings', () => {\n    expect(upperFirst('')).toEqual('');\n  });\n\n  // I would have a test case that shows how it can properly uppercase a multi-code-unit character,\n  // but I'm not actually aware of any specific scenarios that would show the different.\n  // Upper casing an entire character vs upper casing the first first part of a character usually yields the same results,\n  // but languages are weird, and I'm sure there's scenarios where the two differ.\n});\n"},{"name":"words","manifest":{"fnSignature":"_.words(string)","lodashLink":"https://lodash.com/docs/4.17.15#words","summary":"Splits `string` into an array of its words."},"description":"To split a string into words:\n\n```javascript\nstring.split(' ')\n```\n\nThe above will simply split the string on a single space. You can alternatively use one of these as an argument instead:\n* `/ +/` - split on one or more spaces. This will correctly split the string `\"a    b\"` into `[\"a\", \"b\"]`.\n* `/\\s+/` - split on one or more white-space characters (spaces, new lines, etc).\n* `/[^a-zA-Z0-9]+/` - split on any non-alpha-numeric text.\n\nIf you need a more robust solution that's language-sensitive, consider using [`Intl.Segmenter`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter) instead.\n\n```javascript\nconst str = '吾輩は猫である。名前はたぬき。';\nconst segmenterJa = new Intl.Segmenter('ja-JP', { granularity: 'word' });\n\nconsole.log(\n  [...segmenterJa.segment(str)]\n    .filter(segmentInfo => segmentInfo.isWordLike)\n    .map(segmentInfo => segmentInfo.segment)\n);\n// => ['吾輩', 'は', '猫', 'で', 'ある', '名前', 'は', 'たぬき']\n```\n\nLodash attempts to get fancy with how it determines whether or not something should be considered a word or not, but it doesn't do as good of a job as `Intl.Segmenter()` (which wasn't available when Lodash was being created). As always, remember that language is messy and even `Intl.Segmenter()` isn't a perfect solution, but it is the best option that's natively available.\n\nLodash also lets you define what a word is via a pattern argument to `_.words()`. Using the pattern argument is really the same as doing `string.match(pattern) ?? []`. (This is different from doing `string.split(pattern)` in that the regular expression needs to define what characters are inside of a word, instead of defining what characters are between the words).\n\n```javascript\n'fred, barney, & pebbles'.match(/[^, ]+/g) ?? []\n// => [ 'fred', 'barney', '&', 'pebbles' ]\n```\n","src":null,"test":""}]},{"categoryHeading":"Util","entries":[{"name":"attempt","manifest":{"fnSignature":"_.attempt(func, ...args)","lodashLink":"https://lodash.com/docs/4.17.15#attempt","summary":"Attempts to invoke `func`, returning either the result or the caught error object. Any additional arguments are provided to `func` when it's invoked."},"description":"```javascript\nfunction attempt(func, ...args) {\n  try {\n    // Using .call() may be overkill.\n    // You could just do `return func(...args)` if you\n    // don't need to worry about preserving the \"this\" argument.\n    return func.call(...args);\n  } catch (error) {\n    return error instanceof Error ? error : new Error(error);\n  }\n}\n```\n","src":null,"test":""},{"name":"bindAll","manifest":{"fnSignature":"_.bindAll(object, methodNames)","lodashLink":"https://lodash.com/docs/4.17.15#bindAll","summary":"Binds methods of an object to the object itself, overwriting the existing method."},"description":"```javascript\nfunction bindAll(object, methodNames) {\n  for (const method of methodNames) {\n    object[method] = object[method].bind(object);\n  }\n}\n```\n","src":null,"test":""},{"name":"constant","manifest":{"fnSignature":"_.constant(value)","lodashLink":"https://lodash.com/docs/4.17.15#constant","summary":"Creates a function that returns `value`."},"description":"```javascript\n() => value\n```\n\nThe `_.constant()` method was created before arrow function syntax was standard, which meant it used to be a bit more verbose to accomplish this task without Lodash.\n","src":null,"test":""},{"name":"defaultTo","manifest":{"fnSignature":"_.defaultTo(value, defaultValue)","lodashLink":"https://lodash.com/docs/4.17.15#defaultTo","summary":"Checks `value` to determine whether a default value should be returned in its place. The `defaultValue` is returned if value is `NaN`, `null`, or `undefined`."},"description":"The recommended way to fall back to a default value is the following:\n\n```javascript\nvalue ?? defaultValue\n```\n\nThis will cause `defaultValue` to be used if `value` is either `null` or `undefined`. Unlike Lodash, it will _not_ cause the `defaultValue` to be given when `NaN` is provided - this is a good thing, both `null` and `undefined` are used to represent the absent of a value while `NaN` is intended to represent an error in a numerical calculation. In typical scenarios you shouldn't expect `NaN` to fall back to a default value any more than you would expect an instance of `Error` to do that.\n\nIf you are in a scenario where you are expecting an error in a numeric calculation (i.e. you're expecting to see `NaN`), and you would like to fall back to a default value if an error occurs, you can use the following:\n\n```javascript\nNumber.isNaN(value) ? defaultValue : value\n```\n","src":null,"test":""},{"name":"identity","manifest":{"fnSignature":"_.identity(value)","lodashLink":"https://lodash.com/docs/4.17.15#identity","summary":"This method returns the first argument it receives."},"description":"```javascript\nx => x\n```\n\nThe `_.identity()` method was created before arrow function syntax was standard, which meant it used to be a lot more verbose to accomplish this task without Lodash.\n","src":null,"test":""},{"name":"method","manifest":{"fnSignature":"_.method(path, ...args)","lodashLink":"https://lodash.com/docs/4.17.15#method","summary":"Creates a function that invokes the method at `path` of a given object. Any additional arguments are provided to the invoked method."},"description":"Instead of using `_.method()` to create a function, such as in this example:\n\n```javascript\nconst callNestedFn = _.method(['subObj', 'fn']);\nconst obj = { subObj: { fn: () => 7 } };\nconsole.log(callNestedFn(obj)); // => 7\n```\n\nYou can instead define your function with arrow function syntax, like this:\n\n```javascript\nconst callNestedFn = obj => obj.subObj.fn();\nconst obj = { subObj: { fn: () => 7 } };\nconsole.log(callNestedFn(obj)); // => 7\n```\n\nIf you're receiving property names dynamically and really do need a `_.method()`-like helper function, you can use the following:\n\n```javascript\n// This _.invoke() implementation is borrows from the _.invoke() doc entry.\nfunction invoke(object, path, ...args) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return undefined;\n  }\n\n  if (tail.length === 0) {\n    return object[head](...args);\n  }\n\n  return invoke(object[head], tail, ...args);\n}\n\nfunction method(path, ...args) {\n  return object => invoke(object, path, ...args);\n}\n```\n\nBe aware that, like Lodash's `_.method()`, the above implementation doesn't do anything to guard against prototype look-ups, for example, `method('toString')({})` will work, and will return the string `'[object Object]'`. To guard against this, use `if (!(Object.hasOwn(head, object)))` instead of `if(!(head in object))`.\n\nOne of the primary reasons Lodash's `_.method()` function was commonly used, was as a way to easily invoke a function nested in an object without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined.\n\nFor example, these two are effectively the same:\n\n```javascript\n_.method('subObj.fn', 2, 4)(obj);\n\nobj?.subObj?.fn?.(2, 4);\n```\n\nNote that the support for string paths in the above `method()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.method()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"methodOf","manifest":{"fnSignature":"_.methodOf(object, ...args)","lodashLink":"https://lodash.com/docs/4.17.15#methodOf","summary":"The opposite of `_.method`; this method creates a function that invokes the method at a given path of `object`. Any additional arguments are provided to the invoked method."},"description":"```javascript\n// This _.invoke() implementation is borrows from the _.invoke() doc entry.\nfunction invoke(object, path, ...args) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return undefined;\n  }\n\n  if (tail.length === 0) {\n    return object[head](...args);\n  }\n\n  return invoke(object[head], tail, ...args);\n}\n\nfunction methodOf(object, ...args) {\n  return path => invoke(object, path, ...args);\n}\n```\n\nBe aware that, like Lodash's `_.methodOf()`, the above implementation doesn't do anything to guard against prototype look-ups, for example, `methodOf({})('toString')` will work, and will return the string `'[object Object]'`. To guard against this, use `if (!(Object.hasOwn(head, object)))` instead of `if(!(head in object))`.\n\nNote that the support for string paths in the above `methodOf()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.methodOf()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"noop","manifest":{"fnSignature":"_.noop()","lodashLink":"https://lodash.com/docs/4.17.15#noop","summary":"This method returns `undefined`."},"description":"```javascript\n() => {}\n```\n\nThe `_.noop()` method was created before arrow function syntax was standard, which meant it used to be a bit more verbose to accomplish this task without Lodash.\n","src":null,"test":""},{"name":"nthArg","manifest":{"fnSignature":"_.nthArg(n)","lodashLink":"https://lodash.com/docs/4.17.15#nthArg","summary":"Creates a function that gets the argument at index `n`. If `n` is negative, the nth argument from the end is returned."},"description":"In one-off situations, you can simply create a function to handle it:\n\n```javascript\n// Always returns the second argument\n(_, x) => x\n\n// Always returns the fifth argument\n(...args) => args[4]\n\n// Always returns the second-to-last argument\n(...args) => args.at(-2)\n```\n\nIf you need a reusable function, you can use the following:\n\n```javascript\nfunction nthArg(n) {\n  return (...args) => args.at(n);\n}\n```\n","src":null,"test":""},{"name":"range","manifest":{"fnSignature":"_.range(start?, end, step?)","lodashLink":"https://lodash.com/docs/4.17.15#range","summary":"Creates an array of numbers (positive and/or negative) progressing from start up to, but not including, end."},"description":"You can use `Array.from(...)` to generate arrays filled with a range of numbers. Some concrete examples:\n\n```javascript\n// Same as _.range(5)\nArray.from({ length: 5 }, (_, i) => i) // => [0, 1, 2, 3, 4]\n\n// Same as _.range(2, 5)\nArray.from({ length: 3 }, (_, i) => 2 + i) // => [2, 3, 4]\n\n// Same as _.range(4, 10, 2)\nArray.from({ length: 3 }, (_, i) => 4 + i*2) // => [4, 6, 8]\n\n// Same as _.range(5, 3, -0.5)\nArray.from({ length: 4 }, (_, i) => 5 - i*0.5) // => [5, 4.5, 4, 3.5]\n```\n\nHow it works: `Array.from()` expects an array-like (or an iterable) as the first argument and a mapping function as the second. `{ length: n }` is a valid array-like object that is of length `n` and has no elements in it. The mapping function receives, as the second argument, the current item number geing generated.\n\nHere's another way to accomplishing the same thing in a slightly different style:\n\n```javascript\n// Same as _.range(4, 10, 2)\n// And the same as Array.from({ length: 3 }, (_, i) => 4 + i*2) // => [4, 6, 8]\nnew Array(3).fill().map((_, i) => 4 + i*2) // => [4, 6, 8]\n```\n\n`new Array(n)` creates array holes, which are an emptiness state that is different from `undefined` and `null`, that have an inconsistent iteration behavior - some array methods treat holes like `undefined` and others will skip over them entirely. Because of this, it is generally advisable to avoid array holes and `new Array(n)`. The use of `.fill()` right after `new Array(n)` will cause the array holes to immediately be plugged with `undefined`, fixing the problem. If you want to be strict about avoiding array holes, then you may want to avoid this solution, preferring to instead use the `Array.from()` solution. Alternatively, you may see `new Array(n).fill()` as an acceptable exception to the \"avoid array holes\" guidelines and be ok with this solution.\n\nYou can also use the following if you want a more complete helper function that does the math for you. Feel free to remove any pieces of this function that you don't currently need.\n\n```javascript\nfunction range(...args) {\n  // Adds support for passing in a single argument.\n  if (args.length === 1) {\n    const end = args[0];\n    return range(0, end);\n  }\n  const [start, end, step = 1] = args;\n\n  // A couple of checks to prevent accidental infinite loops.\n  // Number.isFinite() is making sure the values are numbers, and they aren't NaN or Infinity.\n  if (step === 0 || ![start, end, step].every(n => Number.isFinite(n))) {\n    throw new Error('Received an invalid argument.');\n  }\n\n  const result = [];\n  if (step > 0) {\n    for (let i = start; i < end; i += step) {\n      result.push(i);\n    }\n  } else {\n    for (let i = start; i > end; i += step) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n```\n\nThis implementation isn't exactly the same as Lodash's in that if you call `range()` with a single, negative argument, Lodash will produce a range that counts down to it. To keep things a little simpler, the above implementation won't automatically swap to a step of -1, and will instead return the empty array.\n\nThere is [an upcoming \"iterator range\" proposal](https://github.com/tc39/proposal-iterator.range) that will introduce a native range function.\n","src":null,"test":"function range(...args) {\n  // Adds support for passing in a single argument.\n  if (args.length === 1) {\n    const end = args[0];\n    return range(0, end);\n  }\n  const [start, end, step = 1] = args;\n\n  // A couple of checks to prevent accidental infinite loops.\n  // Number.isFinite() is making sure the values are numbers, and they aren't NaN or Infinity.\n  if (step === 0 || ![start, end, step].every(n => Number.isFinite(n))) {\n    throw new Error('Received an invalid argument.');\n  }\n\n  const result = [];\n  if (step > 0) {\n    for (let i = start; i < end; i += step) {\n      result.push(i);\n    }\n  } else {\n    for (let i = start; i > end; i += step) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\ndescribe('range()', () => {\n  it('treats a single argument as the stop argument', () => {\n    expect(range(5)).toEqual([0, 1, 2, 3, 4]);\n  });\n\n  it('accepts floats as a single argument', () => {\n    expect(range(4.5)).toEqual([0, 1, 2, 3, 4]);\n  });\n\n  it('returns an empty array when given a non-positive single argument', () => {\n    expect(range(0)).toEqual([]);\n    expect(range(-5)).toEqual([]);\n  });\n\n  it('can accept a start and stop argument', () => {\n    expect(range(2, 5)).toEqual([2, 3, 4]);\n  });\n\n  it('can accept a start, stop, and step argument', () => {\n    expect(range(4, 10, 2)).toEqual([4, 6, 8]);\n  });\n\n  it('can iterate backwards', () => {\n    expect(range(5, 2, -1)).toEqual([5, 4, 3]);\n  });\n\n  it('can iterate over floats', () => {\n    expect(range(3, 5, 0.5)).toEqual([3, 3.5, 4, 4.5]);\n  });\n\n  it('return an empty array if the step is pointed in the wrong direction', () => {\n    expect(range(2, 4, -1)).toEqual([]);\n    expect(range(4, 2)).toEqual([]);\n  });\n\n  it('return an empty array if the stop is already at the start', () => {\n    expect(range(4, 4)).toEqual([]);\n    expect(range(4, 4, -1)).toEqual([]);\n  });\n\n  it('throws when any of the arguments are not a finite number', () => {\n    expect(() => range(-Infinity)).toThrow('invalid argument');\n    expect(() => range(NaN)).toThrow('invalid argument');\n    expect(() => range('23')).toThrow('invalid argument');\n\n    expect(() => range(Infinity, 5, 2)).toThrow('invalid argument');\n    expect(() => range(2, NaN, 3)).toThrow('invalid argument');\n    expect(() => range(1, 2, '23')).toThrow('invalid argument');\n  });\n});\n"},{"name":"rangeRight","manifest":{"fnSignature":"_.rangeRight(start?, end, step?)","lodashLink":"https://lodash.com/docs/4.17.15#rangeRight","summary":"This method is like `_.range` except that it populates values in descending order."},"description":"Refer to [the _.range() documentation entry](#!/nolodash/range) for various techniques on producing a range of values. Then call `.toReversed()` on the result to reverse the range.\n","src":null,"test":""},{"name":"stubArray","manifest":{"fnSignature":"_.stubArray()","lodashLink":"https://lodash.com/docs/4.17.15#stubArray","summary":"This method returns a new empty array."},"description":"```javascript\n() => []\n```\n\nThe `_.stubArray()` method was created before arrow function syntax was standard, which meant it used to be a lot more verbose to accomplish this task without Lodash.\n","src":null,"test":""},{"name":"stubFalse","manifest":{"fnSignature":"_.stubFalse()","lodashLink":"https://lodash.com/docs/4.17.15#stubFalse","summary":"This method returns `false`."},"description":"```javascript\n() => false\n```\n\nThe `_.stubFalse()` method was created before arrow function syntax was standard, which meant it used to be a lot more verbose to accomplish this task without Lodash.\n","src":null,"test":""},{"name":"stubObject","manifest":{"fnSignature":"_.stubObject()","lodashLink":"https://lodash.com/docs/4.17.15#stubObject","summary":"This method returns a new empty object."},"description":"```javascript\n() => ({})\n```\n\nRemember that when arrow functions return an object without explicitly using the `return` keyword, you must wrap the object in parentheses to distinguish it from a block of code (`() => {}` is interpreted as an arrow function with an empty body, which is not the same thing as an arrow function that returns an object).\n\nThe `_.stubObject()` method was created before arrow function syntax was standard, which meant it used to be a lot more verbose to accomplish this task without Lodash.\n","src":null,"test":""},{"name":"stubString","manifest":{"fnSignature":"_.stubString()","lodashLink":"https://lodash.com/docs/4.17.15#stubString","summary":"This method returns an empty string."},"description":"```javascript\n() => ''\n```\n\nThe `_.stubString()` method was created before arrow function syntax was standard, which meant it used to be a lot more verbose to accomplish this task without Lodash.\n","src":null,"test":""},{"name":"stubTrue","manifest":{"fnSignature":"_.stubTrue()","lodashLink":"https://lodash.com/docs/4.17.15#stubTrue","summary":"This method returns `true`."},"description":"```javascript\n() => true\n```\n\nThe `_.stubTrue()` method was created before arrow function syntax was standard, which meant it used to be a lot more verbose to accomplish this task without Lodash.\n","src":null,"test":""},{"name":"times","manifest":{"fnSignature":"_.times(n, iteratee)","lodashLink":"https://lodash.com/docs/4.17.15#times","summary":"Invokes the iteratee `n` times, returning an array of the results of each invocation."},"description":"```javascript\nArray.from({ length: n }, (_, i) => iteratee(i))\n\n// Concrete example:\nArray.from({ length: 5 }, (_, i) => i * 10) // => [0, 10, 20, 30, 40]\n```\n\nHow it works: `Array.from()` expects an array-like (or an iterable) as the first argument and a mapping function as the second. `{ length: n }` is a valid array-like object that is of length `n` and has no elements in it. The mapping function receives, as the second argument, the current item number geing generated.\n\nHere's another way to accomplishing the same thing in a slightly different style:\n\n```javascript\nnew Array(n).fill().map((_, i) => iteratee(i)) // => [1, 2, 3, 4, 5]\n```\n\n`new Array(n)` creates array holes, which are an emptiness state that is different from `undefined` and `null`, that have an inconsistent iteration behavior - some array methods treat holes like `undefined` and others will skip over them entirely. Because of this, it is generally advisable to avoid array holes and `new Array(n)`. The use of `.fill()` right after `new Array(n)` will cause the array holes to immediately be plugged with `undefined`, fixing the problem. If you want to be strict about avoiding array holes, then you may want to avoid this solution, preferring to instead use the `Array.from()` solution. Alternatively, you may see `new Array(n).fill()` as an acceptable exception to the \"avoid array holes\" guidelines and be ok with this solution.\n","src":null,"test":""},{"name":"uniqueId","manifest":{"fnSignature":"_.uniqueId(prefix?)","lodashLink":"https://lodash.com/docs/4.17.15#uniqueId","summary":"Generates a unique ID. If prefix is given, the ID is appended to it."},"description":"```javascript\nlet nextId = 1;\nfunction uniqueId(prefix = '') {\n  return prefix + String(nextId++);\n}\n```\n","src":null,"test":""}]}]