[{"categoryHeading":"Array","entries":[{"name":"chunk","manifest":{"fnSignature":"_.chunk(array, size?)","lodashLink":"https://lodash.com/docs/4.17.15#chunk","summaryHtml":"<p>Creates an array of elements split into groups the length of <code>size</code>. If <code>array</code> can't be split evenly, the final chunk will be the remaining elements.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function chunk(array, size = 1) {\n  const result = [];\n  for (let i = 0; i &lt; array.length; i += size) {\n    result.push(array.slice(i, i + size));\n  }\n  return result;\n}\n</code></pre>","src":null,"test":""},{"name":"compact","manifest":{"fnSignature":"_.compact(array)","lodashLink":"https://lodash.com/docs/4.17.15#compact","summaryHtml":"<p>Creates an array with all falsey values removed. The values <code>false</code>, <code>null</code>, <code>0</code>, <code>\"\"</code>, <code>undefined</code>, and <code>NaN</code> are falsey.</p>"},"descriptionHtml":"<p>All of these solutions are equivalent and commonly used in the wild. Pick the one you find to be the most readable.</p>\n<pre><code class=\"javascript language-javascript\">array.filter(value =&gt; !!value)\n\narray.filter(value =&gt; value)\n\narray.filter(Boolean)\n</code></pre>\n<p>That being said, I would discourage the use of the last option out of principle. If the JavaScript committee were to ever add additional, optional parameters to <code>Boolean</code> like they often do with many other functions, it could cause your code to break, because <code>array.filter()</code> will pass in an index as a second parameter. In practice, so many people have used this specific <code>array.filter(Boolean)</code> trick that they wouldn't be able to do such a change without breaking existing webpages, but it's unfortunate that we've limited their ability to extend their language based on how we've programmed. In general, it is good to avoid doing anything that causes extra arguments to be passed into someone else's function.</p>","src":null,"test":""},{"name":"concat","manifest":{"fnSignature":"_.concat(array, ...values)","lodashLink":"https://lodash.com/docs/4.17.15#concat","summaryHtml":"<p>Creates a new array concatenating <code>array</code> with any additional arrays and/or values.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">const result = [...array1, ...array2, ...array3];\n</code></pre>\n<p>This solution above only works on arrays and other iterables. If some of your values might not be arrays, you can use the native <code>.concat()</code> method instead.</p>\n<pre><code class=\"javascript language-javascript\">const array1 = [1, 2, 3];\nconst value1 = 4;\nconst array2 = [5, 6, 7];\n\nconst result = array1.concat(value1, array2);\n\n// Expected output: [1, 2, 3, 4, 5, 6, 7]\n</code></pre>","src":null,"test":""},{"name":"difference","manifest":{"fnSignature":"_.difference(array, values?)","lodashLink":"https://lodash.com/docs/4.17.15#difference","summaryHtml":"<p>Creates an array of <code>array</code> values not included in the other given arrays using <code>SameValueZero</code> for equality comparisons. The order and references of result values are determined by the first array.</p>"},"descriptionHtml":"<p>To subtract everything in array2 from array1, use the following:</p>\n<pre><code class=\"javascript language-javascript\">array1.filter(x =&gt; !array2.includes(x));\n</code></pre>\n<p>Remember that <code>.includes()</code> has an <code>O(n)</code> lookup time. If you're dealing with larger arrays, make sure to convert the target array into a set first (a set's <code>.has()</code> method has <code>O(1)</code> lookup time).</p>\n<pre><code class=\"javascript language-javascript\">const set2 = new Set(array2);\nconst result = array1.filter(x =&gt; !set2.has(x));\n</code></pre>\n<p>If you don't care about preserving element order or allowing duplicates, perhaps it would be better to use sets from the start and take advantage of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/difference\">the built-in <code>set.difference()</code> function</a>.</p>\n<p>Both <code>array.includes()</code> and sets use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality\">the SameValueZero comparison algorithm</a> under-the-hood as well, just like Lodash's <code>_.difference()</code>.</p>","src":null,"test":""},{"name":"differenceBy","manifest":{"fnSignature":"_.differenceBy(array, values?, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#differenceBy","summaryHtml":"<p>This method is like <code>_.difference</code> except that it accepts <code>iteratee</code> which is invoked for each element of <code>array</code> and <code>values</code> to generate the criterion by which they're compared. The order and references of result values are determined by the first array.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function differenceBy(array, values, iteratee) {\n  const transformedValues = new Set(values.map(x =&gt; iteratee(x)));\n  return array.filter(x =&gt; !transformedValues.has(iteratee(x)));\n}\n</code></pre>","src":null,"test":""},{"name":"differenceWith","manifest":{"fnSignature":"_.differenceWith(array, values?, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#differenceWith","summaryHtml":"<p>This method is like <code>_.difference</code> except that it accepts <code>comparator</code> which is invoked to compare elements of <code>array</code> to <code>values</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function differenceWith(array, values, comparator) {\n  return array.filter(x =&gt; !values.some(y =&gt; comparator(x, y)));\n}\n</code></pre>","src":null,"test":""},{"name":"drop","manifest":{"fnSignature":"_.drop(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#drop","summaryHtml":"<p>Creates a slice of <code>array</code> with <code>n</code> elements dropped from the beginning.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array.slice(n)\n</code></pre>","src":null,"test":""},{"name":"dropRight","manifest":{"fnSignature":"_.dropRight(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#dropRight","summaryHtml":"<p>Creates a slice of <code>array</code> with <code>n</code> elements dropped from the end.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array.slice(0, -n)\n</code></pre>\n<p>You do have to watch out for the zero case. <code>_.dropRight(0)</code> will return the whole array, while, <code>array.slice(0, -0)</code> will return an empty array.</p>","src":null,"test":""},{"name":"dropRightWhile","manifest":{"fnSignature":"_.dropRightWhile(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#dropRightWhile","summaryHtml":"<p>Creates a slice of <code>array</code> excluding elements dropped from the end. Elements are dropped until <code>predicate</code> returns falsey.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function dropRightWhile(array, predicate) {\n  const index = array.findLastIndex((...args) =&gt; !predicate(...args));\n  if (index === -1) {\n    return [];\n  }\n\n  return array.slice(0, index + 1);\n}\n</code></pre>","src":null,"test":""},{"name":"dropWhile","manifest":{"fnSignature":"_.dropWhile(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#dropWhile","summaryHtml":"<p>Creates a slice of <code>array</code> excluding elements dropped from the beginning. Elements are dropped until <code>predicate</code> returns falsey.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function dropWhile(array, predicate) {\n  const index = array.findIndex((...args) =&gt; !predicate(...args));\n  if (index === -1) {\n    return [];\n  }\n\n  return array.slice(index);\n}\n</code></pre>","src":null,"test":""},{"name":"fill","manifest":{"fnSignature":"_.fill(array, value, start?, end?)","lodashLink":"https://lodash.com/docs/4.17.15#fill","summaryHtml":"<p>Fills elements of <code>array</code> with <code>value</code> from <code>start</code> up to, but not including, <code>end</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array.fill(value, start, end);\n</code></pre>\n<p>The <code>start</code> and <code>end</code> parameters are optional.</p>","src":null,"test":""},{"name":"findIndex","manifest":{"fnSignature":"_.findIndex(array, predicate?, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#findIndex","summaryHtml":"<p>This method is like <code>_.find</code> except that it returns the index of the first element <code>predicate</code> returns truthy for instead of the element itself.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array.findIndex(predicate)\n</code></pre>\n<p>If you need to start from a particular index, a simple solution is to check which index you're at inside your predicate. In this example, we'll look for the first non-null element that exists at index 5 or greater.</p>\n<pre><code class=\"javascript language-javascript\">array.findIndex((value, i) =&gt; i &gt;= 5 &amp;&amp; value !== null)\n</code></pre>\n<p>If you need to start from a particular index, and you're dealing with larger arrays, you may just need to build your own <code>findIndex</code> function from a simple for loop, in order to help with performance.</p>","src":null,"test":""},{"name":"findLastIndex","manifest":{"fnSignature":"_.findLastIndex(array, predicate?, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#findLastIndex","summaryHtml":"<p>This method is like <code>_.findIndex</code> except that it iterates over elements of <code>collection</code> from right to left.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array.findLastIndex(predicate)\n</code></pre>\n<p>If you need to start from a particular index, a simple solution is to check which index you're at inside your predicate. In this example, we'll look for the first non-null element that exists at index 5 or earlier.</p>\n<pre><code class=\"javascript language-javascript\">array.findLastIndex((value, i) =&gt; i &lt;= 5 &amp;&amp; value !== null)\n</code></pre>\n<p>If you need to start from a particular index, and you're dealing with larger arrays, you may just need to build your own <code>findLastIndex</code> function from a simple for loop, in order to help with performance.</p>","src":null,"test":""},{"name":"flatten","manifest":{"fnSignature":"_.flatten(array)","lodashLink":"https://lodash.com/docs/4.17.15#flatten","summaryHtml":"<p>Flattens <code>array</code> a single level deep.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array.flat()\n</code></pre>","src":null,"test":""},{"name":"flattenDeep","manifest":{"fnSignature":"_.flattenDeep(array)","lodashLink":"https://lodash.com/docs/4.17.15#flattenDeep","summaryHtml":"<p>Recursively flattens <code>array</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array.flat(Infinity)\n</code></pre>","src":null,"test":""},{"name":"flattenDepth","manifest":{"fnSignature":"_.flattenDepth(array, depth?)","lodashLink":"https://lodash.com/docs/4.17.15#flattenDeep","summaryHtml":"<p>Recursively flatten <code>array</code> up to <code>depth</code> times.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array.flat(depth)\n</code></pre>","src":null,"test":""},{"name":"fromPairs","manifest":{"fnSignature":"_.fromPairs(pairs)","lodashLink":"https://lodash.com/docs/4.17.15#fromPairs","summaryHtml":"<p>The inverse of <code>_.toPairs</code>; this method returns an object composed from key-value <code>pairs</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">Object.fromEntries(pairs)\n</code></pre>","src":null,"test":""},{"name":"head","manifest":{"fnSignature":"_.head(array)","lodashLink":"https://lodash.com/docs/4.17.15#head","summaryHtml":"<p>Gets the first element of <code>array</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array[0]\n</code></pre>","src":null,"test":""},{"name":"indexOf","manifest":{"fnSignature":"_.indexOf(array, value, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#indexOf","summaryHtml":"<p>Gets the index at which the first occurrence of <code>value</code> is found in <code>array</code> using <code>SameValueZero</code> for equality comparisons. If <code>fromIndex</code> is negative, it's used as the offset from the end of array.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array.findIndex(x =&gt; x === value)\n</code></pre>\n<p>If you need to start from a particular index, a simple solution is to check which index you're at inside your predicate. In this example, we'll look for the index of the first <code>42</code> that exists at index 5 or greater.</p>\n<pre><code class=\"javascript language-javascript\">array.findIndex((value, i) =&gt; i &gt;= 5 &amp;&amp; value === 42)\n</code></pre>\n<p>If you need to start from a particular index, and you're dealing with larger arrays, you may just need to build your own <code>findIndex</code> function using a simple for loop, in order to help with performance.</p>\n<p>If you wish to perform comparisons using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality\">the SameValueZero algorithm</a>, similar to how Lodash does it, you can use this helper function:</p>\n<pre><code class=\"javascript language-javascript\">function sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) &amp;&amp; Number.isNaN(y));\n}\n</code></pre>","src":null,"test":""},{"name":"initial","manifest":{"fnSignature":"_.initial(array)","lodashLink":"https://lodash.com/docs/4.17.15#initial","summaryHtml":"<p>Gets all but the last element of <code>array</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array.slice(0, -1)\n</code></pre>","src":null,"test":""},{"name":"intersection","manifest":{"fnSignature":"_.intersection(...arrays)","lodashLink":"https://lodash.com/docs/4.17.15#intersection","summaryHtml":"<p>Creates an array of unique values that are included in all given arrays using <code>SameValueZero</code> for equality comparisons.</p>"},"descriptionHtml":"<p>To take the intersection of array1 and array2, use the following:</p>\n<pre><code class=\"javascript language-javascript\">array1.filter(x =&gt; array2.includes(x))\n</code></pre>\n<p>If you also wish to remove duplicate elements from the final result, the same way <code>_.intersection()</code> does, you can use a set, like so:</p>\n<pre><code class=\"javascript language-javascript\">const resultWithDuplicates = array1.filter(x =&gt; array2.includes(x));\nconst resultWithoutDuplicates = [...new Set(resultWithDuplicates)];\n</code></pre>\n<p>Remember that <code>.includes()</code> has an <code>O(n)</code> lookup time. If you're dealing with larger arrays, make sure to convert the second array into a set (a set's <code>.has()</code> method has <code>O(1)</code> lookup time).</p>\n<pre><code class=\"javascript language-javascript\">const set2 = new Set(array2);\nconst resultWithDuplicates = array1.filter(x =&gt; set2.has(x));\n</code></pre>\n<p>If you don't care about preserving element order or allowing duplicates, perhaps it would be better to use sets from the start and take advantage of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/intersection\">the built-in <code>set.intersection()</code> function</a>.</p>\n<p>Both <code>array.includes()</code> and sets use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality\">the SameValueZero comparison algorithm</a> under-the-hood as well, just like Lodash's <code>_.intersection()</code>.</p>","src":null,"test":""},{"name":"intersectionBy","manifest":{"fnSignature":"_.intersectionBy(...arrays, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#intersectionBy","summaryHtml":"<p>This method is like <code>_.intersection</code> except that it accepts <code>iteratee</code> which is invoked for each element of each <code>arrays</code> to generate the criterion by which they're compared.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function intersectionBy(array1, array2, iteratee = x =&gt; x) {\n  const result = [];\n  const resultTransformed = new Set();\n  const array2Transformed = new Set(array2.map(x =&gt; iteratee(x)));\n  for (const element of array1) {\n    const transformedElement = iteratee(element);\n    const isInIntersection = (\n      !resultTransformed.has(transformedElement) &amp;&amp;\n      array2Transformed.has(transformedElement)\n    );\n\n    if (isInIntersection) {\n      result.push(element);\n      resultTransformed.add(transformedElement);\n    }\n  }\n\n  return result;\n}\n</code></pre>\n<p>If you know that <code>array1</code> doesn't contain duplicate elements, or you don't care if duplicate elements from <code>array1</code> end up in the final result, then this implementation will achieve the same effect:</p>\n<pre><code class=\"javascript language-javascript\">function intersectionBy(array1, array2, iteratee = x =&gt; x) {\n  const array2Transformed = new Set(array2.map(x =&gt; iteratee(x)));\n  return array1.filter(x =&gt; array2Transformed.has(iteratee(x)));\n}\n</code></pre>","src":null,"test":""},{"name":"intersectionWith","manifest":{"fnSignature":"_.intersectionWith(...arrays, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#intersectionWith","summaryHtml":"<p>This method is like <code>_.intersection</code> except that it accepts <code>comparator</code> which is invoked to compare elements of <code>arrays</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function intersectionWith(array1, array2, comparator) {\n  const result = [];\n  for (const element of array1) {\n    const isInIntersection = (\n      !result.some(x =&gt; comparator(x, element)) &amp;&amp;\n      array2.some(x =&gt; comparator(x, element))\n    );\n\n    if (isInIntersection) {\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n</code></pre>\n<p>If you know that <code>array1</code> doesn't contain duplicate elements, or you don't care if duplicate elements from <code>array1</code> end up in the final result, then this implementation will achieve the same effect:</p>\n<pre><code class=\"javascript language-javascript\">function intersectionWith(array1, array2, comparator) {\n  return array1.filter(x =&gt; array2.some(y =&gt; comparator(x, y)));\n}\n</code></pre>","src":null,"test":""},{"name":"join","manifest":{"fnSignature":"_.join(array, separator?)","lodashLink":"https://lodash.com/docs/4.17.15#join","summaryHtml":"<p>Converts all elements in <code>array</code> into a string separated by <code>separator</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array.join(separator)\n</code></pre>","src":null,"test":""},{"name":"last","manifest":{"fnSignature":"_.last(array)","lodashLink":"https://lodash.com/docs/4.17.15#last","summaryHtml":"<p>Gets the last element of <code>array</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array.at(-1)\n</code></pre>","src":null,"test":""},{"name":"lastIndexOf","manifest":{"fnSignature":"_.lastIndexOf(array, value, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#lastIndexOf","summaryHtml":"<p>This method is like <code>_.indexOf</code> except that it iterates over elements of <code>array</code> from right to left.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array.findLastIndex(x =&gt; x === value)\n</code></pre>\n<p>If you need to start from a particular index, a simple solution is to check which index you're at inside your predicate. In this example, we'll look for the index of the last <code>42</code> that exists at index 5 or lower.</p>\n<pre><code class=\"javascript language-javascript\">array.findLastIndex((value, i) =&gt; i &lt;= 5 &amp;&amp; value === 42)\n</code></pre>\n<p>If you need to start from a particular index, and you're dealing with larger arrays, you may just need to build your own <code>findLastIndex</code> function using a simple for loop, in order to help with performance.</p>\n<p>If you wish to perform comparisons using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality\">the SameValueZero algorithm</a>, similar to how Lodash does it, you can use this helper function:</p>\n<pre><code class=\"javascript language-javascript\">function sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) &amp;&amp; Number.isNaN(y));\n}\n</code></pre>","src":null,"test":""},{"name":"nth","manifest":{"fnSignature":"_.nth(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#nth","summaryHtml":"<p>Gets the element at index <code>n</code> of <code>array</code>. If <code>n</code> is negative, the nth element from the end is returned.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array[n]\n</code></pre>\n<p>Or, if you need support for negative indices:</p>\n<pre><code class=\"javascript language-javascript\">array.at(n)\n</code></pre>","src":null,"test":""},{"name":"pull","manifest":{"fnSignature":"_.pull(array, ...values)","lodashLink":"https://lodash.com/docs/4.17.15#pull","summaryHtml":"<p>Removes all given values from <code>array</code> using <code>SameValueZero</code> for equality comparisons. Note: Unlike <code>_.without</code>, this method mutates <code>array</code>.</p>"},"descriptionHtml":"<p>If you're not in a very performance sensitive area of your codebase or dealing with large arrays, consider just using the native <code>.filter()</code> function instead which returns a copy instead of mutating the original. If you are worried about performance, you can use the following <code>filterInPlace()</code> helper to achieve the desired result in <code>O(n)</code> time.</p>\n<pre><code class=\"javascript language-javascript\">function filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex &lt; array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\n// Pull everything out from `array` that equals `targetValue`.\nconst result = filterInPlace(array, x =&gt; x === targetValue);\n</code></pre>\n<p>If you wish to perform comparisons using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality\">the SameValueZero algorithm</a>, similar to how Lodash does it, you can use this helper function:</p>\n<pre><code class=\"javascript language-javascript\">function sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) &amp;&amp; Number.isNaN(y));\n}\n</code></pre>\n<p>See <a href=\"#!/nolodash/pullAll\">the entry for <code>_.pullAll()</code></a> if you have multiple items you wish to pull at once.</p>","src":null,"test":""},{"name":"pullAll","manifest":{"fnSignature":"_.pullAll(array, values)","lodashLink":"https://lodash.com/docs/4.17.15#pullAll","summaryHtml":"<p>This method is like <code>_.pull</code> except that it accepts an array of values to remove.</p>"},"descriptionHtml":"<p>If you're not in a very performance sensitive area of your codebase or dealing with large arrays, consider just using the native <code>.filter()</code> function instead which returns a copy instead of mutating the original. If you are worried about performance, you can use the following <code>filterInPlace()</code> helper to achieve the desired result in <code>O(n)</code> time.</p>\n<pre><code class=\"javascript language-javascript\">function filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex &lt; array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\n// Pull everything in the `values` array from `array`.\nconst result = filterInPlace(array, x =&gt; values.include(x));\n</code></pre>\n<p>Remember that the <code>values.includes()</code> used at the end also has an <code>O(n)</code> lookup time. If you're dealing with a larger <code>values</code> array, make sure to convert it into a set first (a set's <code>.has()</code> method has <code>O(1)</code> lookup time).</p>\n<p>Both <code>array.includes()</code> and <code>set.has()</code> use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality\">the SameValueZero comparison algorithm</a> under-the-hood as well, just like Lodash's <code>_.pullAll()</code>.</p>","src":null,"test":""},{"name":"pullAllBy","manifest":{"fnSignature":"_.pullAllBy(array, values, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#pullAllBy","summaryHtml":"<p>This method is like <code>_.pullAll</code> except that it accepts <code>iteratee</code> which is invoked for each element of <code>array</code> and <code>values</code> to generate the criterion by which they're compared.</p>"},"descriptionHtml":"<p>If you're not in a very performance sensitive area of your codebase or dealing with large arrays, consider just using the native <code>.filter()</code> function instead which returns a copy instead of mutating the original. If you are worried about performance, you can use the following <code>filterInPlace()</code> helper to achieve the desired result in <code>O(n)</code> time.</p>\n<pre><code class=\"javascript language-javascript\">function filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex &lt; array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\nfunction pullAllBy(array, values, iteratee) {\n  const transformedValues = new Set(values.map(x =&gt; iteratee(x)));\n  filterInPlace(array, x =&gt; !transformedValues.has(iteratee(x)));\n}\n</code></pre>","src":null,"test":""},{"name":"pullAllWith","manifest":{"fnSignature":"_.pullAllWith(array, values, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#pullAllWith","summaryHtml":"<p>This method is like <code>_.pullAll</code> except that it accepts <code>comparator</code> which is invoked to compare elements of <code>array</code> to <code>values</code>.</p>"},"descriptionHtml":"<p>If you're not in a very performance sensitive area of your codebase or dealing with large arrays, consider just using the native <code>.filter()</code> function instead which returns a copy instead of mutating the original. If you are worried about performance, you can use the following <code>filterInPlace()</code> helper to achieve the desired result in <code>O(n)</code> time.</p>\n<pre><code class=\"javascript language-javascript\">function filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex &lt; array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\nfunction pullAllWith(array, values, comparator) {\n  filterInPlace(array, x =&gt; !values.some(y =&gt; comparator(x, y)));\n}\n</code></pre>","src":null,"test":""},{"name":"pullAt","manifest":{"fnSignature":"_.pullAt(array, indexes?)","lodashLink":"https://lodash.com/docs/4.17.15#pullAt","summaryHtml":"<p>Removes elements from <code>array</code> corresponding to <code>indexes</code> and returns an array of removed elements.</p>"},"descriptionHtml":"<p>If you're not in a very performance sensitive area of your codebase or dealing with large arrays, consider just using the native <code>.filter()</code> function instead which returns a copy instead of mutating the original. If you are worried about performance, you can use the following <code>filterInPlace()</code> helper to achieve the desired result in <code>O(n)</code> time.</p>\n<pre><code class=\"javascript language-javascript\">function filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex &lt; array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\nfunction pullAt(array, indexes_) {\n  const pulled = indexes_.map(i =&gt; array[i]);\n  const indexes = new Set(indexes_);\n  filterInPlace(array, (_, i) =&gt; !indexes.has(i));\n  return pulled;\n}\n</code></pre>","src":null,"test":""},{"name":"remove","manifest":{"fnSignature":"_.remove(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#remove","summaryHtml":"<p>Removes all elements from <code>array</code> that <code>predicate</code> returns truthy for and returns an array of the removed elements.</p>"},"descriptionHtml":"<p>If you're not in a very performance sensitive area of your codebase or dealing with large arrays, consider just using the native <code>.filter()</code> function instead which returns a copy instead of mutating the original. If you are worried about performance, you can use the following <code>remove()</code> helper to achieve the desired result in <code>O(n)</code> time.</p>\n<pre><code class=\"javascript language-javascript\">function remove(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex &lt; array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n</code></pre>","src":null,"test":""},{"name":"reverse","manifest":{"fnSignature":"_.reverse(array)","lodashLink":"https://lodash.com/docs/4.17.15#reverse","summaryHtml":"<p>Reverses <code>array</code> so that the first element becomes the last, the second element becomes the second to last, and so on.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array.reverse();\n</code></pre>","src":null,"test":""},{"name":"slice","manifest":{"fnSignature":"_.slice(array, start?, end?)","lodashLink":"https://lodash.com/docs/4.17.15#slice","summaryHtml":"<p>Creates a slice of <code>array</code> from <code>start</code> up to, but not including, <code>end</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array.slice(start, end)\n</code></pre>\n<p>One benefit of Lodash's implementation of <code>.slice()</code>, is that it'll always return a dense array (as opposed to a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#sparse_arrays\">sparse one</a>). The same behavior can be achieved in plain JavaScript by simply spreading the array into another one.</p>\n<!--eslint-disable no-sparse-arrays -->\n<pre><code class=\"javascript language-javascript\">const sparseArray = [2,,3,,4]; // =&gt; [2, &lt;empty&gt;, 3, &lt;empty&gt;, 4]\nconst denseArray = [...sparseArray]; // =&gt; [2, undefined, 3, undefined, 4]\nconsole.log(denseArray.slice(1, 3)); // =&gt; [undefined, 3]\n</code></pre>\n<p>Note, however, that Lodash is providing this behavior, mostly because it makes their <code>.slice()</code> implementation more consistent with how newer JavaScript array methods treat sparse arrays - by pretending the holes are the same as <code>undefined</code> values. In practice, such a feature shouldn't make a difference in your codebase, as it's generally considered bad practice to create or pass around sparse arrays. If you're a library developer who may be receiving arbitrary user input, simply treat arguments that could potentially be sparse arrays the same way you would treat any other kind of bad input the end-user gives you. If you don't do any data validation, then don't worry about it - a sparse array would result in undefined behavior, the same way any other bad input would. If you do up-front data validation, you can choose to add the detection of sparse arrays as an additional up-front check.</p>","src":null,"test":""},{"name":"sortedIndex","manifest":{"fnSignature":"_.sortedIndex(array, value)","lodashLink":"https://lodash.com/docs/4.17.15#sortedIndex","summaryHtml":"<p>Uses a binary search to determine the lowest index at which <code>value</code> should be inserted into <code>array</code> in order to maintain its sort order.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function sortedIndex(array, value, _range) {\n  const [low, high] = _range ?? [0, array.length];\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = value &lt;= array[midPoint]\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedIndex(array, value, newRange);\n}\n</code></pre>","src":null,"test":""},{"name":"sortedIndexBy","manifest":{"fnSignature":"_.sortedIndexBy(array, value, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#sortedIndexBy","summaryHtml":"<p>This method is like <code>_.sortedIndex</code> except that it accepts <code>iteratee</code> which is invoked for <code>value</code> and each element of <code>array</code> to compute their sort ranking.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function sortedIndexBy(array, value, iteratee, _recurseOpts) {\n  _recurseOpts ??= {\n    range: [0, array.length],\n    transformedValue: iteratee(value),\n  };\n\n  const transformedValue = _recurseOpts.transformedValue;\n  const [low, high] = _recurseOpts.range;\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = transformedValue &lt;= iteratee(array[midPoint])\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedIndexBy(array, value, iteratee, { transformedValue, range: newRange });\n}\n</code></pre>","src":null,"test":""},{"name":"sortedIndexOf","manifest":{"fnSignature":"_.sortedIndexOf(array, value)","lodashLink":"https://lodash.com/docs/4.17.15#sortedIndexOf","summaryHtml":"<p>This method is like <code>_.indexOf</code> except that it performs a binary search on a sorted <code>array</code>.</p>"},"descriptionHtml":"<p>We will start with <a href=\"#!/nolodash/sortedIndex\">a plain JavaScript implementation of <code>_.sortedIndex()</code></a> to help define <code>sortedIndexOf()</code>.</p>\n<pre><code class=\"javascript language-javascript\">function sortedIndex(array, value, _range) {\n  const [low, high] = _range ?? [0, array.length];\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = value &lt;= array[midPoint]\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedIndex(array, value, newRange);\n}\n</code></pre>\n<p>We can now implement <code>_.sortedIndexOf()</code> like this:</p>\n<pre><code class=\"javascript language-javascript\">function sortedIndexOf(array, value) {\n  const index = sortedIndex(array, value);\n  return array[index] === value ? index : -1;\n}\n</code></pre>","src":null,"test":""},{"name":"sortedLastIndex","manifest":{"fnSignature":"_.sortedLastIndex(array, value)","lodashLink":"https://lodash.com/docs/4.17.15#sortedLastIndex","summaryHtml":"<p>This method is like <code>_.sortedIndex</code> except that it returns the highest index at which <code>value</code> should be inserted into <code>array</code> in order to maintain its sort order.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function sortedLastIndex(array, value, _range) {\n  const [low, high] = _range ?? [0, array.length];\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = value &lt; array[midPoint]\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedLastIndex(array, value, newRange);\n}\n</code></pre>","src":null,"test":""},{"name":"sortedLastIndexBy","manifest":{"fnSignature":"_.sortedLastIndexBy(array, value, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#sortedLastIndexBy","summaryHtml":"<p>This method is like <code>_.sortedLastIndex</code> except that it accepts <code>iteratee</code> which is invoked for value and each element of array to compute their sort ranking.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function sortedLastIndexBy(array, value, iteratee, _recurseOpts) {\n  _recurseOpts ??= {\n    range: [0, array.length],\n    transformedValue: iteratee(value),\n  };\n\n  const transformedValue = _recurseOpts.transformedValue;\n  const [low, high] = _recurseOpts.range;\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = transformedValue &lt; iteratee(array[midPoint])\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedLastIndexBy(array, value, iteratee, { transformedValue, range: newRange });\n}\n</code></pre>","src":null,"test":""},{"name":"sortedLastIndexOf","manifest":{"fnSignature":"_.sortedLastIndexOf(array, value)","lodashLink":"https://lodash.com/docs/4.17.15#sortedLastIndexOf","summaryHtml":"<p>This method is like <code>_.lastIndexOf</code> except that it performs a binary search on a sorted <code>array</code>.</p>"},"descriptionHtml":"<p>We will start with <a href=\"#!/nolodash/sortedLastIndex\">a plain JavaScript implementation of <code>_.sortedLastIndex()</code></a> to help define <code>sortedLastIndexOf()</code>.</p>\n<pre><code class=\"javascript language-javascript\">function sortedLastIndex(array, value, _range) {\n  const [low, high] = _range ?? [0, array.length];\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = value &lt; array[midPoint]\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedLastIndex(array, value, newRange);\n}\n</code></pre>\n<p>We can now implement <code>_.sortedLastIndexOf()</code> like this:</p>\n<pre><code class=\"javascript language-javascript\">function sortedLastIndexOf(array, value) {\n  const index = sortedLastIndex(array, value) - 1;\n  return index &gt; -1 &amp;&amp; array[index] === value ? index : -1;\n}\n</code></pre>","src":null,"test":""},{"name":"sortedUniq","manifest":{"fnSignature":"_.sortedUniq(array)","lodashLink":"https://lodash.com/docs/4.17.15#sortedUniq","summaryHtml":"<p>This method is like <code>_.uniq</code> except that it's designed and optimized for sorted arrays.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function sortedUniq(array) {\n  if (array.length === 0) {\n    return [];\n  }\n\n  const result = [array[0]];\n  for (const value of array) {\n    if (result[result.length - 1] !== value) {\n      result.push(value);\n    }\n  }\n\n  return result;\n}\n</code></pre>\n<p><a href=\"https://gist.github.com/theScottyJam/8424183e49f4555b60752b21f1076129\">Some basic benchmarks</a> shows that the processing time per item improves as the number of repeated items increase. If you're not dealing with large arrays, or arrays with many repeated items, then using the simpler <code>[...new Set(array)]</code> solution should be sufficient.</p>","src":null,"test":""},{"name":"sortedUniqBy","manifest":{"fnSignature":"_.sortedUniqBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#sortedUniqBy","summaryHtml":"<p>This method is like <code>_.uniqBy</code> except that it's designed and optimized for sorted arrays.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function sortedUniqBy(array, iteratee) {\n  if (array.length === 0) {\n    return [];\n  }\n\n  let lastTransformedValue = iteratee(array[0]);\n  const result = [array[0]];\n  for (let i = 0; i &lt; array.length; ++i) {\n    const transformedValue = iteratee(array[i]);\n    if (lastTransformedValue !== transformedValue) {\n      result.push(array[i]);\n      lastTransformedValue = transformedValue;\n    }\n  }\n\n  return result;\n}\n</code></pre>","src":null,"test":""},{"name":"tail","manifest":{"fnSignature":"_.tail(array)","lodashLink":"https://lodash.com/docs/4.17.15#tail","summaryHtml":"<p>Gets all but the first element of <code>array</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array.slice(1);\n</code></pre>","src":null,"test":""},{"name":"take","manifest":{"fnSignature":"_.take(array, n)","lodashLink":"https://lodash.com/docs/4.17.15#take","summaryHtml":"<p>Creates a slice of <code>array</code> with <code>n</code> elements taken from the beginning.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array.slice(0, n);\n</code></pre>","src":null,"test":""},{"name":"takeRight","manifest":{"fnSignature":"_.takeRight(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#takeRight","summaryHtml":"<p>Creates a slice of <code>array</code> with <code>n</code> elements taken from the end.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array.slice(-n);\n</code></pre>\n<p>You do have to watch out for the zero case. <code>_.takeRight(0)</code> will return an empty array, while, <code>array.slice(-0)</code> will return the whole array.</p>","src":null,"test":""},{"name":"takeRightWhile","manifest":{"fnSignature":"_.takeRightWhile(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#takeRightWhile","summaryHtml":"<p>Creates a slice of <code>array</code> with elements taken from the end. Elements are taken until <code>predicate</code> returns falsey.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function takeRightWhile(array, predicate) {\n  const index = array.findLastIndex((...args) =&gt; !predicate(...args))\n  if (index === -1) {\n    return array;\n  }\n\n  return array.slice(index + 1);\n}\n</code></pre>","src":null,"test":""},{"name":"takeWhile","manifest":{"fnSignature":"_.takeWhile(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#takeWhile","summaryHtml":"<p>Creates a slice of <code>array</code> with elements taken from the beginning. Elements are taken until <code>predicate</code> returns falsey.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function takeWhile(array, predicate) {\n  const index = array.findIndex((...args) =&gt; !predicate(...args))\n  if (index === -1) {\n    return array;\n  }\n\n  return array.slice(0, index);\n}\n</code></pre>","src":null,"test":""},{"name":"union","manifest":{"fnSignature":"_.union(...arrays)","lodashLink":"https://lodash.com/docs/4.17.15#union","summaryHtml":"<p>Creates an array of unique values, in order, from all given arrays using <code>SameValueZero</code> for equality comparisons.</p>"},"descriptionHtml":"<p>If you have arrays or other iterables:</p>\n<pre><code class=\"javascript language-javascript\">[...new Set([...array1, ...array2])]\n</code></pre>\n<p>If you have sets:</p>\n<pre><code class=\"javascript language-javascript\">set1.union(set2)\n</code></pre>\n<p>Sets internally use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality\">the SameValueZero comparison algorithm</a> under-the-hood, just like Lodash's <code>_.union()</code>.</p>","src":null,"test":""},{"name":"unionBy","manifest":{"fnSignature":"_.unionBy(...arrays, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#unionBy","summaryHtml":"<p>This method is like <code>_.union</code> except that it accepts <code>iteratee</code> which is invoked for each element of each <code>arrays</code> to generate the criterion by which uniqueness is computed.</p>"},"descriptionHtml":"<p>We will start with <a href=\"#!/nolodash/uniqBy\">a plain JavaScript implementation of <code>_.uniqBy()</code></a> to solve this problem.</p>\n<pre><code class=\"javascript language-javascript\">function uniqBy(array, iteratee) {\n  const transformedResults = new Set();\n  const result = [];\n  for (const element of array) {\n    const transformedElement = iteratee(element);\n    if (!transformedResults.has(transformedElement)) {\n      transformedResults.add(transformedElement);\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n</code></pre>\n<p>We can now mimic <code>_.unionBy()</code> like this:</p>\n<pre><code class=\"javascript language-javascript\">// Merge the given arrays, then filter out duplicates.\n// This end-effect will be the union of these two arrays,\n// using `iteratee` to decide equivalence.\nuniqBy([...array1, ...array2], iteratee)\n</code></pre>","src":null,"test":""},{"name":"unionWith","manifest":{"fnSignature":"_.unionWith(array, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#unionWith","summaryHtml":"<p>This method is like <code>_.union</code> except that it accepts <code>comparator</code> which is invoked to compare elements of <code>arrays</code>.</p>"},"descriptionHtml":"<p>We will start with <a href=\"#!/nolodash/uniqWith\">a plain JavaScript implementation of <code>_.uniqWith()</code></a> to solve this problem.</p>\n<pre><code class=\"javascript language-javascript\">function uniqWith(array, comparator) {\n  const result = [];\n  for (const element of array) {\n    if (result.every(x =&gt; !comparator(x, element))) {\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n</code></pre>\n<p>We can now mimic <code>_.unionWith()</code> like this:</p>\n<pre><code class=\"javascript language-javascript\">// Merge the given arrays, then filter out duplicates.\n// This end-effect will be the union of these two arrays,\n// using `comparator` to decide equivalence.\nuniqWith([...array1, ...array2], comparator)\n</code></pre>","src":null,"test":""},{"name":"uniq","manifest":{"fnSignature":"_.uniq(array)","lodashLink":"https://lodash.com/docs/4.17.15#uniq","summaryHtml":"<p>Creates a duplicate-free version of an array, using <code>SameValueZero</code> for equality comparisons.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">[...new Set(array)]\n</code></pre>\n<p>Sets internally use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality\">the SameValueZero comparison algorithm</a> under-the-hood, just like Lodash's <code>_.uniq()</code>.</p>","src":null,"test":""},{"name":"uniqBy","manifest":{"fnSignature":"_.uniqBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#uniqBy","summaryHtml":"<p>This method is like <code>_.uniq</code> except that it accepts <code>iteratee</code> which is invoked for each element in array to generate the criterion by which uniqueness is computed.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function uniqBy(array, iteratee) {\n  const transformedResults = new Set();\n  const result = [];\n  for (const element of array) {\n    const transformedElement = iteratee(element);\n    if (!transformedResults.has(transformedElement)) {\n      transformedResults.add(transformedElement);\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n</code></pre>","src":null,"test":""},{"name":"uniqWith","manifest":{"fnSignature":"_.uniqWith(array, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#uniqWith","summaryHtml":"<p>This method is like <code>_.uniq</code> except that it accepts <code>comparator</code> which is invoked to compare elements of <code>array</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function uniqWith(array, comparator) {\n  const result = [];\n  for (const element of array) {\n    if (result.every(x =&gt; !comparator(x, element))) {\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n</code></pre>","src":null,"test":""},{"name":"unzip","manifest":{"fnSignature":"_.unzip(array)","lodashLink":"https://lodash.com/docs/4.17.15#unzip","summaryHtml":"<p>This method is like <code>_.zip</code> except that it accepts an array of grouped elements and creates an array regrouping the elements to their pre-zip configuration.</p>"},"descriptionHtml":"<p><code>_.zip()</code> is actually the inverse of itself, meaning you can use it to unzip the result of <code>_.zip()</code>, like this:</p>\n<pre><code class=\"javascript language-javascript\">const original = [[1, 2, 3], ['A', 'B', 'C']];\nconst zipped = _.zip(...original); // [[1, 'A'], [2, 'B'], [3, 'C']]\nconst unzipped = _.zip(...zipped); // [[1, 2, 3], ['A', 'B', 'C']]\n</code></pre>\n<p>The only difference between <code>_.zip()</code> and <code>_.unzip()</code> is how it accepts parameters.</p>\n<!-- eslint-disable @stylistic/no-multi-spaces -->\n<pre><code class=\"javascript language-javascript\">// With _.zip(), arrays are passed in as separate parameters\n_.zip([1, 2], ['A', 'B'])     // =&gt; [[1, 'A'], [2, 'B']]\n// With _.unzip(), arrays are placed inside a single larger array.\n_.unzip([[1, 2], ['A', 'B']]) // =&gt; [[1, 'A'], [2, 'B']]\n</code></pre>\n<p>This means that the you don't need both <code>zip()</code> and <code>unzip()</code>, you can just use <a href=\"#!/nolodash/zip\">a <code>zip</code> implementation</a> for both use-cases:</p>\n<pre><code class=\"javascript language-javascript\">function zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr =&gt; arr.length));\n  const result = [];\n  for (let i = 0; i &lt; minLength; ++i) {\n    result.push(arrays.map(arr =&gt; arr[i]));\n  }\n\n  return result;\n}\n</code></pre>\n<p>If you want a Lodash-style unzip function, here's how to implement it based off of <code>zip()</code>:</p>\n<pre><code class=\"javascript language-javascript\">function unzip(arrays) {\n  return zip(...arrays);\n}\n</code></pre>","src":null,"test":""},{"name":"unzipWith","manifest":{"fnSignature":"_.unzipWith(array, iteratee)","lodashLink":"https://lodash.com/docs/4.17.15#unzipWith","summaryHtml":"<p>This method is like <code>_.unzip</code> except that it accepts <code>iteratee</code> to specify how regrouped values should be combined.</p>"},"descriptionHtml":"<p>The only difference between <code>_.zipWith()</code> and <code>_.unzipWith()</code> is how it accepts parameters.</p>\n<!-- eslint-disable @stylistic/no-multi-spaces -->\n<pre><code class=\"javascript language-javascript\">// With _.zipWith(), arrays are passed in as separate parameters\n_.zipWith([10, 20], [1, 2], (a, b) =&gt; a + b)     // =&gt; [11, 22]\n// With _.unzipWith(), arrays are placed inside a single larger array.\n_.unzipWith([[10, 20], [1, 2]], (a, b) =&gt; a + b) // =&gt; [11, 22]\n</code></pre>\n<p>This means that the you don't need both <code>zipWith()</code> and <code>unzipWith()</code>, you can just use <a href=\"#!/nolodash/zipWith\">a <code>zipWith()</code> implementation</a> for both use-cases:</p>\n<pre><code class=\"javascript language-javascript\">function zipWith(...args) {\n  const arrays = args.slice(0, -1);\n  const iteratee = args.at(-1);\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr =&gt; arr.length));\n  const result = [];\n  for (let i = 0; i &lt; minLength; ++i) {\n    result.push(iteratee(...arrays.map(arr =&gt; arr[i])));\n  }\n\n  return result;\n}\n</code></pre>\n<p>If you want a Lodash-style unzipWith function, here's how to implement it:</p>\n<pre><code class=\"javascript language-javascript\">function unzipWith(arrays, iteratee) {\n  return zipWith(...arrays, iteratee);\n}\n</code></pre>","src":null,"test":""},{"name":"without","manifest":{"fnSignature":"_.without(array, ...values)","lodashLink":"https://lodash.com/docs/4.17.15#without","summaryHtml":"<p>Creates an array excluding all given values using <code>SameValueZero</code> for equality comparisons.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">array.filter(x =&gt; x !== value)\n</code></pre>\n<p>If you wish to filter out multiple values, look at <a href=\"#!/nolodash/difference\">the plain JavaScript version of <code>_.difference()</code></a>. Both <code>_.difference()</code> and <code>_.without()</code> achieve the same effect, but with slightly different function signatures.</p>\n<p>If you wish to perform comparisons using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality\">the SameValueZero algorithm</a>, similar to how Lodash does it, you can use this helper function:</p>\n<pre><code class=\"javascript language-javascript\">function sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) &amp;&amp; Number.isNaN(y));\n}\n</code></pre>","src":null,"test":""},{"name":"xor","manifest":{"fnSignature":"_.xor(...arrays)","lodashLink":"https://lodash.com/docs/4.17.15#xor","summaryHtml":"<p>Creates an array of unique values that is the symmetric difference of the given arrays.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function xor(array1, array2) {\n  const set1 = new Set(array1);\n  const set2 = new Set(array2);\n  return [\n    ...array1.filter(x =&gt; !set2.has(x)),\n    ...array2.filter(x =&gt; !set1.has(x)),\n  ];\n}\n</code></pre>\n<p>If you don't care about preserving element order or allowing duplicates, perhaps it would be better to use sets from the start and take advantage of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/symmetricDifference\">the built-in <code>set.symmetricDifference()</code> function</a>.</p>","src":null,"test":""},{"name":"xorBy","manifest":{"fnSignature":"_.xorBy(...arrays, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#xorBy","summaryHtml":"<p>This method is like <code>_.xor</code> except that it accepts <code>iteratee</code> which is invoked for each element of each <code>arrays</code> to generate the criterion by which by which they're compared.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function xorBy(array1, array2, iteratee) {\n  const set1 = new Set(array1.map(x =&gt; iteratee(x)));\n  const set2 = new Set(array2.map(x =&gt; iteratee(x)));\n  return [\n    ...array1.filter(x =&gt; !set2.has(iteratee(x))),\n    ...array2.filter(x =&gt; !set1.has(iteratee(x))),\n  ];\n}\n</code></pre>","src":null,"test":""},{"name":"xorWith","manifest":{"fnSignature":"_.xorWith(...arrays, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#xorWith","summaryHtml":"<p>This method is like <code>_.xor</code> except that it accepts <code>comparator</code> which is invoked to compare elements of arrays.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function xorWith(array1, array2, comparator) {\n  return [\n    ...array1.filter(x =&gt; !array2.some(y =&gt; comparator(x, y))),\n    ...array2.filter(x =&gt; !array1.some(y =&gt; comparator(x, y))),\n  ];\n}\n</code></pre>","src":null,"test":""},{"name":"zip","manifest":{"fnSignature":"_.zip(...arrays)","lodashLink":"https://lodash.com/docs/4.17.15#zip","summaryHtml":"<p>Creates an array of grouped elements, the first of which contains the first elements of the given arrays, the second of which contains the second elements of the given arrays, and so on.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr =&gt; arr.length));\n  const result = [];\n  for (let i = 0; i &lt; minLength; ++i) {\n    result.push(arrays.map(arr =&gt; arr[i]));\n  }\n\n  return result;\n}\n</code></pre>","src":null,"test":""},{"name":"zipObject","manifest":{"fnSignature":"_.zipObject(props?, values?)","lodashLink":"https://lodash.com/docs/4.17.15#zipObject","summaryHtml":"<p>This method is like <code>_.fromPairs</code> except that it accepts two arrays, one of property identifiers and one of corresponding values.</p>"},"descriptionHtml":"<p>We will start with <a href=\"#!/nolodash/zip\">a plain JavaScript implementation of <code>_.zip()</code></a>.</p>\n<pre><code class=\"javascript language-javascript\">function zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr =&gt; arr.length));\n  const result = [];\n  for (let i = 0; i &lt; minLength; ++i) {\n    result.push(arrays.map(arr =&gt; arr[i]));\n  }\n\n  return result;\n}\n</code></pre>\n<p>We can now mimic <code>_.zipObject()</code> like this:</p>\n<pre><code class=\"javascript language-javascript\">// First zips the keys and values,\n// then build an object from the zipped entries.\nObject.fromEntries(zip(props, values))\n</code></pre>","src":null,"test":""},{"name":"zipObjectDeep","manifest":{"fnSignature":"_.zipObjectDeep(props?, values?)","lodashLink":"https://lodash.com/docs/4.17.15#zipObjectDeep","summaryHtml":"<p>This method is like <code>_.zipObject</code> except that it supports property paths.</p>"},"descriptionHtml":"<p>It's recommended to avoid this function. Building objects via dynamic string paths may (or may not) be indicative of a deeper issue with how the problem is being approached. But, if you really do need support for this sort of thing, it can be done, with the help of the plain JavaScript implementation of <a href=\"#!/nolodash/set\"><code>_.set()</code></a> and <a href=\"#!/nolodash/zip\"><code>_.zip()</code></a>.</p>\n<pre><code class=\"javascript language-javascript\">function set(object, path, value) {\n  if (typeof path === 'string') {\n    const isQuoted = str =&gt; str[0] === '\"' &amp;&amp; str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x =&gt; x)\n      .map(x =&gt; !isNaN(Number(x)) ? Number(x) : x)\n      .map(x =&gt; typeof x === 'string' &amp;&amp; isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = value;\n    return object;\n  }\n\n  if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  set(object[head], tail, value);\n  return object;\n}\n\nfunction zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr =&gt; arr.length));\n  const result = [];\n  for (let i = 0; i &lt; minLength; ++i) {\n    result.push(arrays.map(arr =&gt; arr[i]));\n  }\n\n  return result;\n}\n</code></pre>\n<p>Now we can define <code>zipObjectDeep()</code> as follows:</p>\n<pre><code class=\"javascript language-javascript\">function zipObjectDeep(props, values) {\n  const resultObj = {};\n  for (const [path, value] of zip(props, values)) {\n    set(resultObj, path, value);\n  }\n\n  return resultObj;\n}\n</code></pre>\n<p>Note that the support for string paths in the above <code>zipObjectDeep()</code> implementation isn't very robust. It'll take invalid-looking input, such as <code>\"prop1.[prop2\"</code>, ignore the invalid parts, and attempt to work with it anyways. Lodash's <code>_.zipObjectDeep()</code> isn't all that different in this regard.</p>","src":null,"test":""},{"name":"zipWith","manifest":{"fnSignature":"_.zipWith(...arrays, iteratee)","lodashLink":"https://lodash.com/docs/4.17.15#zipWith","summaryHtml":"<p>This method is like <code>_.zip</code> except that it accepts <code>iteratee</code> to specify how grouped values should be combined.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function zipWith(...args) {\n  const arrays = args.slice(0, -1);\n  const iteratee = args.at(-1);\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr =&gt; arr.length));\n  const result = [];\n  for (let i = 0; i &lt; minLength; ++i) {\n    result.push(iteratee(...arrays.map(arr =&gt; arr[i])));\n  }\n\n  return result;\n}\n</code></pre>","src":null,"test":""}]},{"categoryHeading":"Collection","entries":[{"name":"countBy","manifest":{"fnSignature":"_.countBy(collection, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#countBy","summaryHtml":"<p>Creates an object composed of keys generated from the results of running each element of <code>collection</code> thru <code>iteratee</code>. The corresponding value of each key is the number of times the key was returned by <code>iteratee</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// collection must be an iterable (such as an array)\nfunction countBy(collection, iteratee = x =&gt; x) {\n  const result = {};\n  for (const value of collection) {\n    const changedValue = iteratee(value);\n    result[changedValue] ??= 0;\n    result[changedValue]++;\n  }\n  return result;\n}\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>","src":null,"test":"function countBy(array, iteratee = x => x) {\n  const result = {};\n  for (const value of array) {\n    const changedValue = iteratee(value);\n    result[changedValue] ??= 0;\n    result[changedValue]++;\n  }\n  return result;\n}\n\ndescribe('countBy()', () => {\n  it('can can count values in the array via the provided iteratee', () => {\n    const result = countBy([6.1, 4.2, 6.3], Math.floor);\n    expect(result).toEqual({ 4: 1, 6: 2 });\n  });\n\n  it('can use its default parameter', () => {\n    const result = countBy(['A', 'B', 'A']);\n    expect(result).toEqual({ A: 2, B: 1 });\n  });\n\n  it('returns an empty object when given an empty array', () => {\n    const result = countBy([]);\n    expect(result).toEqual({});\n  });\n});\n"},{"name":"every","manifest":{"fnSignature":"_.every(collection, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#every","summaryHtml":"<p>Checks if <code>predicate</code> returns truthy for all elements of <code>collection</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// collection must be an array\ncollection.every(predicate)\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert iterables into an array, use the spread syntax (e.g. <code>[...collection]</code>).</li>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>","src":null,"test":""},{"name":"filter","manifest":{"fnSignature":"_.filter(collection, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#filter","summaryHtml":"<p>Iterates over elements of <code>collection</code>, returning an array of all elements <code>predicate</code> returns truthy for.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// collection must be an array\ncollection.filter(predicate)\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert iterables into an array, use the spread syntax (e.g. <code>[...collection]</code>).</li>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>","src":null,"test":""},{"name":"find","manifest":{"fnSignature":"_.find(collection, predicate?, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#find","summaryHtml":"<p>Iterates over elements of <code>collection</code>, returning the first element <code>predicate</code> returns truthy for.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// collection must be an array\ncollection.find(predicate)\n</code></pre>\n<p>Or if you want to start searching from a particular index, you can do:</p>\n<pre><code class=\"javascript language-javascript\">// collection must be an array\ncollection.slice(fromIndex).find(predicate)\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert iterables into an array, use the spread syntax (e.g. <code>[...collection]</code>).</li>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>","src":null,"test":""},{"name":"findLast","manifest":{"fnSignature":"_.findLast(collection, predicate?, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#findLast","summaryHtml":"<p>This method is like _.find except that it iterates over elements of <code>collection</code> from right to left.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// collection must be an array\ncollection.findLast(predicate)\n</code></pre>\n<p>Or if you want to start searching from a particular index, you can do:</p>\n<pre><code class=\"javascript language-javascript\">// collection must be an array\ncollection.slice(0, fromIndex + 1).findLast(predicate)\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert iterables into an array, use the spread syntax (e.g. <code>[...collection]</code>).</li>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>","src":null,"test":""},{"name":"flatMap","manifest":{"fnSignature":"_.flatMap(collection, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#flatMap","summaryHtml":"<p>Creates a flattened array of values by running each element in <code>collection</code> thru <code>iteratee</code> and flattening the mapped results.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// collection must be an array\ncollection.flatMap(iteratee)\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert iterables into an array, use the spread syntax (e.g. <code>[...collection]</code>).</li>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>","src":null,"test":""},{"name":"flatMapDeep","manifest":{"fnSignature":"_.flatMapDeep(collection, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#flatMapDeep","summaryHtml":"<p>This method is like <code>_.flatMap</code> except that it recursively flattens the mapped results.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// collection must be an array\ncollection.map(iteratee).flat(Infinity)\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert iterables into an array, use the spread syntax (e.g. <code>[...collection]</code>).</li>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>","src":null,"test":""},{"name":"flatMapDepth","manifest":{"fnSignature":"_.flatMapDepth(collection, iteratee?, depth?)","lodashLink":"https://lodash.com/docs/4.17.15#flatMapDepth","summaryHtml":"<p>This method is like <code>_.flatMap</code> except that it recursively flattens the mapped results up to <code>depth</code> times.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// collection must be an array\ncollection.map(iteratee).flat(depth)\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert iterables into an array, use the spread syntax (e.g. <code>[...collection]</code>).</li>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>","src":null,"test":""},{"name":"forEach","manifest":{"fnSignature":"_.forEach(collection, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#forEach","summaryHtml":"<p>Iterates over elements of collection and invokes iteratee for each element.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// collection can be any iterable (such as an array)\nfor (const value of collection) {\n  iteratee(value);\n}\n</code></pre>\n<p>If you need both the array index and value as you iterate, you can use the <code>.entries()</code> function on the array like so:</p>\n<pre><code class=\"javascript language-javascript\">// collection must be an array\nfor (const [i, value] of collection.entries()) {\n  iteratee(value);\n}\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert iterables into an array, use the spread syntax (e.g. <code>[...collection]</code>).</li>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>\n<p>JavaScript also offers an <code>array.forEach()</code> function which behaves similarly to Lodash's <code>_.forEach()</code> (with the biggest difference being that you can't break out of the native <code>.forEach()</code> loop early, while you can in Lodash's version by returning <code>false</code>). In practice, there's no real reason to use the native <code>.forEach()</code> function anymore. The newer \"for of\" syntax presented above is strictly better and more powerful than <code>.forEach()</code>:</p>\n<ul>\n<li>It supports <code>break</code> and <code>continue</code>.</li>\n<li>You can do <code>await</code> inside a \"for of\" loop. <a href=\"https://stackoverflow.com/questions/37576685/using-async-await-with-a-foreach-loop\">\"await\" will not work properly in <code>.forEach()</code></a>.</li>\n<li>You can use <code>return</code> to return early from a function from inside your loop.</li>\n<li>\"for-of\" works with any iterable, including some odd-ball ones like the arguments object.</li>\n</ul>","src":null,"test":""},{"name":"forEachRight","manifest":{"fnSignature":"_.forEachRight(collection, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#forEachRight","summaryHtml":"<p>This method is like <code>_.forEach</code> except that it iterates over elements of <code>collection</code> from right to left.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// collection must be an array\nfor (const value of collection.toReversed()) {\n  iteratee();\n}\n</code></pre>\n<p>If you need both the array index and value as you iterate, you can use the <code>.entries()</code> function on the array like so:</p>\n<pre><code class=\"javascript language-javascript\">// collcetion must be an iterable (such as an array)\nfor (const [i, value] of [...collection.entries()].toReversed()) {\n  iteratee(value);\n}\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert iterables into an array, use the spread syntax (e.g. <code>[...collection]</code>).</li>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>","src":null,"test":""},{"name":"groupBy","manifest":{"fnSignature":"_.groupBy(collection, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#groupBy","summaryHtml":"<p>Creates an object composed of keys generated from the results of running each element of collection thru iteratee.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// collection must be an iterable (such as an array)\nObject.groupBy(collection, iteratee)\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>","src":null,"test":""},{"name":"includes","manifest":{"fnSignature":"_.includes(collection, value, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#includes","summaryHtml":"<p>Checks if value is in collection.</p>"},"descriptionHtml":"<p>To search for an item in an array:</p>\n<pre><code class=\"javascript language-javascript\">array.includes(item)\n</code></pre>\n<p>To search for an item in an array-like value:</p>\n<pre><code class=\"javascript language-javascript\">Array.from(array).includes(item)\n</code></pre>\n<p>To search for a property value in an object:</p>\n<pre><code class=\"javascript language-javascript\">Object.values(yourObject).includes(item)\n</code></pre>\n<p>To search for a substring in a string:</p>\n<pre><code class=\"javascript language-javascript\">string.includes(subString)\n</code></pre>\n<p>Many iterables will provide some form of an <code>.includes()</code> method, but if they don't, you can convert the iterable to an array before looking for a value in there.</p>\n<pre><code class=\"javascript language-javascript\">[...array].includes(item)\n</code></pre>","src":null,"test":""},{"name":"invokeMap","manifest":{"fnSignature":"_.invokeMap(collection, path, ...args)","lodashLink":"https://lodash.com/docs/4.17.15#invokeMap","summaryHtml":"<p>Invokes the method at path of each element in collection, returning an array of the results of each invoked method.</p>"},"descriptionHtml":"<p>They give the following usage example, which calls a method on each value in your array:</p>\n<pre><code class=\"javascript language-javascript\">_.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort')\n// =&gt; [[1, 5, 7], [1, 2, 3]]\n</code></pre>\n<p>The equivalent in JavaScript would be:</p>\n<pre><code class=\"javascript language-javascript\">[[5, 1, 7], [3, 2, 1]].map(value =&gt; value.sort())\n</code></pre>\n<p>Lodash's <code>_.invokeMap()</code> also has a completely separate use-case with it - it can behave like a regular <code>.map()</code>, except it passes each value to the callback as the \"this\" parameter instead of a normal parameter, as they demonstrated with this example:</p>\n<pre><code class=\"javascript language-javascript\">_.invokeMap([123, 456], String.prototype.split, '')\n// =&gt; [['1', '2', '3'], ['4', '5', '6']]\n</code></pre>\n<p>The generalized equivalent in JavaScript would be to use a normal <code>.map()</code> with a <code>.call()</code> as follows:</p>\n<pre><code class=\"javascript language-javascript\">[123, 456].map(value =&gt; String.prototype.split.call(value, ''))\n</code></pre>\n<p>Though in this specific example, you can just do this:</p>\n<pre><code class=\"javascript language-javascript\">[123, 456].map(value =&gt; String(value).split(''))\n</code></pre>\n<p>The use of <code>.map()</code> requres an array. If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert iterables into an array, use the spread syntax (e.g. <code>[...collection]</code>).</li>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>\n<p>If you're using <code>_.invokeMap()</code> but your path argument is a string or an array of strings, then you can use the JavaScript equivalent to <a href=\"#!/nolodash/invoke\">Lodash's <code>_.invoke()</code></a> inside of a <code>.map()</code> as follows:</p>\n<pre><code class=\"javascript language-javascript\">// Please see the \"_.invoke()\" documentation entry to see\n// how to implement it.\narray.map(value =&gt; invoke(value, path, ...args))\n</code></pre>","src":null,"test":""},{"name":"keyBy","manifest":{"fnSignature":"_.keyBy(collection, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#keyBy","summaryHtml":"<p>Creates an object composed of keys generated from the results of running each element of <code>collection</code> thru <code>iteratee</code>. The corresponding value of each key is the last element responsible for generating the key.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// collection must be an iterable\nfunction keyBy(collection, iteratee = x =&gt; x) {\n  const result = {};\n  for (const value of collection) {\n    const key = iteratee(value);\n    result[key] = value;\n  }\n  return result;\n}\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>","src":null,"test":"function keyBy(collection, iteratee = x => x) {\n  const result = {};\n  for (const value of collection) {\n    const key = iteratee(value);\n    result[key] = value;\n  }\n  return result;\n}\n\ndescribe('keyBy()', () => {\n  it('will group array entries into an object, according to the keys returned by iteratee', () => {\n    const array = [\n      { dir: 'left', code: 97 },\n      { dir: 'right', code: 100 },\n    ];\n\n    const result = keyBy(array, o => String.fromCharCode(o.code));\n\n    expect(result).toEqual({\n      a: { dir: 'left', code: 97 },\n      d: { dir: 'right', code: 100 },\n    });\n  });\n\n  it('will use the last-found value when a conflict occures', () => {\n    const array = [3, 4, 5];\n\n    const result = keyBy(array, n => (n % 2 === 0 ? 'even' : 'odd'));\n\n    expect(result).toEqual({\n      even: 4,\n      odd: 5,\n    });\n  });\n});\n"},{"name":"map","manifest":{"fnSignature":"_.map(collection, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#map","summaryHtml":"<p>Creates an array of values by running each element in <code>collection</code> thru <code>iteratee</code>. </p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// collection must be an array\ncollection.map(iteratee)\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert iterables into an array, use the spread syntax (e.g. <code>[...collection]</code>).</li>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>","src":null,"test":""},{"name":"orderBy","manifest":{"fnSignature":"_.orderBy(collection, iteratees, orders)","lodashLink":"https://lodash.com/docs/4.17.15#orderBy","summaryHtml":"<p>This method is like <code>_.sortBy</code> except that it allows specifying the sort orders of the iteratees to sort by. You can specify an order of \"desc\" for descending or \"asc\" for ascending sort order of corresponding values.</p>"},"descriptionHtml":"<p>To support using multiple \"iteratee\" functions:</p>\n<pre><code class=\"javascript language-javascript\">// collection must be an array\n// orders should be an array of \"asc\" or \"desc\" strings.\nfunction orderBy(collection, iteratees, orders) {\n  return collection.sort((value1, value2) =&gt; {\n    for (const [i, iteratee] of iteratees.entries()) {\n      const reverseSortOrder = orders[i] === 'desc';\n      const comparable1 = iteratee(value1);\n      const comparable2 = iteratee(value2);\n      if (comparable1 &lt; comparable2) return reverseSortOrder ? 1 : -1;\n      if (comparable1 &gt; comparable2) return reverseSortOrder ? -1 : 1;\n    }\n    return 0;\n  });\n}\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert iterables into an array, use the spread syntax (e.g. <code>[...collection]</code>).</li>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>","src":null,"test":"function orderBy(collection, iteratees, orders) {\n  return collection.sort((value1, value2) => {\n    for (const [i, iteratee] of iteratees.entries()) {\n      const reverseSortOrder = orders[i] === 'desc';\n      const comparable1 = iteratee(value1);\n      const comparable2 = iteratee(value2);\n      if (comparable1 < comparable2) return reverseSortOrder ? 1 : -1;\n      if (comparable1 > comparable2) return reverseSortOrder ? -1 : 1;\n    }\n    return 0;\n  });\n}\n\ndescribe('orderBy()', () => {\n  it('sorts using the iteratee functions and order instructions', () => {\n    const users = [\n      { user: 'fred', age: 48 },\n      { user: 'barney', age: 36 },\n      { user: 'fred', age: 40 },\n      { user: 'barney', age: 34 },\n    ];\n\n    const result = orderBy(users, [o => o.user, o => o.age], ['asc', 'desc']);\n\n    expect(result).toEqual([\n      { user: 'barney', age: 36 },\n      { user: 'barney', age: 34 },\n      { user: 'fred', age: 48 },\n      { user: 'fred', age: 40 },\n    ]);\n  });\n});\n"},{"name":"partition","manifest":{"fnSignature":"_.partition(collection, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#partition","summaryHtml":"<p>Creates an array of elements split into two groups, the first of which contains elements predicate returns truthy for, the second of which contains elements predicate returns falsey for.</p>"},"descriptionHtml":"<p>In Lodash, you might use the partition function to sort between evens and odds as follows:</p>\n<pre><code class=\"javascript language-javascript\">const numbers = [2, 3, 7, 8, 9];\n\nconst [evens, odds] = _.partition(numbers, n =&gt; n % 2 === 0);\n// evens -&gt; [ 2, 8 ]\n// odds -&gt; [ 3, 7, 9 ]\n</code></pre>\n<p>The same objective can be accomplished in JavaScript as follows:</p>\n<pre><code class=\"javascript language-javascript\">const numbers = [2, 3, 7, 8, 9];\n\nconst { true: evens, false: odds } = Object.groupBy(numbers, n =&gt; n % 2 === 0);\n// evens -&gt; [ 2, 8 ]\n// odds -&gt; [ 3, 7, 9 ]\n</code></pre>","src":null,"test":""},{"name":"reduce","manifest":{"fnSignature":"_.reduce(collection, iteratee, accumulator?)","lodashLink":"https://lodash.com/docs/4.17.15#reduce","summaryHtml":"<p>Reduces collection to a value which is the accumulated result of running each element in collection thru iteratee, where each successive invocation is supplied the return value of the previous.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// collection must be an array\ncollection.reduce(iteratee, accumulator)\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert iterables into an array, use the spread syntax (e.g. <code>[...collection]</code>).</li>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>","src":null,"test":""},{"name":"reduceRight","manifest":{"fnSignature":"_.reduceRight(collection, iteratee, accumulator?)","lodashLink":"https://lodash.com/docs/4.17.15#reduceRight","summaryHtml":"<p>This method is like <code>_.reduce</code> except that it iterates over elements of <code>collection</code> from right to left.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// collection must be an array\ncollection.toReversed().reduce(iteratee, accumulator)\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert iterables into an array, use the spread syntax (e.g. <code>[...collection]</code>).</li>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>","src":null,"test":""},{"name":"reject","manifest":{"fnSignature":"_.reject(collection, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#reject","summaryHtml":"<p>The opposite of <code>_.filter</code>; this method returns the elements of <code>collection</code> that <code>predicate</code> does <strong>not</strong> return truthy for.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// collection must be an array\ncollection.filter(value =&gt; !predicate(value))\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert iterables into an array, use the spread syntax (e.g. <code>[...collection]</code>).</li>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>","src":null,"test":""},{"name":"sample","manifest":{"fnSignature":"_.sample(collection)","lodashLink":"https://lodash.com/docs/4.17.15#sample","summaryHtml":"<p>Gets a random element from <code>collection</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// collection must be array-like\nfunction sample(collection) {\n  return collection[Math.floor(Math.random() * collection.length)];\n}\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert iterables into an array, use the spread syntax (e.g. <code>[...collection]</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>","src":null,"test":""},{"name":"sampleSize","manifest":{"fnSignature":"_.sampleSize(collection, n)","lodashLink":"https://lodash.com/docs/4.17.15#sampleSize","summaryHtml":"<p>Gets <code>n</code> random elements at unique keys from <code>collection</code> up to the size of <code>collection</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// collection must be iterable\nfunction sampleSize(collection_, n) {\n  const collection = [...collection_];\n  const result = [];\n  for (let i = 0; i &lt; n; i++) {\n    const randomIndex = Math.floor(Math.random() * collection.length);\n    result.push(collection[randomIndex]);\n    collection.splice(randomIndex, 1);\n  }\n  return result;\n}\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>","src":null,"test":""},{"name":"shuffle","manifest":{"fnSignature":"_.shuffle(collection)","lodashLink":"https://lodash.com/docs/4.17.15#shuffle","summaryHtml":"<p>Creates an array of shuffled values.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// collection must be an array\nfunction shuffle(collection) {\n  return collection\n    .map(value =&gt; ({ value, order: Math.random() }))\n    .sort((a, b) =&gt; a.order - b.order)\n    .map(({ value }) =&gt; value);\n}\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert iterables into an array, use the spread syntax (e.g. <code>[...collection]</code>).</li>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>\n<p>Sometimes you'll see a recommendation to shuffle using an algorithm such as this:</p>\n<pre><code class=\"javascript language-javascript\">function shuffle(collection) {\n  return collection.sort(() =&gt; Math.random() - 0.5);\n}\n</code></pre>\n<p>Such an algorithm has the appearance of working, but it is actually a very bias and broken shuffle. This is because a random choice is being made at each comparison, causing some elements to be compared more often than others, which in turn results in this bias.</p>","src":null,"test":""},{"name":"size","manifest":{"fnSignature":"_.size(collection)","lodashLink":"https://lodash.com/docs/4.17.15#size","summaryHtml":"<p>Gets the size of <code>collection</code> by returning its length for array-like values or the number of own enumerable string keyed properties for objects.</p>"},"descriptionHtml":"<p>To get the size of arrays and array-likes:</p>\n<pre><code class=\"javascript language-javascript\">array.length\n</code></pre>\n<p>To get the number of own, enumerable, string-keyed properties in an object:</p>\n<pre><code class=\"javascript language-javascript\">Object.keys(obj).length\n</code></pre>","src":null,"test":""},{"name":"some","manifest":{"fnSignature":"_.some(collection)","lodashLink":"https://lodash.com/docs/4.17.15#some","summaryHtml":"<p>Checks if <code>predicate</code> returns truthy for any element of <code>collection</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// collection must be an array\ncollection.some(predicate)\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert iterables into an array, use the spread syntax (e.g. <code>[...collection]</code>).</li>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>","src":null,"test":""},{"name":"sortBy","manifest":{"fnSignature":"_.sortBy(collection, iteratees)","lodashLink":"https://lodash.com/docs/4.17.15#sortBy","summaryHtml":"<p>Creates an array of elements, sorted in ascending order by the results of running each element in a collection thru each iteratee.</p>"},"descriptionHtml":"<p>To sort using a single \"iteratee\" (sort) function:</p>\n<pre><code class=\"javascript language-javascript\">// collection must be an array\nfunction sortBy(collection, iteratee) {\n  return collection.sort((value1, value2) =&gt; {\n    const comparable1 = iteratee(value1);\n    const comparable2 = iteratee(value2);\n    if (comparable1 &lt; comparable2) return -1;\n    if (comparable1 &gt; comparable2) return 1;\n    return 0;\n  });\n}\n</code></pre>\n<p>To support using multiple \"iteratee\" functions:</p>\n<pre><code class=\"javascript language-javascript\">// collection must be an array\nfunction sortBy(collection, iteratees) {\n  return collection.sort((value1, value2) =&gt; {\n    for (const iteratee of iteratees) {\n      const comparable1 = iteratee(value1);\n      const comparable2 = iteratee(value2);\n      if (comparable1 &lt; comparable2) return -1;\n      if (comparable1 &gt; comparable2) return 1;\n    }\n    return 0;\n  });\n}\n</code></pre>\n<p>If you have a collection type that's not supported by a chosen technique, you may need to convert it to an array first:</p>\n<ul>\n<li>To convert iterables into an array, use the spread syntax (e.g. <code>[...collection]</code>).</li>\n<li>To convert array-likes into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a> (e.g. <code>Array.from(collection)</code>).</li>\n<li>To convert objects into an array, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\"><code>Object.values()</code></a>, or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries()</code></a> depending on what your needs are.</li>\n</ul>","src":null,"test":"describe('sortBy() supporting only one iteratee', () => {\n  function sortBy(collection, iteratee) {\n    return collection.sort((value1, value2) => {\n      const comparable1 = iteratee(value1);\n      const comparable2 = iteratee(value2);\n      if (comparable1 < comparable2) return -1;\n      if (comparable1 > comparable2) return 1;\n      return 0;\n    });\n  }\n\n  it('sorts using the iteratee function', () => {\n    const users = [\n      { user: 'fred', age: 48 },\n      { user: 'barney', age: 36 },\n      { user: 'fred', age: 40 },\n      { user: 'barney', age: 34 },\n    ];\n\n    const result = sortBy(users, o => o.user);\n\n    expect(result).toEqual([\n      { user: 'barney', age: 36 },\n      { user: 'barney', age: 34 },\n      { user: 'fred', age: 48 },\n      { user: 'fred', age: 40 },\n    ]);\n  });\n});\n\ndescribe('sortBy() supporting multiple iteratees', () => {\n  function sortBy(collection, iteratees) {\n    return collection.sort((value1, value2) => {\n      for (const iteratee of iteratees) {\n        const comparable1 = iteratee(value1);\n        const comparable2 = iteratee(value2);\n        if (comparable1 < comparable2) return -1;\n        if (comparable1 > comparable2) return 1;\n      }\n      return 0;\n    });\n  }\n\n  it('sorts using the iteratee functions', () => {\n    const users = [\n      { user: 'fred', age: 48 },\n      { user: 'barney', age: 36 },\n      { user: 'fred', age: 40 },\n      { user: 'barney', age: 34 },\n    ];\n\n    const result = sortBy(users, [o => o.user, o => o.age]);\n\n    expect(result).toEqual([\n      { user: 'barney', age: 34 },\n      { user: 'barney', age: 36 },\n      { user: 'fred', age: 40 },\n      { user: 'fred', age: 48 },\n    ]);\n  });\n});\n"}]},{"categoryHeading":"Date","entries":[{"name":"now","manifest":{"fnSignature":"_.now()","lodashLink":"https://lodash.com/docs/4.17.15#now","summaryHtml":"<p>Gets the timestamp of the number of milliseconds that have elapsed since the Unix epoch.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">Date.now()\n</code></pre>","src":null,"test":""}]},{"categoryHeading":"Function","entries":[{"name":"after","manifest":{"fnSignature":"_.after(n, func)","lodashLink":"https://lodash.com/docs/4.17.15#after","summaryHtml":"<p>The opposite of <code>_.before</code>; this method creates a function that invokes <code>func</code> once it's called <code>n</code> or more times.</p>"},"descriptionHtml":"<p><code>_.after()</code> was a convenient helper function back when asynchronous programming was done primarily through callbacks - it allowed you execute a function after a number of asynchronous tasks have finished, as shown in this example from their documentation.</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">var saves = ['profile', 'settings'];\n\nvar done = _.after(saves.length, function() {\n  console.log('done saving!');\n});\n\n_.forEach(saves, function(type) {\n  asyncSave({ 'type': type, 'complete': done });\n});\n// =&gt; Logs 'done saving!' after the two async saves have completed.\n</code></pre>\n<p>Now days, the <code>asyncSave()</code> function from the example would typically be written to return a promise instead of accepting a callback (and if its not, you can convert it to a promise-based function yourself with the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\">Promise constructor</a>). With a promise-based <code>asyncSave()</code>, we can rewrite this example to just use <code>Promise.all()</code> instead.</p>\n<pre><code class=\"javascript language-javascript\">await Promise.all([\n  asyncSave({ type: 'profile' }),\n  asyncSave({ type: 'settings' }),\n]);\n\nconsole.log('done saving!');\n// =&gt; Logs 'done saving!' after the two async saves have completed.\n</code></pre>\n<p>If the <code>saves</code> array is dynamically generated, you can use the <a href=\"https://stackoverflow.com/a/37576787/7696223\"><code>Promise.all()</code> + <code>array.map()</code> pattern</a>.</p>\n<pre><code class=\"javascript language-javascript\">const saves = getAnArrayFromSomewhere();\n\nawait Promise.all(saves.map(async type =&gt; {\n  await asyncSave({ type });\n}));\n\nconsole.log('done saving!');\n// =&gt; Logs 'done saving!' after the two async saves have completed.\n</code></pre>\n<p>That being said, if you need a utility that acts like Lodash's <code>_.after()</code>, here's how you could code it up:</p>\n<pre><code class=\"javascript language-javascript\">function after(n, func) {\n  let callCount = 0;\n  return function (...args) {\n    callCount++;\n    if (callCount &lt; n) {\n      return;\n    }\n\n    // Using .call() may be overkill.\n    // You could just do `return func(...args)` if you\n    // don't need to worry about preserving the \"this\" argument.\n    return func.call(this, ...args);\n  };\n}\n</code></pre>","src":null,"test":"function after(n, func) {\n  let callCount = 0;\n  return function (...args) {\n    callCount++;\n    if (callCount < n) {\n      return;\n    }\n\n    // Using .call() may be overkill.\n    // You could just do `return func(...args)` if you\n    // don't need to worry about preserving the \"this\" argument.\n    return func.call(this, ...args);\n  };\n}\n\ndescribe('after()', () => {\n  it('calls the passed-in callback as normal once returned function has been called n times', () => {\n    const fn = after(3, (x, y) => x + y);\n\n    expect(fn(2, 3)).toEqual(undefined);\n    expect(fn(2, 3)).toEqual(undefined);\n    expect(fn(2, 3)).toEqual(5);\n  });\n\n  it('preserves the \"this\" argument', () => {\n    let self;\n\n    const fn = after(1, function () {\n      self = this;\n    });\n\n    const myThis = { x: 2 };\n    fn.call(myThis);\n\n    expect(self).toEqual(myThis);\n  });\n});\n"},{"name":"ary","manifest":{"fnSignature":"_.ary(func, n)","lodashLink":"https://lodash.com/docs/4.17.15#ary","summaryHtml":"<p>Creates a function that invokes <code>func</code>, with up to <code>n</code> arguments, ignoring any additional arguments.</p>"},"descriptionHtml":"<p><code>_.ary()</code> was created before JavaScript provided arrow function syntax. Now days, it's fairly easy and concise to just use an arrow function to accomplish the same job.</p>\n<pre><code class=\"javascript language-javascript\">// An example of using _.ary() from their documentation\n_.map(['6', '8', '10'], _.ary(parseInt, 1)); // =&gt; [6, 8, 10]\n\n// How you can do the same thing with an arrow function\n['6', '8', '10'].map(n =&gt; parseInt(n)); // =&gt; [6, 8, 10]\n</code></pre>\n<p>If you wish to have a utility function that acts like Lodash's <code>_.ary()</code>, you can use the following:</p>\n<pre><code class=\"javascript language-javascript\">function ary(func, n) {\n  return function (...args) {\n    // Using .call() may be overkill.\n    // You could just do `return func(...args.slice(0, n))` if you\n    // don't need to worry about preserving the \"this\" argument.\n    return func.call(this, ...args.slice(0, n));\n  };\n}\n</code></pre>","src":null,"test":"function ary(func, n) {\n  return function (...args) {\n    // Using .call() may be overkill.\n    // You could just do `return func(...args.slice(0, n))` if you\n    // don't need to worry about preserving the \"this\" argument.\n    return func.call(this, ...args.slice(0, n));\n  };\n}\n\ndescribe('ary()', () => {\n  it('only passes in the first n arguments', () => {\n    const fn = ary((x, y, z) => [x, y, z], 2);\n\n    expect(fn(2, 3, 4)).toEqual([2, 3, undefined]);\n  });\n\n  it('preserves the \"this\" argument', () => {\n    let self;\n\n    const fn = ary(function () {\n      self = this;\n    }, 0);\n\n    const myThis = { x: 2 };\n    fn.call(myThis);\n\n    expect(self).toEqual(myThis);\n  });\n});\n"},{"name":"before","manifest":{"fnSignature":"_.before(n, func)","lodashLink":"https://lodash.com/docs/4.17.15#before","summaryHtml":"<p>Creates a function that invokes <code>func</code>, with the <code>this</code> binding and arguments of the created function, while it's called less than <code>n</code> times. Subsequent calls to the created function return the result of the last <code>func</code> invocation.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function before(n, func) {\n  let lastResult;\n  return function (...args) {\n    n--;\n    if (n &lt;= 0) {\n      return lastResult;\n    }\n\n    lastResult = func.call(this, ...args);\n    return lastResult;\n  };\n}\n</code></pre>\n<p>Personally, I'm not sure why a function like this is all that useful. If you ever find this function to be helpful, I'd be interested to hear why - you can open a GitHub issue and let me know.</p>\n<p>If you want to use this function with <code>n=1</code>, then refer to <code>_.once()</code> instead.</p>","src":null,"test":"function before(n, func) {\n  let lastResult;\n  return function (...args) {\n    n--;\n    if (n <= 0) {\n      return lastResult;\n    }\n\n    lastResult = func.call(this, ...args);\n    return lastResult;\n  };\n}\n\ndescribe('before()', () => {\n  it('returns the last result after n calls', () => {\n    const fn = before(4, x => x ** 2);\n\n    expect(fn(1)).toEqual(1);\n    expect(fn(2)).toEqual(4);\n    expect(fn(3)).toEqual(9);\n    expect(fn(4)).toEqual(9);\n    expect(fn(5)).toEqual(9);\n  });\n\n  it('preserves the \"this\" argument', () => {\n    let self;\n    const fn = before(3, function () {\n      self = this;\n    });\n\n    const myThis = { x: 2 };\n    fn.call(myThis);\n\n    expect(self).toEqual(myThis);\n  });\n});\n"},{"name":"bind","manifest":{"fnSignature":"_.bind(func, thisArg, ...partials)","lodashLink":"https://lodash.com/docs/4.17.15#bind","summaryHtml":"<p>Creates a function that invokes <code>func</code> with the <code>this</code> binding of <code>thisArg</code> and <code>partials</code> prepended to the arguments it receives.</p>"},"descriptionHtml":"<p>You can use an arrow function to get the same effect, or the native <code>.bind()</code> method will work for most use cases as well.</p>\n<p>To bind a method to the object it is found on:</p>\n<pre><code class=\"javascript language-javascript\">// Instead of this\n_.bind(obj.method, obj)\n</code></pre>\n<pre><code class=\"javascript language-javascript\">// You can use an arrow function\n(...args) =&gt; obj.method(...args)\n</code></pre>\n<pre><code class=\"javascript language-javascript\">// or you can use the native .bind() method.\nobj.method.bind(obj)\n</code></pre>\n<p>To bind a method to any object:</p>\n<pre><code class=\"javascript language-javascript\">// Instead of this\n_.bind(obj.method, anyObj)\n</code></pre>\n<pre><code class=\"javascript language-javascript\">// You can use an arrow function with .call()\n(...args) =&gt; obj.method.call(anyObj, ...args)\n</code></pre>\n<pre><code class=\"javascript language-javascript\">// or you can use the native .bind() method.\nobj.method.bind(anyObj)\n</code></pre>\n<p>If you wish to partially apply some initial arguments:</p>\n<pre><code class=\"javascript language-javascript\">// Instead of this\n_.bind(obj.method, obj, 1, 2, 3)\n</code></pre>\n<pre><code class=\"javascript language-javascript\">// You can use an arrow function\n(...args) =&gt; obj.method(1, 2, 3, ...args)\n</code></pre>\n<pre><code class=\"javascript language-javascript\">// or you can use the native .bind() method.\nobj.method.bind(obj, 1, 2, 3)\n</code></pre>\n<p>If you wish to partially apply some arguments from any position</p>\n<pre><code class=\"javascript language-javascript\">// Instead of this\n_.bind(obj.method, obj, 1, _, 2, 3)\n</code></pre>\n<pre><code class=\"javascript language-javascript\">// You can use an arrow function\nx =&gt; obj.method(1, x, 2, 3)\n</code></pre>","src":null,"test":""},{"name":"bindKey","manifest":{"fnSignature":"_.bindKey(object, key, ...partials)","lodashLink":"https://lodash.com/docs/4.17.15#bindKey","summaryHtml":"<p>Creates a function that invokes the method at <code>object[key]</code> with <code>partials</code> prepended to the arguments it receives. This method differs from <code>_.bind</code> by allowing bound functions to reference methods that may be redefined or don't yet exist.</p>"},"descriptionHtml":"<p>You can use arrow functions to achieve the same results.</p>\n<p>To bind a method's this parameter to the object it is found on:</p>\n<pre><code class=\"javascript language-javascript\">// Instead of this\n_.bindKey(obj, 'method')\n</code></pre>\n<pre><code class=\"javascript language-javascript\">// You can use an arrow function\n(...args) =&gt; obj.method(...args)\n</code></pre>\n<p>If you wish to partially apply some initial arguments in addition to binding a this parameter:</p>\n<pre><code class=\"javascript language-javascript\">// Instead of this\n_.bindKey(obj, 'method', 1, 2, 3)\n</code></pre>\n<pre><code class=\"javascript language-javascript\">// You can use an arrow function\n(...args) =&gt; obj.method(1, 2, 3, ...args)\n</code></pre>\n<p>If you wish to partially apply some arguments from any position in addition to binding a this parameter:</p>\n<pre><code class=\"javascript language-javascript\">// Instead of this\n_.bindKey(obj, 'method', 1, _, 2, 3)\n</code></pre>\n<pre><code class=\"javascript language-javascript\">// You can use an arrow function\nx =&gt; obj.method(1, x, 2, 3)\n</code></pre>\n<p>Notice that if we changed the <code>method</code> property on <code>obj</code> and swap it out for a new method, both the arrow function and <code>_.bindKey</code> will start invoking the new method, while using the native <code>.bind()</code> method or Lodash's <code>_.bind()</code> will use the old method.</p>\n<pre><code class=\"javascript language-javascript\">const obj = {\n  method: () =&gt; 'before',\n};\n\nconst lodashBindKeyFn = _.bindKey(obj, 'method');\nconst arrowFn = () =&gt; obj.method();\nconst lodashBindFn = _.bind(obj.method, obj);\nconst nativeBindFn = obj.method.bind(obj);\n\nobj.method = () =&gt; 'after';\n\nlodashBindKeyFn(); // 'after'\narrowFn(); // 'after'\nlodashBindFn(); // 'before'\nnativeBindFn(); // 'before'\n</code></pre>","src":null,"test":""},{"name":"curryRight","manifest":{"fnSignature":"_.curryRight(func, arity?)","lodashLink":"https://lodash.com/docs/4.17.15#curryRight","summaryHtml":"<p>This method is like _.curryRight except that arguments will be passed in in reverse order.</p>"},"descriptionHtml":"<p>Currying is a principle of point-free programming, a programming style that JavaScript wasn't really designed to support. You can do it, but without the help of a third-party library, you'll just be fighting against the language and its uncurried standard library every step of the way. If you want to do point-free programming, you are better off adopting a library such as Rambda, which basically provides an alternative, pre-curried standard library along with some helper functions such as a replacement for Lodash's <code>_.curryRight()</code>.</p>\n<p>That being said, you can easily curry-right any function by using arrow function syntax. For example, to curry-right a function that takes two arguments, do the following:</p>\n<pre><code class=\"javascript language-javascript\">// hasOwn() is a curried-right version of Object.hasOwn()\nconst hasOwn = prop =&gt; obj =&gt; Object.hasOwn(obj, prop);\n\n// Example usage:\nconst doesObjHaveMyProp = hasOwn('exampleProp');\nconsole.log(doesObjHaveMyProp({ exampleProp: 22 })); // true\n</code></pre>\n<p>If you want a function that does it, you can use the following:</p>\n<pre><code class=\"javascript language-javascript\">function curryRight(func, arity, _appliedArgs = []) {\n  return (...args) =&gt; {\n    const newAppliedArgs = [...args, ..._appliedArgs];\n    if (newAppliedArgs.length &lt; arity) {\n      return curryRight(func, arity, newAppliedArgs);\n    } else {\n      return func(...newAppliedArgs);\n    }\n  };\n}\n</code></pre>\n<p>And if you need support for being able to skip parameters when partially applying a curried function (i.e. passing in the <code>_</code> value when calling it), you can use the following:</p>\n<pre><code class=\"javascript language-javascript\">const _ = Symbol('curry placeholder');\n\nfunction curryRight(func, arity, _appliedArgs = {}, _numApplied = 0) {\n  return (...args) =&gt; {\n    const appliedArgs = { ..._appliedArgs };\n    let numApplied = _numApplied;\n    for (let i = arity - 1; i &gt;= 0; i--) {\n      if (i in appliedArgs) continue;\n      if (args.at(-1) !== _) {\n        numApplied++;\n        appliedArgs[i] = args.at(-1);\n      }\n      args.pop();\n      if (args.length === 0) break;\n    }\n\n    if (numApplied === arity) {\n      return func(...Array.from({ ...appliedArgs, length: arity }));\n    } else {\n      return curryRight(func, arity, appliedArgs, numApplied);\n    }\n  };\n}\n</code></pre>\n<p>Notice that the <code>curryRight()</code> functions above requires you to supply an <code>arity</code> parameter - it does not fall back to using <code>func.length</code> (i.e. the number of parameters <code>func</code> says it takes). This is purposely different from Lodash's <code>_.curryRight()</code>. Code maintainers often don't consider the <code>length</code> property of their functions to be a value they're supposed to keep stable between releases - in fact, many JavaScript developers are not even be aware of its existence. People are generally free to do updates such as <code>(x, y) =&gt; { ... }</code> to <code>(...args) =&gt; { ... }</code> or <code>(x, y) =&gt; { if (y === undefined) { y = someDefault; } ... }</code> to <code>(x, y=someDefault) =&gt; { ... }</code>. Lets keep it that way. Don't write fragile code that depends on the <code>.length</code> property of functions, causing your code to break if a refactoring like this occurs.</p>","src":null,"test":"describe('curryRight() without \"_\" placeholder support', () => {\n  function curryRight(func, arity, _appliedArgs = []) {\n    return (...args) => {\n      const newAppliedArgs = [...args, ..._appliedArgs];\n      if (newAppliedArgs.length < arity) {\n        return curryRight(func, arity, newAppliedArgs);\n      } else {\n        return func(...newAppliedArgs);\n      }\n    };\n  }\n\n  it('can curry a function', () => {\n    const fn = curryRight((a, b) => a + b, 2);\n    expect(fn('a')('b')).toEqual('ba');\n  });\n\n  it('allows you to supply multiple arguments at once to a curried function', () => {\n    const fn = curryRight((a, b, c) => a + b + c, 3);\n    expect(fn('a', 'b')('c')).toEqual('cab');\n  });\n\n  it('can call a curried function with an arity argument of 0', () => {\n    const fn = curryRight(() => 'result', 0);\n    expect(fn()).toEqual('result');\n  });\n});\n\ndescribe('curryRight() with \"_\" placeholder support', () => {\n  const _ = Symbol('curry placeholder');\n\n  function curryRight(func, arity, _appliedArgs = {}, _numApplied = 0) {\n    return (...args) => {\n      const appliedArgs = { ..._appliedArgs };\n      let numApplied = _numApplied;\n      for (let i = arity - 1; i >= 0; i--) {\n        if (i in appliedArgs) continue;\n        if (args.at(-1) !== _) {\n          numApplied++;\n          appliedArgs[i] = args.at(-1);\n        }\n        args.pop();\n        if (args.length === 0) break;\n      }\n\n      if (numApplied === arity) {\n        return func(...Array.from({ ...appliedArgs, length: arity }));\n      } else {\n        return curryRight(func, arity, appliedArgs, numApplied);\n      }\n    };\n  }\n\n  it('can curry a function', () => {\n    const fn = curryRight((a, b) => a + b, 2);\n    expect(fn('b')('a')).toEqual('ab');\n  });\n\n  it('allows you to supply multiple arguments at once to a curried function', () => {\n    const fn = curryRight((a, b, c) => a + b + c, 3);\n    expect(fn('b', 'c')('a')).toEqual('abc');\n  });\n\n  it('allows you to skip parameters when partially apply a curried function', () => {\n    const fn = curryRight((a, b, c) => a + b + c, 3);\n    expect(fn('b', _)('a', 'c')).toEqual('abc');\n  });\n\n  it('allows you to fill all parameters except for skipped ones', () => {\n    const fn = curryRight((a, b, c, d) => a + b + c + d, 4);\n    expect(fn('a', _, _, 'd')('c')('b')).toEqual('abcd');\n  });\n\n  it('can call a curried function with an arity argument of 0', () => {\n    const fn = curryRight(() => 'result', 0);\n    expect(fn()).toEqual('result');\n  });\n});\n"},{"name":"curry","manifest":{"fnSignature":"_.curry(func, arity?)","lodashLink":"https://lodash.com/docs/4.17.15#curry","summaryHtml":"<p>Creates a function that invokes the method at <code>object[key]</code> with <code>partials</code> prepended to the arguments it receives. This method differs from <code>_.bind</code> by allowing bound functions to reference methods that may be redefined or don't yet exist.</p>"},"descriptionHtml":"<p>Currying is a principle of point-free programming, a programming style that JavaScript wasn't really designed to support. You can do it, but without the help of a third-party library, you'll just be fighting against the language and its uncurried standard library every step of the way. If you want to do point-free programming, you are better off adopting a library such as Rambda, which basically provides an alternative, pre-curried standard library along with some helper functions such as a replacement for Lodash's <code>_.curry()</code>.</p>\n<p>That being said, you can easily curry any function by using arrow function syntax. For example, to curry a function that takes two arguments, do the following:</p>\n<pre><code class=\"javascript language-javascript\">// hasOwn() is a curried version of Object.hasOwn()\nconst hasOwn = obj =&gt; prop =&gt; Object.hasOwn(obj, prop);\n\n// Example usage:\nconst doesMyObjHaveProp = hasOwn({ a: 1, b: 2 });\nconsole.log(doesMyObjHaveProp('a')); // true\n</code></pre>\n<p>If you want a function that does it, you can use the following:</p>\n<pre><code class=\"javascript language-javascript\">function curry(func, arity, _appliedArgs = []) {\n  return (...args) =&gt; {\n    const newAppliedArgs = [..._appliedArgs, ...args];\n    if (newAppliedArgs.length &lt; arity) {\n      return curry(func, arity, newAppliedArgs);\n    } else {\n      return func(...newAppliedArgs);\n    }\n  };\n}\n</code></pre>\n<p>And if you need support for being able to skip parameters when partially applying a curried function (i.e. passing in the <code>_</code> value when calling it), you can use the following:</p>\n<pre><code class=\"javascript language-javascript\">const _ = Symbol('curry placeholder');\n\nfunction curry(func, arity, _appliedArgs = {}, _numApplied = 0) {\n  return (...args) =&gt; {\n    const appliedArgs = { ..._appliedArgs };\n    let numApplied = _numApplied;\n    for (let i = 0; i &lt; arity; i++) {\n      if (i in appliedArgs) continue;\n      if (args[0] !== _) {\n        numApplied++;\n        appliedArgs[i] = args[0];\n      }\n      args.shift();\n      if (args.length === 0) break;\n    }\n\n    if (numApplied === arity) {\n      return func(...Array.from({ ...appliedArgs, length: arity }));\n    } else {\n      return curry(func, arity, appliedArgs, numApplied);\n    }\n  };\n}\n</code></pre>\n<p>Notice that the <code>curry()</code> functions above requires you to supply an <code>arity</code> parameter - it does not fall back to using <code>func.length</code> (i.e. the number of parameters <code>func</code> says it takes). This is purposely different from Lodash's <code>_.curry()</code>. Code maintainers often don't consider the <code>length</code> property of their functions to be a value they're supposed to keep stable between releases - in fact, many JavaScript developers are not even be aware of its existence. People are generally free to do updates such as <code>(x, y) =&gt; { ... }</code> to <code>(...args) =&gt; { ... }</code> or <code>(x, y) =&gt; { if (y === undefined) { y = someDefault; } ... }</code> to <code>(x, y=someDefault) =&gt; { ... }</code>. Lets keep it that way. Don't write fragile code that depends on the <code>.length</code> property of functions, causing your code to break if a refactoring like this occurs.</p>","src":null,"test":"describe('curry() without \"_\" placeholder support', () => {\n  function curry(func, arity, _appliedArgs = []) {\n    return (...args) => {\n      const newAppliedArgs = [..._appliedArgs, ...args];\n      if (newAppliedArgs.length < arity) {\n        return curry(func, arity, newAppliedArgs);\n      } else {\n        return func(...newAppliedArgs);\n      }\n    };\n  }\n\n  it('can curry a function', () => {\n    const fn = curry((a, b) => a + b, 2);\n    expect(fn('a')('b')).toEqual('ab');\n  });\n\n  it('allows you to supply multiple arguments at once to a curried function', () => {\n    const fn = curry((a, b, c) => a + b + c, 3);\n    expect(fn('a', 'b')('c')).toEqual('abc');\n  });\n\n  it('can call a curried function with an arity argument of 0', () => {\n    const fn = curry(() => 'result', 0);\n    expect(fn()).toEqual('result');\n  });\n});\n\ndescribe('curry() with \"_\" placeholder support', () => {\n  const _ = Symbol('curry placeholder');\n\n  function curry(func, arity, _appliedArgs = {}, _numApplied = 0) {\n    return (...args) => {\n      const appliedArgs = { ..._appliedArgs };\n      let numApplied = _numApplied;\n      for (let i = 0; i < arity; i++) {\n        if (i in appliedArgs) continue;\n        if (args[0] !== _) {\n          numApplied++;\n          appliedArgs[i] = args[0];\n        }\n        args.shift();\n        if (args.length === 0) break;\n      }\n\n      if (numApplied === arity) {\n        return func(...Array.from({ ...appliedArgs, length: arity }));\n      } else {\n        return curry(func, arity, appliedArgs, numApplied);\n      }\n    };\n  }\n\n  it('can curry a function', () => {\n    const fn = curry((a, b) => a + b, 2);\n    expect(fn('a')('b')).toEqual('ab');\n  });\n\n  it('allows you to supply multiple arguments at once to a curried function', () => {\n    const fn = curry((a, b, c) => a + b + c, 3);\n    expect(fn('a', 'b')('c')).toEqual('abc');\n  });\n\n  it('allows you to skip parameters when partially apply a curried function', () => {\n    const fn = curry((a, b, c) => a + b + c, 3);\n    expect(fn(_, 'b')('a', 'c')).toEqual('abc');\n  });\n\n  it('allows you to fill all parameters except for skipped ones', () => {\n    const fn = curry((a, b, c, d) => a + b + c + d, 4);\n    expect(fn('a', _, _, 'd')('b')('c')).toEqual('abcd');\n  });\n\n  it('can call a curried function with an arity argument of 0', () => {\n    const fn = curry(() => 'result', 0);\n    expect(fn()).toEqual('result');\n  });\n});\n"},{"name":"debounce","manifest":{"fnSignature":"_.debounce(func, wait, options?)","lodashLink":"https://lodash.com/docs/4.17.15#debounce","summaryHtml":"<p>Creates a debounced function that delays invoking <code>func</code> until after <code>wait</code> milliseconds have elapsed since the last time the debounced function was invoked. The <code>func</code> is invoked with the last arguments provided to the debounced function. Subsequent calls to the debounced function return the result of the last <code>func</code> invocation. See <a href=\"https://css-tricks.com/debouncing-throttling-explained-examples/\">David Corbacho's article</a> for details over the differences between <code>_.debounce</code> and <code>_.throttle</code>.</p>"},"descriptionHtml":"<!-- Due to the repeated variable names, eslint can't lint this. You'll need to manually lint it through other means. -->\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">/*# METADATA\n[\n  {\n    \"id\": \"when\",\n    \"type\": \"radio\",\n    \"message\": \"When a user attempts to call your debounced function multiple times in quick succession, at what point should the wrapped function actually be called?\",\n    \"default\": \"trailing\",\n    \"options\": {\n      \"leading\": \"At the leading end of the series of calls.\",\n      \"trailing\": \"At the trailing end of the series of calls (Lodash's default behavior).\",\n      \"leadingAndTrailing\": \"At both the leading and trailing end of the series of calls.\"\n    }\n  },\n  {\n    \"id\": \"withHelpers\",\n    \"type\": \"radio\",\n    \"message\": \"Should functions be attached to the returned debounced function for additional control?\",\n    \"default\": \"none\",\n    \"options\": {\n      \"none\": \"No\",\n      \"cancel\": \"Provide a cancel function, to cancel delayed function invocations.\",\n      \"flushAndCancel\": \"In addition to a cancel function, provide a flush function that forces any delayed function invocations to run immediately.\"\n    }\n  }\n]\n#*/\n\n//# CONFIG { \"when\": \"leading\", \"withHelpers\": \"none\" }\n\n/**\n * Invokes the function `func` then starts a countdown for `wait` ms.\n * Any further invocations that happen during the countdown will be ignored,\n * and will reset the countdown back to `wait` ms.\n * @return The value that `func` returned when it was last called.\n */\nfunction debounceLeading(func, wait) {\n  let timeoutId = undefined;\n  let lastResult;\n\n  const debounced = (...args) =&gt; {\n    if (timeoutId === undefined) {\n      // Invokes the function and starts a countdown\n      lastResult = func(...args);\n      timeoutId = setTimeout(() =&gt; { timeoutId = undefined }, wait);\n    } else {\n      // Ignores this call and resets the countdown\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() =&gt; { timeoutId = undefined }, wait);\n    }\n\n    return lastResult;\n  };\n\n  return debounced;\n}\n\n//# CONFIG { \"when\": \"leading\", \"withHelpers\": \"cancel\" }\n\n/**\n * Invokes the function `func` then starts a countdown for `wait` ms.\n * Any further invocations that happen during the countdown will be ignored,\n * and will reset the countdown back to `wait` ms.\n * @return The value that `func` returned when it was last called.\n */\nfunction debounceLeading(func, wait) {\n  let timeoutId = undefined;\n  let lastResult;\n\n  const debounced = (...args) =&gt; {\n    if (timeoutId === undefined) {\n      // Invokes the function and starts a countdown\n      lastResult = func(...args);\n      timeoutId = setTimeout(() =&gt; { timeoutId = undefined }, wait);\n    } else {\n      // Ignores this call and resets the countdown\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() =&gt; { timeoutId = undefined }, wait);\n    }\n\n    return lastResult;\n  };\n\n  debounced.cancel = () =&gt; {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n  };\n\n  return debounced;\n}\n\n//# CONFIG { \"when\": \"leading\", \"withHelpers\": \"flushAndCancel\" }\n\n/*\n.flush() doesn't actually make sense in the context of a leading-only debounce function,\nas there's nothing to flush - the callback has already been called.\n\nChoose a different combination of options :).\n*/\n\n//# CONFIG { \"when\": \"trailing\", \"withHelpers\": \"none\" }\n\n/**\n * Starts a countdown for `wait` ms.\n * Any invocations that happen during the countdown will reset the countdown\n * back to `wait` ms. When the countdown is done, the function `func` will be called.\n * @return The value that `func` returned when it was last called, or\n *   undefined if it hasn't been called yet.\n */\nfunction debounceTrailing(func, wait) {\n  let lastFuncResult = undefined;\n  let timeoutId = undefined;\n\n  const debounced = (...args) =&gt; {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() =&gt; {\n      timeoutId = undefined;\n      lastFuncResult = func(...args);\n    }, wait);\n\n    return lastFuncResult;\n  };\n\n  return debounced;\n}\n\n//# CONFIG { \"when\": \"trailing\", \"withHelpers\": \"cancel\" }\n\n/**\n * Starts a countdown for `wait` ms.\n * Any invocations that happen during the countdown will reset the countdown\n * back to `wait` ms. When the countdown is done, the function `func` will be called.\n * @return The value that `func` returned when it was last called, or\n *   undefined if it hasn't been called yet.\n */\nfunction debounceTrailing(func, wait) {\n  let lastFuncResult = undefined;\n  let timeoutId = undefined;\n\n  const debounced = (...args) =&gt; {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() =&gt; {\n      timeoutId = undefined;\n      lastFuncResult = func(...args);\n    }, wait);\n\n    return lastFuncResult;\n  };\n\n  debounced.cancel = () =&gt; {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n  };\n\n  return debounced;\n}\n\n//# CONFIG { \"when\": \"trailing\", \"withHelpers\": \"flushAndCancel\" }\n\n/**\n * Starts a countdown for `wait` ms.\n * Any invocations that happen during the countdown will reset the countdown\n * back to `wait` ms. When the countdown is done, the function `func` will be called.\n * @return The value that `func` returned when it was last called, or\n *   undefined if it hasn't been called yet.\n */\nfunction debounceTrailing(func, wait) {\n  let lastFuncResult = undefined;\n  let timeoutId = undefined;\n  let debouncedArgs = undefined; // This will only be set when timeoutId is also set\n\n  const onTimeout = () =&gt; {\n    timeoutId = undefined;\n    try {\n      lastFuncResult = func(...debouncedArgs);\n    } finally {\n      debouncedArgs = undefined;\n    }\n    return lastFuncResult;\n  };\n\n  const debounced = (...args) =&gt; {\n    debouncedArgs = args;\n\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(onTimeout, wait);\n\n    return lastFuncResult;\n  };\n\n  debounced.cancel = () =&gt; {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n      debouncedArgs = undefined;\n    }\n  };\n\n  debounced.flush = () =&gt; {\n    if (timeoutId === undefined) {\n      return lastFuncResult;\n    }\n\n    clearTimeout(timeoutId);\n    return onTimeout();\n  };\n\n  return debounced;\n}\n\n//# CONFIG { \"when\": \"leadingAndTrailing\", \"withHelpers\": \"none\" }\n\n/**\n * Invokes the function `func` then starts a countdown for `wait` ms.\n * Any further invocations that happen during the countdown will be ignored,\n * and will reset the countdown back to `wait` ms.\n * When the countdown expires, `func` will be called if there was an\n * attempt to call it during the countdown.\n * @return The value that `func` returned when it was last called.\n */\nfunction debounceLeadingAndTrailing(func, wait) {\n  let lastFuncResult;\n  let timeoutId = undefined;\n\n  const debounced = (...args) =&gt; {\n    if (timeoutId === undefined) {\n      // Invokes the function and starts a countdown\n      lastFuncResult = func(...args);\n      timeoutId = setTimeout(() =&gt; {\n        timeoutId = undefined;\n      }, wait);\n    } else {\n      // Ignores this call and resets the countdown.\n      // When the countdown ends, it'll now also call func() again.\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() =&gt; {\n        timeoutId = undefined;\n        lastFuncResult = func(...args);\n      }, wait);\n    }\n\n    return lastFuncResult;\n  };\n\n  return debounced;\n}\n\n//# CONFIG { \"when\": \"leadingAndTrailing\", \"withHelpers\": \"cancel\" }\n\n/**\n * Invokes the function `func` then starts a countdown for `wait` ms.\n * Any further invocations that happen during the countdown will be ignored,\n * and will reset the countdown back to `wait` ms.\n * When the countdown expires, `func` will be called if there was an\n * attempt to call it during the countdown.\n * @return The value that `func` returned when it was last called.\n */\nfunction debounceLeadingAndTrailing(func, wait) {\n  let lastFuncResult;\n  let timeoutId = undefined;\n\n  const debounced = (...args) =&gt; {\n    if (timeoutId === undefined) {\n      // Invokes the function and starts a countdown\n      lastFuncResult = func(...args);\n      timeoutId = setTimeout(() =&gt; {\n        timeoutId = undefined;\n      }, wait);\n    } else {\n      // Ignores this call and resets the countdown.\n      // When the countdown ends, it'll now also call func() again.\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() =&gt; {\n        timeoutId = undefined;\n        lastFuncResult = func(...args);\n      }, wait);\n    }\n\n    return lastFuncResult;\n  };\n\n  debounced.cancel = () =&gt; {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n  };\n\n  return debounced;\n}\n\n//# CONFIG { \"when\": \"leadingAndTrailing\", \"withHelpers\": \"flushAndCancel\" }\n\n/**\n * Invokes the function `func` then starts a countdown for `wait` ms.\n * Any further invocations that happen during the countdown will be ignored,\n * and will reset the countdown back to `wait` ms.\n * When the countdown expires, `func` will be called if there was an\n * attempt to call it during the countdown.\n * @return The value that `func` returned when it was last called.\n */\nfunction debounceLeadingAndTrailing(func, wait) {\n  let lastFuncResult;\n  let timeoutId = undefined;\n  // Set to undefined when no countdown is active or\n  // the function does not need to be called during timeout handling.\n  // Otherwise, set to a list of arguments that'll be sent to `func` during\n  // timeout handling.\n  let debouncedArgs = undefined;\n\n  const onTimeout = () =&gt; {\n    timeoutId = undefined;\n    if (debouncedArgs !== undefined) {\n      lastFuncResult = func(...debouncedArgs);\n    }\n    return lastFuncResult;\n  };\n\n  const debounced = (...args) =&gt; {\n    if (timeoutId === undefined) {\n      // Invokes the function and starts a countdown\n      lastFuncResult = func(...args);\n      debouncedArgs = undefined;\n      timeoutId = setTimeout(onTimeout, wait);\n    } else {\n      // Ignores this call and resets the countdown.\n      // When the countdown ends, it'll now also call func() again.\n      clearTimeout(timeoutId);\n      debouncedArgs = args;\n      timeoutId = setTimeout(onTimeout, wait);\n    }\n\n    return lastFuncResult;\n  };\n\n  debounced.cancel = () =&gt; {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n  };\n\n  debounced.flush = () =&gt; {\n    if (timeoutId === undefined) {\n      return lastFuncResult;\n    }\n\n    clearTimeout(timeoutId);\n    return onTimeout();\n  };\n\n  return debounced;\n}\n</code></pre>","src":null,"test":"// The below function is copied into description.md under\n//   //# CONFIG { \"when\": \"leading\", \"withHelpers\": \"none\" }\n//   (with the debounced.cancel() function removed)\n// and\n//   //# CONFIG { \"when\": \"leading\", \"withHelpers\": \"cancel\" }\n\n/**\n * Invokes the function `func` then starts a countdown for `wait` ms.\n * Any further invocations that happen during the countdown will be ignored,\n * and will reset the countdown back to `wait` ms.\n * @return The value that `func` returned when it was last called.\n */\nfunction debounceLeading(func, wait) {\n  let timeoutId = undefined;\n  let lastResult;\n\n  const debounced = (...args) => {\n    if (timeoutId === undefined) {\n      // Invokes the function and starts a countdown\n      lastResult = func(...args);\n      timeoutId = setTimeout(() => { timeoutId = undefined }, wait);\n    } else {\n      // Ignores this call and resets the countdown\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => { timeoutId = undefined }, wait);\n    }\n\n    return lastResult;\n  };\n\n  debounced.cancel = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n  };\n\n  return debounced;\n}\n\n// The below function is copied into description.md under\n//   //# CONFIG { \"when\": \"trailing\", \"withHelpers\": \"none\" }\n//   (with the debounced.cancel() function removed)\n// and\n//   //# CONFIG { \"when\": \"trailing\", \"withHelpers\": \"cancel\" }\n\n/**\n * Starts a countdown for `wait` ms.\n * Any invocations that happen during the countdown will reset the countdown\n * back to `wait` ms. When the countdown is done, the function `func` will be called.\n * @return The value that `func` returned when it was last called, or\n *   undefined if it hasn't been called yet.\n */\nfunction debounceTrailing(func, wait) {\n  let lastFuncResult = undefined;\n  let timeoutId = undefined;\n\n  const debounced = (...args) => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() => {\n      timeoutId = undefined;\n      lastFuncResult = func(...args);\n    }, wait);\n\n    return lastFuncResult;\n  };\n\n  debounced.cancel = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n  };\n\n  return debounced;\n}\n\n// The below function is copied into description.md under\n//   //# CONFIG { \"when\": \"trailing\", \"withHelpers\": \"flushAndCancel\" }\n//   (with the function renamed to simply debounceTrailing())\n\n/**\n * Starts a countdown for `wait` ms.\n * Any invocations that happen during the countdown will reset the countdown\n * back to `wait` ms. When the countdown is done, the function `func` will be called.\n * @return The value that `func` returned when it was last called, or\n *   undefined if it hasn't been called yet.\n */\nfunction debounceTrailingWithFlushSupport(func, wait) {\n  let lastFuncResult = undefined;\n  let timeoutId = undefined;\n  let debouncedArgs = undefined; // This will only be set when timeoutId is also set\n\n  const onTimeout = () => {\n    timeoutId = undefined;\n    try {\n      lastFuncResult = func(...debouncedArgs);\n    } finally {\n      debouncedArgs = undefined;\n    }\n    return lastFuncResult;\n  };\n\n  const debounced = (...args) => {\n    debouncedArgs = args;\n\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(onTimeout, wait);\n\n    return lastFuncResult;\n  };\n\n  debounced.cancel = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n      debouncedArgs = undefined;\n    }\n  };\n\n  debounced.flush = () => {\n    if (timeoutId === undefined) {\n      return lastFuncResult;\n    }\n\n    clearTimeout(timeoutId);\n    return onTimeout();\n  };\n\n  return debounced;\n}\n\n// The below function is copied into description.md under\n//   //# CONFIG { \"when\": \"leadingAndTrailing\", \"withHelpers\": \"none\" }\n//   (with the debounced.cancel() function removed)\n// and\n//   //# CONFIG { \"when\": \"leadingAndTrailing\", \"withHelpers\": \"cancel\" }\n\n/**\n * Invokes the function `func` then starts a countdown for `wait` ms.\n * Any further invocations that happen during the countdown will be ignored,\n * and will reset the countdown back to `wait` ms.\n * When the countdown expires, `func` will be called if there was an\n * attempt to call it during the countdown.\n * @return The value that `func` returned when it was last called.\n */\nfunction debounceLeadingAndTrailing(func, wait) {\n  let lastFuncResult;\n  let timeoutId = undefined;\n\n  const debounced = (...args) => {\n    if (timeoutId === undefined) {\n      // Invokes the function and starts a countdown\n      lastFuncResult = func(...args);\n      timeoutId = setTimeout(() => {\n        timeoutId = undefined;\n      }, wait);\n    } else {\n      // Ignores this call and resets the countdown.\n      // When the countdown ends, it'll now also call func() again.\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => {\n        timeoutId = undefined;\n        lastFuncResult = func(...args);\n      }, wait);\n    }\n\n    return lastFuncResult;\n  };\n\n  debounced.cancel = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n  };\n\n  return debounced;\n}\n\n// The below function is copied into description.md under\n//   //# CONFIG { \"when\": \"debounceLeadingAndTrailing\", \"withHelpers\": \"flushAndCancel\" }\n//   (with the function renamed to simply debounceLeadingAndTrailing())\n\n/**\n * Invokes the function `func` then starts a countdown for `wait` ms.\n * Any further invocations that happen during the countdown will be ignored,\n * and will reset the countdown back to `wait` ms.\n * When the countdown expires, `func` will be called if there was an\n * attempt to call it during the countdown.\n * @return The value that `func` returned when it was last called.\n */\nfunction debounceLeadingAndTrailingWithFlushSupport(func, wait) {\n  let lastFuncResult;\n  let timeoutId = undefined;\n  // Set to undefined when no countdown is active or\n  // the function does not need to be called during timeout handling.\n  // Otherwise, set to a list of arguments that'll be sent to `func` during\n  // timeout handling.\n  let debouncedArgs = undefined;\n\n  const onTimeout = () => {\n    timeoutId = undefined;\n    if (debouncedArgs !== undefined) {\n      lastFuncResult = func(...debouncedArgs);\n    }\n    return lastFuncResult;\n  };\n\n  const debounced = (...args) => {\n    if (timeoutId === undefined) {\n      // Invokes the function and starts a countdown\n      lastFuncResult = func(...args);\n      debouncedArgs = undefined;\n      timeoutId = setTimeout(onTimeout, wait);\n    } else {\n      // Ignores this call and resets the countdown.\n      // When the countdown ends, it'll now also call func() again.\n      clearTimeout(timeoutId);\n      debouncedArgs = args;\n      timeoutId = setTimeout(onTimeout, wait);\n    }\n\n    return lastFuncResult;\n  };\n\n  debounced.cancel = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n  };\n\n  debounced.flush = () => {\n    if (timeoutId === undefined) {\n      return lastFuncResult;\n    }\n\n    clearTimeout(timeoutId);\n    return onTimeout();\n  };\n\n  return debounced;\n}\n\nclass FakeTimeout {\n  #originals = {};\n  #now = 0;\n  #events = [];\n  #fakeSetTimeout(callback, ms = 0) {\n    if (!Number.isInteger(ms) || ms < 0) {\n      throw new Error(`Invalid timeout: ${ms}`);\n    }\n    const id = Math.floor(Math.random() * 1e8);\n    this.#events.push({ callback, fireAt: this.#now + ms, id });\n    return id;\n  }\n\n  #fakeClearTimeout(id) {\n    this.#events = this.#events.filter(event => event.id !== id);\n  }\n\n  tick(deltaMs, { expectedError = undefined } = {}) {\n    const newNow = this.#now + deltaMs;\n    this.#events.sort((a, b) => b.fireAt - a.fireAt);\n    while (this.#events.length > 0 && this.#events.at(-1).fireAt < newNow) {\n      const event = this.#events.pop();\n      // Update this.#now before calling event.callback(),\n      // because the callback() could, in turn, call setTimeout()\n      this.#now = event.fireAt;\n      try {\n        event.callback();\n      } catch (error) {\n        if (expectedError !== undefined && expectedError === error) {\n          // ignore it\n        } else {\n          throw error;\n        }\n      }\n      // Re-sorting events - it's possible that the callback registered another event.\n      this.#events.sort((a, b) => b.fireAt - a.fireAt);\n    }\n    this.#now = newNow;\n  }\n\n  flush() {\n    // Doing this in a loop, in case further events got registered after the flush happened\n    while (this.#events.length > 0) {\n      const furthestEventTime = Math.max(...this.#events.map(event => event.fireAt));\n      // The +1 is probably unnecessary, but doing it anyways.\n      this.tick(furthestEventTime - this.#now + 1);\n    }\n  }\n\n  areTherePendingTimers() {\n    return this.#events.length > 0;\n  }\n\n  getTimestamp() {\n    return this.#now;\n  }\n\n  install() {\n    this.#originals = {\n      setTimeout: globalThis.setTimeout,\n      clearTimeout: globalThis.clearTimeout,\n    };\n    globalThis.setTimeout = this.#fakeSetTimeout.bind(this);\n    globalThis.clearTimeout = this.#fakeClearTimeout.bind(this);\n  }\n\n  uninstall() {\n    globalThis.setTimeout = this.#originals.setTimeout;\n    globalThis.clearTimeout = this.#originals.clearTimeout;\n    this.#originals = {};\n  }\n}\n\n// What gets returned if no return value was specified.\nconst DEFAULT_RETURN_VALUE = Symbol('Default mock callback return value');\nclass MockCallback {\n  #eventTimes = [];\n  #returns = { value: DEFAULT_RETURN_VALUE }; // { value: ... } or { error: ... }\n  #fakeTimeout;\n  constructor(fakeTimeout) {\n    this.#fakeTimeout = fakeTimeout;\n  }\n\n  fn = () => {\n    this.#eventTimes.push(this.#fakeTimeout.getTimestamp());\n    if ('value' in this.#returns) {\n      return this.#returns.value;\n    } else {\n      throw this.#returns.error;\n    }\n  };\n\n  reset() {\n    this.#eventTimes = [];\n    this.#returns = { value: DEFAULT_RETURN_VALUE };\n  }\n\n  setReturnValue(value) {\n    this.#returns = { value };\n  }\n\n  throwWhenCalled(error) {\n    this.#returns = { error };\n  }\n\n  getCallCount() {\n    return this.#eventTimes.length;\n  }\n\n  wasCalledAt(timeStamp) {\n    return this.#eventTimes.some(eventTime => eventTime === timeStamp);\n  }\n\n  // Not actually used in any tests, but it can be helpful to call this to debug test issues.\n  _getAllCallTimes() {\n    return [...this.#eventTimes];\n  }\n}\n\nfunction multiTest(description, expectationGroups, testFn, { only = false } = {}) {\n  (only ? describe.only.bind(describe) : describe)(description, () => {\n    for (const { targets, expectations = undefined } of expectationGroups) {\n      for (const [name, target] of Object.entries(targets)) {\n        it(`${name}()`, () => testFn(target, expectations));\n      }\n    }\n  });\n}\n\nmultiTest.only = (description, expectationGroups, testFn) => multiTest(description, expectationGroups, testFn, { only: true });\n\ndescribe('debounce()', () => {\n  const DEBOUNCE_TIME = 10 * 1000; // 10 seconds\n\n  const fakeTimeout = new FakeTimeout();\n  const mockCallback = new MockCallback(fakeTimeout);\n  // Using the same debounced instances across all tests as an easy way to\n  // verify that debounced functions clean themselves up between\n  // different types of interactions.\n  const debounced = {\n    leading: debounceLeading(mockCallback.fn, DEBOUNCE_TIME),\n    trailing: debounceTrailing(mockCallback.fn, DEBOUNCE_TIME),\n    trailingWithFlushSupport: debounceTrailingWithFlushSupport(mockCallback.fn, DEBOUNCE_TIME),\n    leadingAndTrailing: debounceLeadingAndTrailing(mockCallback.fn, DEBOUNCE_TIME),\n    leadingAndTrailingWithFlushSupport: debounceLeadingAndTrailingWithFlushSupport(mockCallback.fn, DEBOUNCE_TIME),\n  };\n\n  beforeAll(() => {\n    fakeTimeout.install();\n  });\n\n  afterEach(() => {\n    fakeTimeout.flush();\n    mockCallback.reset();\n  });\n\n  afterAll(() => {\n    fakeTimeout.uninstall();\n  });\n\n  multiTest('repeated calls to the debounced function prevents the wrapped function from getting called', [\n    {\n      targets: {\n        debounceLeading: debounced.leading,\n        debounceTrailing: debounced.trailing,\n        debounceTrailingWithFlushSupport: debounced.trailingWithFlushSupport,\n      },\n      expectations: { callCount: 1 },\n    },\n    {\n      targets: {\n        debounceLeadingAndTrailing: debounced.leadingAndTrailing,\n        debounceLeadingAndTrailingWithFlushSupport: debounced.leadingAndTrailingWithFlushSupport,\n      },\n      // If multiple invocations happen during the debounce interval, and it's supposed\n      // to fire both on the leading and trailing end of the interval, then we'd expect\n      // the wrapped function to be called twice.\n      expectations: { callCount: 2 },\n    },\n  ], (debouncedFn, expectations) => {\n    for (let i = 0; i < 100; i++) {\n      debouncedFn();\n      fakeTimeout.tick(1000);\n    }\n    fakeTimeout.flush();\n\n    expect(mockCallback.getCallCount()).toEqual(expectations.callCount);\n  });\n\n  multiTest('An isolated call to the debounced function results in a single call to the wrapped function', [\n    {\n      targets: {\n        debounceLeading: debounced.leading,\n        debounceTrailing: debounced.trailing,\n        debounceTrailingWithFlushSupport: debounced.trailingWithFlushSupport,\n        // This test is especially important for these two functions.\n        // If multiple calls happen in quick succession, these two functions\n        // are configured to call the wrapped function twice - on the leading and trailing end of the interval.\n        // However, when only one call happens, these should only invoke the wrapped function once instead of twice.\n        debounceLeadingAndTrailing: debounced.leadingAndTrailing,\n        debounceLeadingAndTrailingWithFlushSupport: debounced.leadingAndTrailingWithFlushSupport,\n      },\n    },\n  ], debouncedFn => {\n    debouncedFn();\n    fakeTimeout.flush();\n\n    expect(mockCallback.getCallCount()).toEqual(1);\n  });\n\n  // Only applicable for a leading debounce function\n  multiTest('Calls the wrapped function on the leading end', [\n    {\n      targets: {\n        debounceLeading: debounced.leading,\n        debounceLeadingAndTrailing: debounced.leadingAndTrailing,\n        debounceLeadingAndTrailingWithFlushSupport: debounced.leadingAndTrailingWithFlushSupport,\n      },\n    },\n  ], debouncedFn => {\n    const startTime = fakeTimeout.getTimestamp();\n\n    debouncedFn();\n    fakeTimeout.tick(100);\n    debouncedFn();\n    fakeTimeout.tick(100);\n    debouncedFn();\n    fakeTimeout.flush();\n\n    expect(mockCallback.wasCalledAt(startTime)).toEqual(true);\n  });\n\n  // Only applicable for a trailing debounce function\n  multiTest('Calls the wrapped function on the trailing end', [\n    {\n      targets: {\n        debounceTrailing: debounced.trailing,\n        debounceTrailingWithFlushSupport: debounced.trailingWithFlushSupport,\n        debounceLeadingAndTrailing: debounced.leadingAndTrailing,\n        debounceLeadingAndTrailingWithFlushSupport: debounced.leadingAndTrailingWithFlushSupport,\n      },\n    },\n  ], debouncedFn => {\n    debouncedFn();\n    fakeTimeout.tick(100);\n    debouncedFn();\n    fakeTimeout.tick(100);\n    debouncedFn();\n    const lastCallTime = fakeTimeout.getTimestamp();\n    fakeTimeout.flush();\n\n    expect(mockCallback.wasCalledAt(lastCallTime + DEBOUNCE_TIME)).toEqual(true);\n  });\n\n  // Only applicable for leading debounce functions\n  multiTest('Memoizes the return value from the leading call', [\n    {\n      targets: {\n        debounceLeading: debounced.leading,\n        debounceLeadingAndTrailing: debounced.leadingAndTrailing,\n        debounceLeadingAndTrailingWithFlushSupport: debounced.leadingAndTrailingWithFlushSupport,\n      },\n    },\n  ], debouncedFn => {\n    mockCallback.setReturnValue('THE_RETURN_VALUE');\n    debouncedFn();\n    mockCallback.setReturnValue('NOT_THE_RETURN_VALUE');\n\n    fakeTimeout.tick(100);\n    expect(debouncedFn()).toBe('THE_RETURN_VALUE');\n  });\n\n  // only applicable for trailing-only debounce functions\n  multiTest('returns undefined if no value has been memoized yet', [\n    {\n      targets: {\n        // Using fresh debounce instances, because this undefined-returning behavior only happens\n        // with fresh instances.\n        debounceTrailing: debounceTrailing(mockCallback.fn, DEBOUNCE_TIME),\n        debounceTrailingWithFlushSupport: debounceTrailingWithFlushSupport(mockCallback.fn, DEBOUNCE_TIME),\n      },\n    },\n  ], debouncedFn => {\n    mockCallback.setReturnValue('THE_RETURN_VALUE');\n\n    expect(debouncedFn()).toBe(undefined);\n    // Even after a bit of time, it still behaves the same\n    fakeTimeout.tick(100);\n    expect(debouncedFn()).toBe(undefined);\n  });\n\n  // This is only applicable for trailing-only debounce functions, because leading debounce functions\n  // will simply call the wrapped function again at this point in time and get a new value to memoize.\n  multiTest('returns the memoized value shortly after the trailing end of the wait window', [\n    {\n      targets: {\n        debounceTrailing: debounced.trailing,\n        debounceTrailingWithFlushSupport: debounced.trailingWithFlushSupport,\n      },\n    },\n  ], debouncedFn => {\n    mockCallback.setReturnValue('THE_RETURN_VALUE');\n    debouncedFn();\n\n    fakeTimeout.tick(DEBOUNCE_TIME + 100);\n    mockCallback.setReturnValue('NOT_THE_RETURN_VALUE');\n\n    expect(debouncedFn()).toBe('THE_RETURN_VALUE');\n  });\n\n  // Only applicable for leading debounce functions\n  multiTest('recovers if a callback called on the leading end of the debounce window throws', [\n    {\n      targets: {\n        debounceLeading: debounced.leading,\n        debounceLeadingAndTrailing: debounced.leadingAndTrailing,\n        debounceLeadingAndTrailingWithFlushSupport: debounced.leadingAndTrailingWithFlushSupport,\n      },\n    },\n  ], debouncedFn => {\n    const error = new Error('Wuh Woh!');\n    mockCallback.throwWhenCalled(error);\n\n    // Just showing that when we start, no timers are scheduled\n    expect(fakeTimeout.areTherePendingTimers()).toBe(false);\n\n    expect(debouncedFn).toThrow('Wuh Woh!');\n\n    // After it's been called, we should stay in the exact same state,\n    // which means no timers should be scheduled still.\n    // Timers aren't needed, because the way we're implementing this,\n    // we don't want to start a debounce window unless the\n    // callback returns successfully.\n    expect(fakeTimeout.areTherePendingTimers()).toBe(false);\n  });\n\n  // This set of tests only handles leading debounce functions.\n  // There's another set of tests below for the trailing-only functions that test the same thing\n  multiTest('recovers if a callback called on the trailing end throws', [\n    {\n      targets: {\n        debounceLeading: debounced.leading,\n        debounceLeadingAndTrailing: debounced.leadingAndTrailing,\n        debounceLeadingAndTrailingWithFlushSupport: debounced.leadingAndTrailingWithFlushSupport,\n      },\n    },\n  ], debouncedFn => {\n    debouncedFn();\n\n    const error = new Error('Wuh Woh!');\n    mockCallback.throwWhenCalled(error);\n\n    // It throws an error while trying to auto-call the callback at the trailing end\n    fakeTimeout.tick(DEBOUNCE_TIME + 100, { expectedError: error });\n\n    // Things still work as normal afterwards, e.g. it'll still cache return values and what-not.\n    fakeTimeout.tick(100);\n    mockCallback.setReturnValue('NEW_RETURN_VALUE');\n    expect(debouncedFn()).toBe('NEW_RETURN_VALUE');\n  });\n\n  // This set of tests only handles trailing-only debounce functions.\n  // There's another set of tests below for the leading functions that test the same thing\n  multiTest('recovers if a callback called on the trailing end throws', [\n    {\n      targets: {\n        debounceTrailing: debounced.trailing,\n        debounceTrailingWithFlushSupport: debounced.trailingWithFlushSupport,\n      },\n    },\n  ], debouncedFn => {\n    // Get an old value into the cache\n    mockCallback.setReturnValue('OLD_RETURN_VALUE');\n    debouncedFn();\n    fakeTimeout.tick(DEBOUNCE_TIME + 100);\n\n    // Start a new time window\n    mockCallback.setReturnValue('NEW_RETURN_VALUE_1');\n    debouncedFn();\n\n    // Throw an error after the trailing end of the new time window\n    // (which means, nothing will be cached from this time window)\n    const error = new Error('Wuh Woh!');\n    mockCallback.throwWhenCalled(error);\n    // It throws an error while trying to auto-call the callback at the trailing end\n    fakeTimeout.tick(DEBOUNCE_TIME + 100, { expectedError: error });\n\n    // Things still work as normal afterwards, e.g. it'll still pull the old value from the cache and what-not\n    fakeTimeout.tick(100);\n    mockCallback.setReturnValue('NEW_RETURN_VALUE_2');\n    expect(debouncedFn()).toBe('OLD_RETURN_VALUE');\n  });\n\n  // Only applicable for a leading debounce function\n  multiTest('cancel() cancels timers, letting you re-trigger leading-edge behavior', [\n    {\n      targets: {\n        debounceLeading: debounced.leading,\n        debounceLeadingAndTrailing: debounced.leadingAndTrailing,\n        debounceLeadingAndTrailingWithFlushSupport: debounced.leadingAndTrailingWithFlushSupport,\n      },\n    },\n  ], debouncedFn => {\n    debouncedFn();\n    fakeTimeout.tick(100);\n\n    expect(mockCallback.getCallCount()).toEqual(1);\n\n    debouncedFn.cancel();\n    debouncedFn();\n    expect(mockCallback.getCallCount()).toEqual(2);\n  });\n\n  // Only applicable for a trailing debounce function\n  multiTest('cancel() cancels timers, preventing the callback from getting called on the trailing end', [\n    {\n      targets: {\n        debounceTrailing: debounced.trailing,\n      },\n      expectations: { callCount: 0 },\n    },\n    {\n      targets: {\n        debounceLeadingAndTrailing: debounced.leadingAndTrailing,\n        debounceLeadingAndTrailingWithFlushSupport: debounced.leadingAndTrailingWithFlushSupport,\n      },\n      // It gets called once on the leading end\n      expectations: { callCount: 1 },\n    },\n  ], (debouncedFn, expectations) => {\n    debouncedFn();\n    debouncedFn.cancel();\n\n    expect(mockCallback.getCallCount()).toEqual(expectations.callCount);\n\n    // Make what would have been the debounce time window pass.\n    fakeTimeout.tick(DEBOUNCE_TIME + 100);\n\n    // The number of calls hasn't changed, even though we\n    // passed what would have been the trailing-end point of the time window.\n    expect(mockCallback.getCallCount()).toEqual(expectations.callCount);\n  });\n});\n"},{"name":"defer","manifest":{"fnSignature":"_.defer(func, ...args)","lodashLink":"https://lodash.com/docs/4.17.15#defer","summaryHtml":"<p>Defers invoking the <code>func</code> until the current call stack has cleared. Any additional arguments are provided to <code>func</code> when it's invoked.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">setTimeout(fn)\n// or\nsetTimeout(fn, 0, ...args)\n</code></pre>\n<p>If the timeout is omitted, it's the same as setting it to zero, which causes the function to run on the next event loop cycle assuming <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#reasons_for_delays_longer_than_specified\">it doesn't get delayed, which can happen for various reasons</a>.</p>\n<p>Lodash's implementation will actually use a timeout of <code>1</code> instead of <code>0</code>, which means there will always be a <code>1ms</code> delay when using their implementation. Browsers in general also used to clamp <code>setTimeout()</code> to a minimum, but those restrictions have since been removed (<a href=\"https://chromestatus.com/feature/4889002157015040\">Here's one example of Chrome removing their 1ms clamping restriction</a>).</p>\n<p>Please use <code>setTimeout(fn, 0)</code> as a last resort. If you need to wait for other code to finish running, prefer letting that other code tell you when it's finished running instead of trying to automatically figure it out based on when the call stack empties. Using <code>setTimeout(fn, 0)</code> means the code you're waiting on can't also use <code>setTimeout(fn, 0)</code> without causing your code to break (i.e. this hack can only be used so many times), and it means your code is at the mercy of running whenever <code>setTimeout()</code> lets it, which isn't always immediate.</p>","src":null,"test":""},{"name":"delay","manifest":{"fnSignature":"_.delay(func, wait, ...args)","lodashLink":"https://lodash.com/docs/4.17.15#delay","summaryHtml":"<p>Invokes <code>func</code> after <code>wait</code> milliseconds. Any additional arguments are provided to <code>func</code> when it's invoked.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">setTimeout(func, wait, ...args)\n</code></pre>","src":null,"test":""},{"name":"flip","manifest":{"fnSignature":"_.flip(func)","lodashLink":"https://lodash.com/docs/4.17.15#flip","summaryHtml":"<p>Creates a function that invokes <code>func</code> with arguments reversed.</p>"},"descriptionHtml":"<p>Flipping a function's arguments is a technique that is sometimes done to facilitate point-free programming, a programming style that JavaScript wasn't really designed to support. You can do it, but without the help of a third-party library, you'll just be fighting against the language every step of the way. If you want to do point-free programming, you are better off adopting a library such as Rambda, which basically provides an alternative standard library built from the ground up to make point-free programming much easier to handle, as well as providing utility functions such as this flip function.</p>\n<p>That being said, if you really want your own implementation of the flip function, you can use the following:</p>\n<pre><code class=\"javascript language-javascript\">function flip(func) {\n  return function (...args) {\n    // Using .call() may be overkill.\n    // You could just do `return func(...args.reverse())` if you\n    // don't need to worry about preserving the \"this\" argument.\n    return func.call(this, ...args.reverse());\n  };\n}\n</code></pre>","src":null,"test":"describe('flip()', () => {\n  function flip(func) {\n    return function (...args) {\n      // Using .call() may be overkill.\n      // You could just do `return func(...args.reverse())` if you\n      // don't need to worry about preserving the \"this\" argument.\n      return func.call(this, ...args.reverse());\n    };\n  }\n\n  it('can flip the arguments of a function', () => {\n    const fn = flip((a, b) => a + b);\n    expect(fn('a', 'b')).toEqual('ba');\n  });\n\n  it('preserves the \"this\" argument', () => {\n    let self;\n    const fn = flip(function () {\n      self = this;\n    });\n\n    const myThis = { x: 2 };\n    fn.call(myThis);\n\n    expect(self).toEqual(myThis);\n  });\n});\n"},{"name":"memoize","manifest":{"fnSignature":"_.memoize(func, resolver?)","lodashLink":"https://lodash.com/docs/4.17.15#memoize","summaryHtml":"<p>Creates a function that memoizes the result of <code>func</code>. If <code>resolver</code> is provided, it determines the cache key for storing the result based on the arguments provided to the memoized function. By default, the first argument provided to the memoized function is used as the map cache key.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function defaultResolver(...args) {\n  if (args.length !== 1) {\n    throw new Error(\n      'Exactly one argument must be passed in to this memoized function ' +\n      '(unless a custom resolver function is provided)',\n    );\n  }\n  return args[0];\n}\n\nfunction memoize(fn, resolver = defaultResolver) {\n  const cache = new Map();\n  return function (...args) {\n    const key = resolver(...args);\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n\n    // Using .call() may be overkill.\n    // You could just do `const res = fn(...args);` if you\n    // don't need to worry about preserving the \"this\" argument.\n    const res = fn.call(this, ...args);\n    cache.set(key, res);\n    return res;\n  };\n}\n</code></pre>\n<p>The default resolver behavior in the above implementation is to cache the result based on the first argument, but unlike Lodash's <code>_.memoize()</code>, it will also require that only one argument is supplied, in order to help avoid accidental mis-use. If you want a resolver that behave's more like Lodash's, just pass in <code>x =&gt; x</code> as your resolver function.</p>","src":null,"test":""},{"name":"negate","manifest":{"fnSignature":"_.negate(predicate)","lodashLink":"https://lodash.com/docs/4.17.15#negate","summaryHtml":"<p>Creates a function that negates the result of the predicate <code>func</code>.</p>"},"descriptionHtml":"<p>Instead of this:</p>\n<pre><code class=\"javascript language-javascript\">function isEven(n) {\n  return n % 2 == 0;\n}\n\n[1, 2, 3, 4, 5, 6].filter(_.negate(isEven)) // =&gt; [1, 3, 5]\n</code></pre>\n<p>just use an arrow function like this:</p>\n<pre><code class=\"javascript language-javascript\">[1, 2, 3, 4, 5, 6].filter(n =&gt; !isEven(n)) // =&gt; [1, 3, 5]\n</code></pre>","src":null,"test":""},{"name":"once","manifest":{"fnSignature":"_.once(func)","lodashLink":"https://lodash.com/docs/4.17.15#once","summaryHtml":"<p>Creates a function that is restricted to invoking <code>func</code> once. Repeat calls to the function return the value of the first invocation.</p>"},"descriptionHtml":"<p>If you need to do this in a one-off situation, you can generally just modify your existing function to make it so it can only be called once, like this:</p>\n<pre><code class=\"javascript language-javascript\">let resultOfExpensiveTask = undefined;\nasync function doExpensiveTask() {\n  if (resultOfExpensiveTask !== undefined) {\n    return resultOfExpensiveTask;\n  }\n\n  resultOfExpensiveTask = JSON.parse(await fetchResource());\n  return resultOfExpensiveTask;\n}\n</code></pre>\n<p>If you need a helper function similar to Lodash's <code>_.once()</code>, you can use the following:</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">/*# METADATA\n[\n  {\n    \"id\": \"forwardThis\",\n    \"type\": \"radio\",\n    \"message\": \"Do you need to forward the \\\"this\\\" parameter from the caller to the callback? (Usually this isn't necessary)\",\n    \"default\": \"no\",\n    \"options\": {\n      \"no\": \"No\",\n      \"yes\": \"Yes\"\n    }\n  }\n]\n#*/\n\n//# CONFIG { \"forwardThis\": \"no\" }\n\nfunction once(func) {\n  let cachedResult;\n  let hasCachedResult = false;\n  return (...args) =&gt; {\n    if (hasCachedResult) {\n      return cachedResult;\n    }\n\n    hasCachedResult = true;\n    cachedResult = func(...args);\n    return cachedResult;\n  };\n}\n\n//# CONFIG { \"forwardThis\": \"yes\" }\n\nfunction once(func) {\n  let cachedResult;\n  let hasCachedResult = false;\n  return function (...args) {\n    if (hasCachedResult) {\n      return cachedResult;\n    }\n\n    hasCachedResult = true;\n    cachedResult = func.call(this, ...args);\n    return cachedResult;\n  };\n}\n</code></pre>","src":null,"test":"function once(func) {\n  let cachedResult;\n  let hasCachedResult = false;\n  return function (...args) {\n    if (hasCachedResult) {\n      return cachedResult;\n    }\n\n    hasCachedResult = true;\n    cachedResult = func.call(this, ...args);\n    return cachedResult;\n  };\n}\n\ndescribe('once()', () => {\n  it('returns the last result after one calls', () => {\n    const fn = once(x => x ** 2);\n\n    expect(fn(2)).toEqual(4);\n    // Regardless of what is passed in, we always get the first answer back\n    expect(fn(3)).toEqual(4);\n    expect(fn(4)).toEqual(4);\n    expect(fn(5)).toEqual(4);\n  });\n\n  it('preserves the \"this\" argument', () => {\n    let self;\n    const fn = once(function () {\n      self = this;\n    });\n\n    const myThis = { x: 2 };\n    fn.call(myThis);\n\n    expect(self).toEqual(myThis);\n  });\n});\n"},{"name":"overArgs","manifest":{"fnSignature":"_.overArgs(func, transforms)","lodashLink":"https://lodash.com/docs/4.17.15#overArgs","summaryHtml":"<p>Creates a function that invokes <code>func</code> with its arguments transformed.</p>"},"descriptionHtml":"<p>Instead of this:</p>\n<pre><code class=\"javascript language-javascript\">const doubled = n =&gt; n * 2;\nconst square = n =&gt; n ** 2;\nconst originalFunc = (x, y) =&gt; [x, y];\n\nconst wrappedFunc = _.overArgs(originalFunc, [square, doubled]);\n\nwrappedFunc(9, 3); // =&gt; [81, 6]\n</code></pre>\n<p>just create a new function like this:</p>\n<pre><code class=\"javascript language-javascript\">const doubled = n =&gt; n * 2;\nconst square = n =&gt; n ** 2;\nconst originalFunc = (x, y) =&gt; [x, y];\n\nfunction wrappedFunc(x, y) {\n  return originalFunc(square(x), doubled(y));\n}\n\nwrappedFunc(9, 3); // =&gt; [81, 6]\n</code></pre>","src":null,"test":""},{"name":"rest","manifest":{"fnSignature":"_.rest(func, start?)","lodashLink":"https://lodash.com/docs/4.17.15#rest","summaryHtml":"<p>Creates a function that invokes <code>func</code> with the <code>this</code> binding of the created function and arguments from <code>start</code> and beyond provided as an array.</p>"},"descriptionHtml":"<p>Instead of this:</p>\n<pre><code class=\"javascript language-javascript\">const buildMessage = _.rest((key, values) =&gt; {\n  return `${key}: ${values.join(', ')}`;\n});\n\nbuildMessage('users', 'fred', 'barney', 'pebbles'); // =&gt; 'users: fred, barney, pebbles'\n</code></pre>\n<p>Use the \"rest\" syntax.</p>\n<pre><code class=\"javascript language-javascript\">const buildMessage = (key, ...values) =&gt; {\n  return `${key}: ${values.join(', ')}`;\n};\n\nbuildMessage('users', 'fred', 'barney', 'pebbles'); // =&gt; 'users: fred, barney, pebbles'\n</code></pre>","src":null,"test":""},{"name":"spread","manifest":{"fnSignature":"_.spread(func, start?)","lodashLink":"https://lodash.com/docs/4.17.15#spread","summaryHtml":"<p>Creates a function that invokes <code>func</code> with the <code>this</code> binding of the <code>create</code> function and an array of arguments much like <code>Function.prototype.apply</code>.</p>"},"descriptionHtml":"<p>Instead of using <code>_.spread()</code>, you can use the spread syntax to spread arguments at the call site, such as what's seen in this example:</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">// -- An example from their documentation --\nvar say = _.spread(function(who, what) {\n  return who + ' says ' + what;\n});\n\nsay(['fred', 'hello']);\n// =&gt; 'fred says hello'\n</code></pre>\n<pre><code class=\"javascript language-javascript\">// -- The example re-written to use spread syntax --\nfunction say(who, what) {\n  return who + ' says ' + what;\n};\n\nsay(...['fred', 'hello']); // or, in this specific case, say('fred', 'hello') does the same thing.\n// =&gt; 'fred says hello'\n</code></pre>\n<p>They also provided an example where it wasn't convenient to use spread syntax at the call site - in this particular case, you can just destructure the parameters.</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">// -- An example from their documentation --\nvar numbers = Promise.all([\n  Promise.resolve(40),\n  Promise.resolve(36)\n]);\n\nnumbers.then(_.spread(function(x, y) {\n  return x + y;\n}));\n// =&gt; a Promise of 76\n</code></pre>\n<!-- eslint-disable @stylistic/comma-dangle -->\n<pre><code class=\"javascript language-javascript\">// -- The example re-written to use destructuring --\nconst numbers = Promise.all([\n  Promise.resolve(40),\n  Promise.resolve(36)\n]);\n\nnumbers.then(([x, y]) =&gt; x + y);\n// =&gt; a Promise of 76\n</code></pre>\n<!-- eslint-disable @stylistic/comma-dangle -->\n<pre><code class=\"javascript language-javascript\">// -- The example re-written to also make use of async/await --\nconst [x, y] = await Promise.all([\n  Promise.resolve(40),\n  Promise.resolve(36)\n]);\n\nx + y;\n// =&gt; 76\n</code></pre>","src":null,"test":""},{"name":"unary","manifest":{"fnSignature":"_.unary(func)","lodashLink":"https://lodash.com/docs/4.17.15#unary","summaryHtml":"<p>Creates a function that accepts up to one argument, ignoring any additional arguments.</p>"},"descriptionHtml":"<p>You can get the same effect by simply using arrow function syntax.</p>\n<pre><code class=\"javascript language-javascript\">// With Lodash\n['6', '8', '10'].map(_.unary(parseInt)) // =&gt; [6, 8, 10]\n</code></pre>\n<pre><code class=\"javascript language-javascript\">// Without Lodash\n['6', '8', '10'].map(s =&gt; parseInt(s)) // =&gt; [6, 8, 10]\n</code></pre>\n<p>In case you weren't aware, <code>.map()</code> supplies multiple parameters to its callbacks, including an index, and <code>parseInt()</code> can accept a second parameter, a base, so simply plugging the two together with <code>['6', '8', '10'].map(parseInt)</code> will result in the index being fed into the base parameter, resulting in <code>[6, NaN, 2]</code>. This is why it's important to use an arrow function (or <code>_.unary</code>) to force additional parameters to be ignored.</p>\n<p>In general, it's good to avoid passing in more arguments than what a function takes - even if the function you're calling is just ignoring those additional parameters, there's no guarantee that it won't stay that way - often, functions are changed to support additional optional parameters, and this is usually not considered a breaking change - don't let that kind of change break your code. So, for example, prefer <code>array.map(x =&gt; Number(x))</code> over <code>array.map(Number)</code> - both of these will technically behave the same today, but if the JavaScript committee were to ever add a second, optional parameter to <code>Number</code>, then any code with <code>array.map(Number)</code> would break (In reality, they're unlikely to ever make this specific change to <code>Number()</code> because so many people have written <code>array.map(Number)</code> in their code, but they do often make other similar changes to other functions).</p>","src":null,"test":""},{"name":"wrap","manifest":{"fnSignature":"_.wrap(value, wrapper)","lodashLink":"https://lodash.com/docs/4.17.15#wrap","summaryHtml":"<p>Creates a function that provides <code>value</code> to <code>wrapper</code> as its first argument. Any additional arguments provided to the function are appended to those provided to the <code>wrapper</code>.</p>"},"descriptionHtml":"<p>You can get the same effect by simply using arrow function syntax.</p>\n<pre><code class=\"javascript language-javascript\">const add = (x, y) =&gt; x + y;\n</code></pre>\n<pre><code class=\"javascript language-javascript\">// With Lodash\nconst addOne = _.wrap(1, add);\naddOne(2) // =&gt; 3\n</code></pre>\n<pre><code class=\"javascript language-javascript\">// Without Lodash\nconst addOne = x =&gt; add(1, x);\naddOne(2) // =&gt; 3\n</code></pre>\n<p><code>.bind()</code> is technically able to accomplish this task as well. Pass in the correct <code>this</code> value as the first parameter (or <code>undefined</code> if it is not needed), then pass in any additional parameters that you want to be automatically supplied to the function being called.</p>\n<pre><code class=\"javascript language-javascript\">const addOne = add.bind(undefined, 1);\naddOne(2) // =&gt; 3\n</code></pre>\n<p>I personally would recommend just going with arrow functions - there's no real advantage to using <code>.bind()</code>, and arrow functions are simpler for others to understand.</p>","src":null,"test":""}]},{"categoryHeading":"Lang","entries":[{"name":"castArray","manifest":{"fnSignature":"_.castArray(value)","lodashLink":"https://lodash.com/docs/4.17.15#castArray","summaryHtml":"<p>Casts <code>value</code> as an array if it's not one.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">Array.isArray(value) ? value : [value]\n</code></pre>","src":null,"test":""},{"name":"clone","manifest":{"fnSignature":"_.clone(value)","lodashLink":"https://lodash.com/docs/4.17.15#clone","summaryHtml":"<p>Creates a shallow clone of <code>value</code>.</p>"},"descriptionHtml":"<p>To shallow-clone a value, you can simply use the API provided by the specific object type you have. If a particular class doesn't provide any particular way to clone a value, then it may not be possible clone it - not even Lodash's <code>_.cone()</code> will be able to help.</p>\n<p>Here are a few different ways to create shallow clones of various built-in data types.</p>\n<ul>\n<li>Primitives (such as strings, numbers, booleans, etc): It's not possible to clone these. You also don't need to - they're immutable anyways.</li>\n<li>Objects: Use the spread syntax, e.g. <code>const newObj = { ...oldObj };</code></li>\n<li>Arrays: Use the spread syntax, e.g. <code>const newArray = [...oldArray];</code></li>\n<li>Maps: <code>const newMap = new Map(oldMap);</code></li>\n<li>Sets: <code>const newSet = new Set(oldSet);</code></li>\n<li>Dates: <code>const newDate = new Date(oldDate)</code></li>\n<li>Regular Expressions: <code>const newRegex = new RegExp(oldRegex); newRegex.lastIndex = oldRegex.lastIndex;</code>. The <code>lastIndex</code> property holds state related to where the regular expression was last searching in a given string - depending on your use-case, it may or may not make sense to preserve this information when cloning.</li>\n<li>Array Buffers: <code>const newArrayBuffer = oldArrayBuffer.slice();</code></li>\n<li>typed arrays: As these are just views on array buffers, they don't need to be cloned - unless you're trying to clone both the view and the underlying array buffer, in which case, use the <code>.buffer</code> property on your typed array to get access to the underlying buffer, clone it with <code>.slice()</code>, then build a new type array of the same type from the cloned buffer. Put together, for <code>Uint8Array</code>, this would look like <code>const newTypedArray = new Uint8Array(oldTypedArray.buffer.slice())</code>.</li>\n</ul>","src":null,"test":""},{"name":"cloneDeep","manifest":{"fnSignature":"_.cloneDeep(value)","lodashLink":"https://lodash.com/docs/4.17.15#cloneDeep","summaryHtml":"<p>This method is like <code>_.clone</code> except that it recursively clones value.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">structuredClone(value)\n</code></pre>\n<p><code>_.cloneDeep()</code> is loosely based off of the structured clone algorithm, the same algorithm that is provided to you natively with the <code>structuredClone()</code> function. The structured clone algorithm can be useful for simpler scenarios, but it has severe limitations that you should be aware of:</p>\n<ul>\n<li>many objects, such as <code>ArrayBuffer</code> instances, will have ownership of their data transferred to their clone, rendering the original unusable. A complete list of transferable objects can be found <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Transferable_objects#supported_objects\">on MDN's website</a>.</li>\n<li>Some values, like functions, can not be cloned.</li>\n<li>Some objects lose data when they get cloned. This includes the prototypes of most objects (making it impossible to properly clone instances of any userland class), getters and setters, some data stored on regular expression instances, etc.</li>\n</ul>\n<p>For a complete reference to the algorithm's limitations, please refer to the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\">structured clone algorithm page</a> on MDN.</p>\n<p>If <code>structuredClone()</code> doesn't suit your needs (because, e.g., maybe you have userland instances that you wish to clone), you'll have to build up your own cloning algorithm by hand, according to your use-case. Here's a simple version to get you started - it shows examples of how you would deep-clone a handful of different types of data. It's up to you to add or remove functionality as needed. Note that this version does not support circular references - if you need to support that, you'll additionally need to keep around a set containing each value you've visited to make sure you're not going in a loop.</p>\n<pre><code class=\"javascript language-javascript\">const isObject = value =&gt; ['object', 'function'].includes(typeof value) &amp;&amp; value !== null;\n\nfunction cloneDeep(value) {\n  if (!isObject(value)) {\n    // It's a primitive, which is immutable, so we don't need to clone it.\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(cloneDeep);\n  } else if (value instanceof Map) {\n    return new Map(\n      [...value].map(([key, value]) =&gt; [cloneDeep(key), cloneDeep(value)]),\n    );\n  } else if (value instanceof Set) {\n    return new Set(\n      [...value].map(x =&gt; cloneDeep(x)),\n    );\n  } else if (Object.getPrototypeOf(value) === Object.prototype) {\n    return Object.fromEntries(\n      Object.entries(value).map(([key, value]) =&gt; [key, cloneDeep(value)]),\n    );\n  } else if (Object.getPrototypeOf(value) === null) {\n    const newObject = Object.fromEntries(\n      Object.entries(value).map(([key, value]) =&gt; [key, cloneDeep(value)]),\n    );\n    Object.setPrototypeOf(newObject, null);\n    return newObject;\n  } else {\n    throw new Error(`Can not clone an instance of ${value.constructor?.name}`);\n  }\n}\n</code></pre>","src":null,"test":""},{"name":"eq","manifest":{"fnSignature":"_.eq(value, other)","lodashLink":"https://lodash.com/docs/4.17.15#eq","summaryHtml":"<p>Performs a <code>SameValueZero</code> comparison between two values to determine if they are equivalent.</p>"},"descriptionHtml":"<p>To check if two values are exactly the same, use <code>Object.is(x, y)</code> (which follows the <code>SameValue</code> algorithm).</p>\n<p>If you want a slightly looser algorithm that considers <code>-0</code> and <code>+0</code> to be the same, use the <code>SameValueZero</code> algorithm. This is the same algorithm that Lodash uses in it's <code>_.eq()</code> implementation, and also the same algorithm the JavaScript language uses in many of it's built-in functions, such as <code>array.includes()</code>. This algorithm can be implemented as follows:</p>\n<pre><code class=\"javascript language-javascript\">function sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) &amp;&amp; Number.isNaN(y));\n}\n</code></pre>\n<p>If you want an algorithm that also conforms to the IEEE floating point spec, which states that <code>NaN</code> is not supposed to be considered equal to itself, use JavaScript's strict equality operator (<code>x === y</code>).</p>\n<p>If you don't know what to use, use JavaScript's strict equality operator (<code>x === y</code>).</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness\">Refer to MDN for a deeper discussion on JavaScript's comparison algorithms</a>.</p>","src":null,"test":"function sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) && Number.isNaN(y));\n}\n\ndescribe('sameValueZero()', () => {\n  it('considers -0 and +0 to be equal', () => {\n    expect(sameValueZero(-0, 0)).toEqual(true);\n  });\n\n  it('considers NaN to equal NaN', () => {\n    expect(sameValueZero(NaN, NaN)).toEqual(true);\n  });\n\n  it('considers different values of the same type to not be equal', () => {\n    expect(sameValueZero(1, 2)).toEqual(false);\n  });\n\n  it('considers values of different types to not be equal', () => {\n    expect(sameValueZero(1, '1')).toEqual(false);\n  });\n\n  it('considers references to the same object to be equal', () => {\n    const myObj = {};\n    expect(sameValueZero(myObj, myObj)).toEqual(true);\n    expect(sameValueZero(myObj, {})).toEqual(false);\n  });\n});\n"},{"name":"gt","manifest":{"fnSignature":"_.gt(value, other)","lodashLink":"https://lodash.com/docs/4.17.15#gt","summaryHtml":"<p>Checks if <code>value</code> is greater than <code>other</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">value &gt; other\n</code></pre>\n<p>One reason <code>_.gt()</code> exists, is because it's a ready-made function, that can easily be passed into other functions, like this:</p>\n<pre><code class=\"javascript language-javascript\">_.zipWith([1, 2, 3], [3, 2, 1], _.gt) // =&gt; [false, false, true]\n</code></pre>\n<p>When Lodash was first born, the only alternative at the time would be to create an entire function, using the <code>function</code> keyword.</p>\n<pre><code class=\"javascript language-javascript\">_.zipWith([1, 2, 3], [3, 2, 1], function (a, b) {\n  return a &gt; b;\n})\n</code></pre>\n<p>Since then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.</p>\n<pre><code class=\"javascript language-javascript\">_.zipWith([1, 2, 3], [3, 2, 1], (a, b) =&gt; a &gt; b)\n</code></pre>","src":null,"test":""},{"name":"gte","manifest":{"fnSignature":"_.gte(value, other)","lodashLink":"https://lodash.com/docs/4.17.15#gte","summaryHtml":"<p>Checks if <code>value</code> is greater than or equal to <code>other</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">value &gt;= other\n</code></pre>\n<p>One reason <code>_.gte()</code> exists, is because it's a ready-made function, that can easily be passed into other functions, like this:</p>\n<pre><code class=\"javascript language-javascript\">_.zipWith([1, 2, 3], [3, 2, 1], _.gte) // =&gt; [false, true, true]\n</code></pre>\n<p>When Lodash was first born, the only alternative at the time would be to create an entire function, using the <code>function</code> keyword.</p>\n<pre><code class=\"javascript language-javascript\">_.zipWith([1, 2, 3], [3, 2, 1], function (a, b) {\n  return a &gt;= b;\n})\n</code></pre>\n<p>Since then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.</p>\n<pre><code class=\"javascript language-javascript\">_.zipWith([1, 2, 3], [3, 2, 1], (a, b) =&gt; a &gt;= b)\n</code></pre>","src":null,"test":""},{"name":"isArguments","manifest":{"fnSignature":"_.isArguments(value)","lodashLink":"https://lodash.com/docs/4.17.15#isArguments","summaryHtml":"<p>Checks if <code>value</code> is likely an <code>arguments</code> object.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function isArguments(value) {\n  return Object.prototype.toString.call(value) === '[object Arguments]' &amp;&amp; !(Symbol.toStringTag in value);\n}\n</code></pre>\n<p>The above solution can technically give wrong answers if you provide an arguments object that has been mutated to contain <code>Symbol.toStringTag</code>.</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">function () {\n  arguments[Symbol.toStringTag] = 'badValue';\n  console.log(isArguments(arguments)); // =&gt; false\n}\n</code></pre>\n<p>Even Lodash's implementation can be spoofed, but under different conditions. If you run the following, you'll see that it will incorrectly claim that the provided object is an arguments object <code>true</code>.</p>\n<pre><code class=\"javascript language-javascript\">_.isArguments({ get [Symbol.toStringTag]() { return 'Arguments' } })\n// =&gt; true\n</code></pre>\n<p>If you're exclusively using Node, you're welcome to instead use <code>require('util').types.isArgumentsObject(value)</code> for your <code>isArguments</code> check.</p>","src":null,"test":""},{"name":"isArray","manifest":{"fnSignature":"_.isArray(value)","lodashLink":"https://lodash.com/docs/4.17.15#isArray","summaryHtml":"<p>Checks if <code>value</code> is classified as an <code>Array</code> object.</p>"},"descriptionHtml":"<p>Lodash's <code>_.isArray()</code> is simply an alias for <code>Array.isArray(value)</code>.</p>\n<p>Note that <code>Array.isArray()</code> will return <code>true</code> both for array subclasses and if you directly pass in <code>Array.prototype</code>. In many cases this sort of thing isn't something you need to worry about, but if you want to prevent subclasses and/or <code>Array.prototype</code> from getting through there's various solutions you can use depending on how robust you need the solution to be.</p>\n<ol>\n<li><p><code>Object.getPrototypeOf(value) === Array.prototype</code> is the simplest way to exclude <code>Array.prototype</code> and inherited instances, but has issues with cross-realm arrays (see footnote 1) and <code>Object.create(Array.prototype)</code> (see footnote 2).</p></li>\n<li><p><code>Array.isArray(value) &amp;&amp; Object.getPrototypeOf(value) === Array.prototype</code> is a little more robust and solved the <code>Object.create(Array.prototype)</code> issue (footnote 2), but still has issues with cross-realm arrays (footnote 1).</p></li>\n<li><p>The helper function below would be the strongest solution, and doesn't have any of the issues that the simpler solutions have.</p>\n<pre><code class=\"javascript language-javascript\">// Cross realm compatible is-non-inherited-array check.\nfunction isNonInheritedArray(value) {\n  const protoOf = Object.getPrototypeOf;\n  // An array's prototype chain should normally be\n  // value -&gt; Array.prototype -&gt; Object.prototype -&gt; null\n  // If there's an extra link in there, it means inheritance has happened.\n  return (\n    Array.isArray(value) &amp;&amp;\n    protoOf(protoOf(value)) !== null &amp;&amp; // This check fails if you pass in Array.prototype.\n    protoOf(protoOf(protoOf(value))) === null\n  );\n}\n</code></pre></li>\n<li><p>If you just want to exclude <code>Array.prototype</code> and still allow subclasses, then you can use solution 3, but omit the last <code>protoOf(protoOf(protoOf(value))) === null</code> check.</p></li>\n</ol>\n<p>Footnotes:</p>\n<ol>\n<li>A \"cross-realm array\" is, for example, an array from an iframe. Since the Array class from within the iframe is separate from the Array class outside of the iframe, you can't simply do an equality check on their prototypes.</li>\n<li>The problem with <code>Object.create(Array.prototype)</code> is that this does not create a real array, it's just an object who's prototype happens to be <code>Array.prototype</code>.</li>\n</ol>","src":null,"test":""},{"name":"isArrayBuffer","manifest":{"fnSignature":"_.isArrayBuffer(value)","lodashLink":"https://lodash.com/docs/4.17.15#isArrayBuffer","summaryHtml":"<p>Checks if <code>value</code> is classified as an <code>ArrayBuffer</code> object.</p>"},"descriptionHtml":"<p>To check if your value is an instance of <code>ArrayBuffer</code>:</p>\n<pre><code class=\"javascript language-javascript\">value instanceof ArrayBuffer\n</code></pre>\n<p>The above should be good enough for the vast majority of use-cases.</p>\n<p>It's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:</p>\n<pre><code class=\"javascript language-javascript\">Object.getPrototypeOf(value) === ArrayBuffer.prototype\n</code></pre>\n<p>Both of the above type-detection mechanisms have a couple of flaws:</p>\n<ol>\n<li>they don't work with cross-realm values. For example, if you receive an instance of an <code>ArrayBuffer</code> from across an iframe boundary, that instance's prototype would link to the iframe's <code>ArrayBuffer</code> class, not your <code>ArrayBuffer</code> class, and both of the above checks would fail to recognize it as an ArrayBuffer.</li>\n<li>They will state that <code>Object.create(ArrayBuffer.prototype)</code> is an <code>ArrayBuffer</code>, but it's not. It's just a regular object who's prototype has been set to <code>ArrayBuffer.prototype</code>.</li>\n</ol>\n<p>Both of these issues can be solved with a helper function like this:</p>\n<pre><code class=\"javascript language-javascript\">// An isArrayBuffer() check that supports cross-realm ArrayBuffers.\nfunction isArrayBuffer(value) {\n  try {\n    // If you call an ArrayBuffer method, like .slice(),\n    // with a \"this\" value that's anything\n    // other than an ArrayBuffer, a TypeError is thrown.\n    ArrayBuffer.prototype.slice.call(value, 0, 0);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n</code></pre>\n<p>If you additionally need to ensure that you are not receiving an ArrayBuffer instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace <code>return true;</code> with the following:</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">// A ArrayBuffer's prototype's chain should be\n// value -&gt; ArrayBuffer.prototype -&gt; Object.prototype -&gt; null\n// If it's not, then we're dealing with an ArrayBuffer subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n</code></pre>\n<p>Lodash's <code>_.isArrayBuffer()</code> also supports cross-realm ArrayBuffer checks, but it uses a less robust algorithm that can be easily fooled. For example, if you run Lodash in the browser, the following will return the wrong answer.</p>\n<pre><code class=\"javascript language-javascript\">_.isArrayBuffer({ get [Symbol.toStringTag]() { return 'ArrayBuffer' } })\n// =&gt; true\n</code></pre>\n<p>In Node, Lodash will instead use <code>require('util').types.isArrayBuffer(value)</code> for it's implementation, which you are also welcome to use if you know your code will only run in Node.</p>\n<p>Future JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:</p>\n<ul>\n<li><a href=\"https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1\">Pattern matching's built-in matchers</a></li>\n</ul>","src":null,"test":""},{"name":"isArrayLike","manifest":{"fnSignature":"_.isArrayLike(value)","lodashLink":"https://lodash.com/docs/4.17.15#isArrayLike","summaryHtml":"<p>Checks if <code>value</code> is array-like. A value is considered array-like if it's not a function and has a value.length that's an integer greater than or equal to <code>0</code> and less than or equal to <code>Number.MAX_SAFE_INTEGER</code>.</p>"},"descriptionHtml":"<p>An equivalent to Lodash's \"is-array-like\" algorithm is as follows:</p>\n<pre><code class=\"javascript language-javascript\">function isArrayLike(value) {\n  return (\n    typeof value !== 'function' &amp;&amp;\n    Number.isInteger(value?.length) &amp;&amp;\n    value.length &gt;= 0\n  );\n}\n</code></pre>\n<p>The JavaScript specification uses a much looser definition for \"array-like\" - basically, as long as you can get a \"length\" property from the value and coerce it into an integer somehow, then it's an array-like value. This means that even <code>{}</code> is \"array-like\", because it's able to get the (non-existent) length property (<code>undefined</code>), then coerce that into an integer (<code>0</code>). This definition technically makes almost any value except undefined, null, and a couple of other minor edge cases \"array-like\". A good way to check if something is considered array-like or not per the spec, is to run the following snippet and see if it throws an error, if it does not, your value is an array-like value.</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">Array.prototype.slice.call(&lt;your value&gt;);\n</code></pre>\n<p>In day-to-day conversation the term \"array-like\" goes beyond the technical definition of array-like as outlined by the spec. An array-like value is additionally a value that was intentionally designed to have array-like characteristics, which is why Lodash's implementation still makes sense - Lodash's does a good job at rejecting values that were never intended to be used like an array. The point is that Lodash's implementation isn't the only correct way to implement this check - depending on your use-case you might find that a different <code>isArrayLike()</code> implementation would be more appropriate.</p>\n<p>An even better lesson from all of this is that if you're tempted to design a function that behaves differently depending on if an input value is array-like or not, it might be worthwhile to reconsider the API design so you don't have to make your public API depend on either a non-standard or overly loose definition of \"array-like\".</p>","src":null,"test":"function isArrayLike(value) {\n  return (\n    typeof value !== 'function' &&\n    Number.isInteger(value?.length) &&\n    value.length >= 0\n  );\n}\n\ndescribe('isArrayLike()', () => {\n  it('considers an array to be array-like', () => {\n    expect(isArrayLike([2, 3])).toBe(true);\n  });\n\n  it('considers a string to be array-like', () => {\n    expect(isArrayLike('23')).toBe(true);\n  });\n\n  it('considers an arguments object to be array-like', () => {\n    (function () {\n      expect(isArrayLike(arguments)).toBe(true);\n    })();\n  });\n\n  it('does not consider a function to be array-like', () => {\n    expect(isArrayLike(function () {})).toBe(false);\n  });\n\n  it('considers a value missing a length property to not be array-like', () => {\n    expect(isArrayLike({})).toBe(false);\n  });\n\n  it('considers a value with a positive integer length to be array-like', () => {\n    expect(isArrayLike({ length: 2 })).toBe(true);\n  });\n\n  it('considers a value with the length 0 to be array-like', () => {\n    expect(isArrayLike({ length: 0 })).toBe(true);\n  });\n\n  it('considers a value with a string length to not be array-like', () => {\n    expect(isArrayLike({ length: '2' })).toBe(false);\n  });\n\n  it('considers a value with a length of Infinity to not be array-like', () => {\n    expect(isArrayLike({ length: Infinity })).toBe(false);\n  });\n\n  it('considers a value with a length of NaN to not be array-like', () => {\n    expect(isArrayLike({ length: NaN })).toBe(false);\n  });\n\n  it('considers a value with a float length to not be array-like', () => {\n    expect(isArrayLike({ length: 2.3 })).toBe(false);\n  });\n\n  it('considers a value with a really large length to not be array-like (as those are represented as floats)', () => {\n    // eslint-disable-next-line no-loss-of-precision\n    expect(isArrayLike({ length: 2e999 })).toBe(false);\n  });\n});\n"},{"name":"isArrayLikeObject","manifest":{"fnSignature":"_.isArrayLikeObject(value)","lodashLink":"https://lodash.com/docs/4.17.15#isArrayLikeObject","summaryHtml":"<p>This method is like <code>_.isArrayLike</code> except that it also checks if <code>value</code> is an object.</p>"},"descriptionHtml":"<p>An equivalent to Lodash's \"is-array-like-object\" algorithm is as follows:</p>\n<pre><code class=\"javascript language-javascript\">function isArrayLikeObject(value) {\n  return isArrayLike(value) &amp;&amp; isObject(value);\n}\n\n// -- helpers --\n\nfunction isArrayLike(value) {\n  return (\n    typeof value !== 'function' &amp;&amp;\n    Number.isInteger(value?.length) &amp;&amp;\n    value.length &gt;= 0\n  );\n}\n\nfunction isObject(value) {\n  return value === Object(value);\n}\n</code></pre>\n<p>(Note that the only difference between <code>_.isArrayLikeObject()</code> and <code>_.isArrayLike()</code> is that <code>_.isArrayLikeObject()</code> does not return <code>true</code> for string primitives).</p>\n<p>The JavaScript specification uses a much looser definition for \"array-like object\" - basically, as long as the value is an object and you can get a \"length\" property from the value and coerce it into an integer somehow, then it's an array-like value. This means that even <code>{}</code> is \"array-like\", because it's able to get the (non-existent) length property (<code>undefined</code>), then coerce that into an integer (<code>0</code>). This definition technically makes almost any non-primitive value \"array-like\" (an exception could be, for example, an object with a \"length\" getter that throws an error).</p>\n<p>In day-to-day conversation the term \"array-like object\" goes beyond the technical definition of array-like object as outlined by the spec. An array-like object is additionally an object that was intentionally designed to have array-like characteristics, which is why Lodash's implementation still makes sense - Lodash's does a good job at rejecting values that were never intended to be used like an array. The point is that Lodash's implementation isn't the only correct way to implement this check - depending on your use-case you might find that a different <code>isArrayLikeObject()</code> implementation would be more appropriate.</p>\n<p>An even better lesson from all of this is that if you're tempted to design a function that behaves differently depending on if an input value is an array-like object or not, it might be worthwhile to reconsider the API design so you don't have to make your public API depend on either a non-standard or overly loose definition of \"array-like object\".</p>","src":null,"test":"function isArrayLikeObject(value) {\n  return isArrayLike(value) && isObject(value);\n}\n\nfunction isArrayLike(value) {\n  return (\n    typeof value !== 'function' &&\n    Number.isInteger(value?.length) &&\n    value.length >= 0\n  );\n}\n\nfunction isObject(value) {\n  return value === Object(value);\n}\n\ndescribe('isArrayLikeObject()', () => {\n  it('considers an array to be an array-like object', () => {\n    expect(isArrayLikeObject([2, 3])).toBe(true);\n  });\n\n  it('does not considers a string to be an array-like object', () => {\n    expect(isArrayLikeObject('23')).toBe(false);\n  });\n\n  it('considers an arguments object to be an array-like object', () => {\n    (function () {\n      expect(isArrayLikeObject(arguments)).toBe(true);\n    })();\n  });\n\n  it('does not consider a function to be an array-like object', () => {\n    expect(isArrayLikeObject(function () {})).toBe(false);\n  });\n\n  it('considers a value missing a length property to not be an array-like object', () => {\n    expect(isArrayLikeObject({})).toBe(false);\n  });\n\n  it('considers a value with a positive integer length to be an array-like object', () => {\n    expect(isArrayLikeObject({ length: 2 })).toBe(true);\n  });\n\n  it('considers a value with the length 0 to be an array-like object', () => {\n    expect(isArrayLikeObject({ length: 0 })).toBe(true);\n  });\n\n  it('considers a value with a string length to not be an array-like object', () => {\n    expect(isArrayLikeObject({ length: '2' })).toBe(false);\n  });\n\n  it('considers a value with a length of Infinity to not be an array-like object', () => {\n    expect(isArrayLikeObject({ length: Infinity })).toBe(false);\n  });\n\n  it('considers a value with a length of NaN to not be an array-like object', () => {\n    expect(isArrayLikeObject({ length: NaN })).toBe(false);\n  });\n\n  it('considers a value with a float length to not be an array-like object', () => {\n    expect(isArrayLikeObject({ length: 2.3 })).toBe(false);\n  });\n\n  it('considers a value with a really large length to not be an array-like object (as those are represented as floats)', () => {\n    // eslint-disable-next-line no-loss-of-precision\n    expect(isArrayLikeObject({ length: 2e999 })).toBe(false);\n  });\n});\n"},{"name":"isBoolean","manifest":{"fnSignature":"_.isBoolean(value)","lodashLink":"https://lodash.com/docs/4.17.15#isBoolean","summaryHtml":"<p>Checks if <code>value</code> is classified as a boolean primitive or object.</p>"},"descriptionHtml":"<p>To check if a value is a boolean primitive:</p>\n<pre><code class=\"javascript language-javascript\">typeof value === 'boolean'\n</code></pre>\n<p>The above should be good enough for the vast majority of use-cases.</p>\n<p>Lodash will also check if the value is a boolean object. In practice, such objects should never be found in your codebase, and if someone ever tries to hand such an object to you you really ought to treat it the same way you would treat any other bad input (throw an error, or if you aren't explicitly trying to check for bad inputs just let your library fall over, the same way it would with any other bad input).</p>\n<p>To check if something is specifically a boolean object (and not a primitive), use the following:</p>\n<pre><code class=\"javascript language-javascript\">value instanceof Boolean\n</code></pre>\n<p>This, however, doesn't work cross realm (i.e. a boolean object created from inside an iframe would fail this check). It also would incorrectly state that <code>Object.create(Boolean.prototype)</code> is a boolean object, when in reality, it's just a normal object who's prototype is set to <code>Boolean.prototype</code>. If you need to worry about these kinds of issues, use the following solution instead:</p>\n<pre><code class=\"javascript language-javascript\">// An isBoolean() check that supports cross-realm Boolean instances.\n// This will check if `value` is a boolean primitive or object.\n// Returns `true` for values that inherit from `Boolean` as well.\nfunction isBoolean(value) {\n  try {\n    // If you call this method with a \"this\" value that's anything\n    // other than a boolean primitive or object, a TypeError is thrown.\n    Boolean.prototype.toString.call(value);\n    // Makes sure Boolean.prototype was not passed in.\n    const protoOf = Object.getPrototypeOf;\n    return protoOf(protoOf(value)) !== null;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n</code></pre>\n<p>Lodash's <code>_.isBoolean()</code> also supports cross-realm <code>Boolean</code> object checks, but it uses a less robust algorithm that can be easily fooled. For example, the following will return the wrong answer.</p>\n<pre><code class=\"javascript language-javascript\">_.isBoolean({ get [Symbol.toStringTag]() { return 'Boolean' } })\n// =&gt; true\n</code></pre>\n<p>If you're exclusively using Node, you can use <code>require('util').types.isBooleanObject(value)</code> to specifically check if the value is a boolean object (not a primitive). This solution will also return <code>true</code> for both subclasses and <code>Boolean.prototype</code>.</p>","src":null,"test":""},{"name":"isBuffer","manifest":{"fnSignature":"_.isBuffer(value)","lodashLink":"https://lodash.com/docs/4.17.15#isBuffer","summaryHtml":"<p>Checks if <code>value</code> is a buffer.</p>"},"descriptionHtml":"<p>The <code>Buffer</code> class is part of Node, and isn't found in the core JavaScript language. You can check if something is an instance of Buffer using Node's <code>isBuffer()</code> method as follows:</p>\n<pre><code class=\"javascript language-javascript\">Buffer.isBuffer(value)\n</code></pre>\n<p>This will return <code>true</code> for <code>Buffer</code> subclasses. If you want to ensure your buffer instance is not a subclass, you can do the following:</p>\n<pre><code class=\"javascript language-javascript\">function isNonInheritedBuffer(value) {\n  // A Buffer's prototype's chain should be\n  // value -&gt; Buffer.prototype -&gt; Uint8Array.prototype -&gt; TypedArray.prototype -&gt; Object.prototype -&gt; null\n  // If it's not, then we're dealing with a Buffer subclass.\n  const protoOf = Object.getPrototypeOf;\n  return (\n    Buffer.isBuffer(value) &amp;&amp;\n    protoOf(protoOf(protoOf(protoOf(protoOf(value))))) === null\n  );\n}\n</code></pre>\n<p>Both of these solutions will work with cross-realm <code>Buffer</code> instances.</p>","src":null,"test":""},{"name":"isDate","manifest":{"fnSignature":"_.isDate(value)","lodashLink":"https://lodash.com/docs/4.17.15#isDate","summaryHtml":"<p>Checks if <code>value</code> is classified as a <code>Date</code> object.</p>"},"descriptionHtml":"<p>To check if your value is an instance of <code>Date</code>:</p>\n<pre><code class=\"javascript language-javascript\">value instanceof Date\n</code></pre>\n<p>The above should be good enough for the vast majority of use-cases.</p>\n<p>It's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:</p>\n<pre><code class=\"javascript language-javascript\">Object.getPrototypeOf(value) === Date.prototype\n</code></pre>\n<p>Both of the above type-detection mechanisms have a couple of flaws:</p>\n<ol>\n<li>they don't work with cross-realm values. For example, if you receive an instance of a <code>Date</code> from across an iframe boundary, that instance's prototype would link to the iframe's <code>Date</code> class, not your <code>Date</code> class, and both of the above checks would fail to recognize it as a <code>Date</code>.</li>\n<li>They will state that <code>Object.create(Date.prototype)</code> is a <code>Date</code>, but it's not. It's just a regular object who's prototype has been set to <code>Date.prototype</code>.</li>\n</ol>\n<p>Both of these issues can be solved with a helper function like this:</p>\n<pre><code class=\"javascript language-javascript\">// An isDate() check that supports cross-realm Dates.\nfunction isDate(value) {\n  try {\n    // If you call a Date method, like .valueOf(),\n    // with a \"this\" value that's anything\n    // other than a Date, a TypeError is thrown.\n    Date.prototype.valueOf.call(value);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n</code></pre>\n<p>If you additionally need to ensure your are not receiving a <code>Date</code> instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace <code>return true;</code> with the following:</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">// A Date's prototype's chain should be\n// value -&gt; Date.prototype -&gt; Object.prototype -&gt; null\n// If it's not, then we're dealing with a Map subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n</code></pre>\n<p>Lodash's <code>_.isDate()</code> also supports cross-realm <code>Date</code> checks, but it uses a less robust algorithm that can be easily fooled. For example, if you run Lodash in the browser, the following will return the wrong answer.</p>\n<pre><code class=\"javascript language-javascript\">_.isDate({ get [Symbol.toStringTag]() { return 'Date' } })\n// =&gt; true\n</code></pre>\n<p>In Node, Lodash will instead use <code>require('util').types.isDate(value)</code> for it's implementation, which you are also welcome to use if you know your code will only run in Node. This solution will also return <code>true</code> for subclasses.</p>\n<p>Future JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:</p>\n<ul>\n<li><a href=\"https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1\">Pattern matching's built-in matchers</a></li>\n</ul>","src":null,"test":""},{"name":"isElement","manifest":{"fnSignature":"_.isElement(value)","lodashLink":"https://lodash.com/docs/4.17.15#isElement","summaryHtml":"<p>Checks if value is likely a <code>DOM</code> element.</p>"},"descriptionHtml":"<p>To check if your value is an HTML Element:</p>\n<pre><code class=\"javascript language-javascript\">value instanceof Element\n</code></pre>\n<p>For the vast majority of scenarios the above should be good enough, but it does technically have a couple of flaws:</p>\n<ol>\n<li>it doesn't work with cross-realm values. For example, if you receive an instance of an <code>Element</code> from across an iframe boundary, that instance's prototype would link to the iframe's <code>Element</code> class, not your <code>Element</code> class, and the above check would fail to recognize it as an <code>Element</code>.</li>\n<li>They will state that <code>Object.create(Element.prototype)</code> is an element, but it's not. It's just a regular object who's prototype has been set to <code>Element.prototype</code>.</li>\n</ol>\n<p>Both of these issues can be solved with a helper function like this:</p>\n<pre><code class=\"javascript language-javascript\">// An isElement() check that supports cross-realm Elements.\nfunction isElement(value) {\n  try {\n    // If you call a Element method, like .getAttribute(),\n    // with a \"this\" value that's anything\n    // other than an Element, a TypeError is thrown.\n    Element.prototype.getAttribute.call(value, '');\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n</code></pre>\n<p>Lodash's <code>_.isElement()</code> also supports cross-realm <code>Element</code> checks, but it uses a far less robust algorithm that can be easily fooled. To spoof it, you just need to provide a <a href=\"https://lodash.com/docs/4.17.15#isPlainObject\">non-plain object</a> which has a <code>nodeType</code> property set to <code>1</code>.</p>\n<pre><code class=\"javascript language-javascript\">class NotAnElement {\n  nodeType = 1;\n}\n\n_.isElement(new NotAnElement()) // =&gt; true\n</code></pre>","src":null,"test":""},{"name":"isEmpty","manifest":{"fnSignature":"_.isEmpty(value)","lodashLink":"https://lodash.com/docs/4.17.15#isEmpty","summaryHtml":"<p>Checks if <code>value</code> is an empty object, collection, map, or set.</p>"},"descriptionHtml":"<p>To check if something is empty, you can simply use the API provided by the specific object type you have.</p>\n<p>For array and strings, use the <code>.length</code> property.</p>\n<pre><code class=\"javascript language-javascript\">myArray.length === 0\nmyString.length === 0\n</code></pre>\n<p>For maps and sets, use the <code>.size</code> property.</p>\n<pre><code class=\"javascript language-javascript\">new Map().size === 0\nnew Set().size === 0\n</code></pre>\n<p>You can check if an object has zero non-inherited string keys by checking the length of <code>Object.keys()</code>.</p>\n<pre><code class=\"javascript language-javascript\">Object.keys({}).length === 0\n</code></pre>\n<p>Lodash treats <code>undefined</code> and <code>null</code> as empty, while treating all other non-string primitives as non-empty. This distinction is technically nonsense. Only containers can be empty. If your piece of data can't hold anything, then it <em>can't</em> be empty or non-empty, instead it's simply an invalid input. It's true that a <code>null</code> or <code>undefined</code> can be used to represent the absence of a value, but these pieces of data aren't in-and-of-themselves <em>empty</em>. In any case, if you want to check if something is <code>undefined</code> or <code>null</code>, you can just use <code>value === undefined</code> or <code>value === null</code>.</p>\n<p>If you want to check if an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#array-like_objects\">array-like value</a> (e.g. the argument object, typed arrays, etc) is empty, check the <code>.length</code> property, the same way you would with a normal array.</p>\n<pre><code class=\"javascript language-javascript\">myArrayLikeValue.length === 0\n</code></pre>\n<p>Despite what Lodash's documentation seems to imply, <code>_.isEmpty()</code> does not work with <em>any</em> array-like value. Take, for example, <code>{ length: 0 }</code>, which is an array-like object (it passes Lodash's <code>_.isArrayLike()</code> check), however, when passed into <code>_.isEmpty()</code>, Lodash will incorrectly state that this array-like value is not empty. The reason for this odd behavior is simply because this function has been overloaded with too many behaviors - while it's true that <code>{ length: 0 }</code> is an empty array-like object, it's also true that this is not an empty object, and Lodash has decided to let the \"is this an empty object\" behavior take precedence over the \"is this an empty array-like value\" behavior for this specific scenario. If you want to know the details of how it decides which behavior to follow, feel free to <a href=\"https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L11479\">read its source code</a>.</p>","src":null,"test":""},{"name":"isEqual","manifest":{"fnSignature":"_.isEqual(value, other)","lodashLink":"https://lodash.com/docs/4.17.15#isEqual","summaryHtml":"<p>Performs a deep comparison between two values to determine if they are equivalent.</p>"},"descriptionHtml":"<p>To deeply compare values you'll have to build up your own deep comparison algorithm by hand according to your use-case. General-purpose deep-comparison algorithms like Lodash's <code>_.isEqual()</code> can be nice to have for simple use-cases, but it's important to understand that all such algorithms have limitations and you may be forced to revert to building your own deep-comparison algorithm if you are using a data type that the algorithm does not explicitly support (e.g. no general-purpose algorithm can deeply compare private data defined in your classes), or if you need very specific behavior (e.g. should <code>+0</code> equal <code>-0</code> or not? Will you only compare an object's string keys, or will you include symbol keys too? etc).</p>\n<p>Here's a simple version to get you started - it shows examples of how you would compare a handful of different types of data. It's up to you to add, remove, or tweak functionality as needed. Note that this version does not support circular references - if you need to support that, you'll additionally need to keep around a set containing each value you've visited to make sure you're not going in a loop.</p>\n<pre><code class=\"javascript language-javascript\">const isPrimitive = value =&gt; value !== Object(value);\n\nconst isPlainObject = value =&gt; (\n  value != null &amp;&amp;\n  [null, Object.prototype].includes(Object.getPrototypeOf(value))\n);\n\nfunction isEqual(value1, value2) {\n  // Each type corresponds to a particular comparison algorithm\n  const getType = value =&gt; {\n    if (isPrimitive(value)) return 'primitive';\n    if (Array.isArray(value)) return 'array';\n    if (value instanceof Map) return 'map';\n    if (isPlainObject(value)) return 'plainObject';\n    throw new Error(`deeply comparing an instance of type ${value.constructor?.name} is not supported.`);\n  };\n\n  const type = getType(value1);\n  if (type !== getType(value2)) {\n    return false;\n  }\n\n  if (type === 'primitive') {\n    return (\n      value1 === value2 ||\n      (Number.isNaN(value1) &amp;&amp; Number.isNaN(value2))\n    );\n  } else if (type === 'array') {\n    return (\n      value1.length === value2.length &amp;&amp;\n      value1.every((iterValue, i) =&gt; isEqual(iterValue, value2[i]))\n    );\n  } else if (type === 'map') {\n    // In this particular implementation, map keys are not\n    // being deeply compared, only map values.\n    return (\n      value1.size === value2.size &amp;&amp;\n      [...value1].every(([iterKey, iterValue]) =&gt; {\n        return value2.has(iterKey) &amp;&amp; isEqual(iterValue, value2.get(iterKey));\n      })\n    );\n  } else if (type === 'plainObject') {\n    const value1AsMap = new Map(Object.entries(value1));\n    const value2AsMap = new Map(Object.entries(value2));\n    return (\n      value1AsMap.size === value2AsMap.size &amp;&amp;\n      [...value1AsMap].every(([iterKey, iterValue]) =&gt; {\n        return value2AsMap.has(iterKey) &amp;&amp; isEqual(iterValue, value2AsMap.get(iterKey));\n      })\n    );\n  } else {\n    throw new Error('Unreachable');\n  }\n}\n</code></pre>\n<p>If you're dealing with JSON-serializable data (i.e. data that does not contain values like <code>Date</code> instances or <code>undefined</code>), and you're not working in performance-sensitive code, you could also use the simpler solution of <code>JSON.stringify()</code>ing the two values and comparing the strings. You'll need to supply a <code>replacer</code> function to sort object keys before converting the object to JSON.</p>\n<pre><code class=\"javascript language-javascript\">function sortObjKeysReplacer(key, maybeObj) {\n  if (typeof maybeObj !== 'object' || maybeObj === null) return maybeObj;\n\n  return Object.fromEntries(\n    Object.entries(maybeObj)\n      .sort((a, b) =&gt; a[0] &gt; b[0] ? 1 : -1),\n  );\n}\n\nfunction isEqual(value1, value2) {\n  const jsonValue1 = JSON.stringify(value1, sortObjKeysReplacer);\n  const jsonValue2 = JSON.stringify(value2, sortObjKeysReplacer);\n  return jsonValue1 === jsonValue2;\n}\n</code></pre>","src":null,"test":"const isPrimitive = value => value !== Object(value);\n\nconst isPlainObject = value => (\n  value != null &&\n  [null, Object.prototype].includes(Object.getPrototypeOf(value))\n);\n\nfunction isEqual(value1, value2) {\n  // Each type corresponds to a particular comparison algorithm\n  const getType = value => {\n    if (isPrimitive(value)) return 'primitive';\n    if (Array.isArray(value)) return 'array';\n    if (value instanceof Map) return 'map';\n    if (isPlainObject(value)) return 'plainObject';\n    throw new Error(`deeply comparing an instance of type ${value.constructor?.name} is not supported.`);\n  };\n\n  const type = getType(value1);\n  if (type !== getType(value2)) {\n    return false;\n  }\n\n  if (type === 'primitive') {\n    return (\n      value1 === value2 ||\n      (Number.isNaN(value1) && Number.isNaN(value2))\n    );\n  } else if (type === 'array') {\n    return (\n      value1.length === value2.length &&\n      value1.every((iterValue, i) => isEqual(iterValue, value2[i]))\n    );\n  } else if (type === 'map') {\n    // In this particular implementation, map keys are not\n    // being deeply compared, only map values.\n    return (\n      value1.size === value2.size &&\n      [...value1].every(([iterKey, iterValue]) => {\n        return value2.has(iterKey) && isEqual(iterValue, value2.get(iterKey));\n      })\n    );\n  } else if (type === 'plainObject') {\n    const value1AsMap = new Map(Object.entries(value1));\n    const value2AsMap = new Map(Object.entries(value2));\n    return (\n      value1AsMap.size === value2AsMap.size &&\n      [...value1AsMap].every(([iterKey, iterValue]) => {\n        return value2AsMap.has(iterKey) && isEqual(iterValue, value2AsMap.get(iterKey));\n      })\n    );\n  } else {\n    throw new Error('Unreachable');\n  }\n}\n\ntest('comparing values of different types', () => {\n  expect(!isEqual({}, null)).toBe(true); // Even though `typeof {}` is `null`, these should clearly not be equal\n  expect(!isEqual({}, undefined)).toBe(true);\n  expect(!isEqual(null, undefined)).toBe(true);\n  expect(!isEqual({}, 2)).toBe(true);\n  expect(!isEqual(2, 2n)).toBe(true);\n  expect(!isEqual(new Map(), {})).toBe(true);\n});\n\ntest('comparing primitives', () => {\n  expect(isEqual(2, 2)).toBe(true);\n  expect(!isEqual(2, 3)).toBe(true);\n\n  expect(isEqual('x', 'x')).toBe(true);\n  expect(!isEqual('x', 'xx')).toBe(true);\n\n  const s = Symbol('mySymb');\n  expect(isEqual(s, s)).toBe(true);\n  expect(!isEqual(s, Symbol('mySymb'))).toBe(true);\n\n  expect(isEqual(true, true)).toBe(true);\n  expect(!isEqual(true, false)).toBe(true);\n\n  expect(isEqual(undefined, undefined)).toBe(true);\n  expect(isEqual(null, null)).toBe(true);\n});\n\ntest('comparing objects', () => {\n  expect(isEqual({ x: { y: 2 } }, { x: { y: 2 } })).toBe(true);\n  expect(isEqual({ x: 2, y: 3 }, { y: 3, x: 2 })).toBe(true);\n  expect(!isEqual({ x: { y: 2 } }, { x: { y: 3 } })).toBe(true);\n  expect(!isEqual({ x: { y: 2 } }, { x: { y: 2, z: 2 } })).toBe(true);\n});\n\ntest('comparing arrays', () => {\n  expect(isEqual([1, 2], [1, 2])).toBe(true);\n  expect(isEqual([[1, 2]], [[1, 2]])).toBe(true);\n\n  expect(!isEqual([[1, 2]], [[1, 3]])).toBe(true);\n  expect(!isEqual([1, 2], [1, 3])).toBe(true);\n  expect(!isEqual([1, 2], [1, 2, 3])).toBe(true);\n});\n\ntest('comparing maps', () => {\n  expect(\n    isEqual(\n      new Map([\n        [1, 'A'],\n        [2, 'B'],\n      ]),\n      new Map([\n        [2, 'B'],\n        [1, 'A'],\n      ]),\n    ),\n  ).toBe(true);\n  expect(isEqual(new Map([[1, { x: 2 }]]), new Map([[1, { x: 2 }]]))).toBe(true);\n\n  expect(!isEqual(new Map([[1, { x: 2 }]]), new Map([[1, { x: 1 }]]))).toBe(true);\n  expect(\n    !isEqual(\n      new Map([\n        [1, 'A'],\n        [2, 'B'],\n      ]),\n      new Map([\n        [1, 'A'],\n        [2, 'C'],\n      ]),\n    ),\n  ).toBe(true);\n  expect(\n    !isEqual(\n      new Map([\n        [1, 'A'],\n        [2, 'B'],\n      ]),\n      new Map([\n        [1, 'A'],\n        [3, 'B'],\n      ]),\n    ),\n  ).toBe(true);\n  expect(\n    !isEqual(\n      new Map([\n        [1, 'A'],\n        [2, 'B'],\n      ]),\n      new Map([\n        [1, 'A'],\n        [2, 'B'],\n        [3, 'C'],\n      ]),\n    ),\n  ).toBe(true);\n});\n"},{"name":"isEqualWith","manifest":{"fnSignature":"_.isEqualWith(value, other, [customizer])","lodashLink":"https://lodash.com/docs/4.17.15#isEqualWith","summaryHtml":"<p>This method is like <code>_.isEqual</code> except that it accepts <code>customizer</code> which is invoked to compare values. If <code>customizer</code> returns <code>undefined</code>, comparisons are handled by the method instead.</p>"},"descriptionHtml":"<p>Like with <code>_.isEqual()</code>, deep comparison algorithms need to be hand-built according to your use-cases. Lodash's <code>_.isEqualWith()</code> can be convenient to help with some use cases, but it won't cover everything (e.g. it can't peer into private data).</p>\n<p>Here's a simple version to get you started - it shows examples of how you would compare a handful of different types of data. It's up to you to add, remove, or tweak functionality as needed. Note that this version does not support circular references - if you need to support that, you'll additionally need to keep around a set containing each value you've visited to make sure you're not going in a loop.</p>\n<pre><code class=\"javascript language-javascript\">const isPrimitive = value =&gt; value !== Object(value);\n\nconst isPlainObject = value =&gt; (\n  value != null &amp;&amp;\n  [null, Object.prototype].includes(Object.getPrototypeOf(value))\n);\n\nfunction isEqualWith(value1, value2, customizer, _parentNodeInfo = undefined) {\n  // Each type corresponds to a particular comparison algorithm\n  const getType = value =&gt; {\n    if (isPrimitive(value)) return 'primitive';\n    if (Array.isArray(value)) return 'array';\n    if (isPlainObject(value)) return 'plainObject';\n    throw new Error(`deeply comparing an instance of type ${value1.constructor?.name} is not supported.`);\n  };\n\n  // Checks with the customizer() function to see if it\n  // wants to override the default comparison behavior\n  {\n    let customizerResult;\n    if (_parentNodeInfo === undefined) {\n      customizerResult = customizer(value1, value2);\n    } else {\n      const { key, value1Parent, value2Parent } = _parentNodeInfo;\n      customizerResult = customizer(value1, value2, key, value1Parent, value2Parent);\n    }\n\n    if (customizerResult !== undefined) {\n      return customizerResult;\n    }\n  }\n\n  const type = getType(value1);\n  if (type !== getType(value2)) {\n    return false;\n  }\n\n  if (type === 'primitive') {\n    return (\n      value1 === value2 ||\n      (Number.isNaN(value1) &amp;&amp; Number.isNaN(value2))\n    );\n  } else if (type === 'array') {\n    return (\n      value1.length === value2.length &amp;&amp;\n      value1.every(\n        (iterValue, i) =&gt; isEqualWith(\n          iterValue,\n          value2[i],\n          customizer,\n          { value1Parent: value1, value2Parent: value2, key: i },\n        ),\n      )\n    );\n  } else if (type === 'plainObject') {\n    const value1AsMap = new Map(Object.entries(value1));\n    const value2AsMap = new Map(Object.entries(value2));\n    return (\n      value1AsMap.size === value2AsMap.size &amp;&amp;\n      [...value1AsMap].every(([iterKey, iterValue]) =&gt; {\n        return (\n          value2AsMap.has(iterKey) &amp;&amp;\n          isEqualWith(\n            iterValue,\n            value2AsMap.get(iterKey),\n            customizer,\n            { value1Parent: value1, value2Parent: value2, key: iterKey },\n          )\n        );\n      })\n    );\n  } else {\n    throw new Error('Unreachable');\n  }\n}\n</code></pre>\n<p>In Lodash, the <code>customizer</code> function would be called with a sixth \"stack\" argument. Some probing shows that it's an instance of an internal \"Stack\" class that provides some methods which, presumably, can be used to gather information about the objects you're comparing. Due to the fact that this seems to be a rather complex feature that's entirely undocumented, it'll be assumed that the vast majority of users do not use this parameter, and so it's functionality won't be recreated here either.</p>\n<p>Special data types, like Maps and Sets, are not supported in the above example. This is partly because Lodash chooses to support them in a slightly odd way that you may not wish to mirror. For example:</p>\n<ul>\n<li>The fourth or fifth argument to your <code>customizer</code> function is supposed to be the parent node, but if that parent node was a <code>Map</code> or <code>Set</code> instance, you'll instead receive arrays containing the node's contents (e.g. a map of usernames to ids would be turned into <code>[['Sally', 1], ['Zack', 2]]</code> before being provided to you).</li>\n<li>When comparing two sets, like <code>new Set([1, 2, 3, 4])</code> and <code>new Set([5, 6, 7, 8])</code>, its going to call your <code>customizer</code> function <em>16</em> different times (assuming the <code>customizer</code> function returns <code>false</code> or <code>undefined</code> each time). As your sets grow in length, the amount of times it has to call your customizer grows exponentially. Maps have a similar issue. This behavior is required to implement the general-purpose algorithm Lodash was going for, but maybe for your use-case you don't need your algorithm to be so general-purpose - maybe you can cut some corners to help with performance.</li>\n</ul>","src":null,"test":""},{"name":"isError","manifest":{"fnSignature":"_.isError(value)","lodashLink":"https://lodash.com/docs/4.17.15#isError","summaryHtml":"<p>Checks if value is an <code>Error</code>, <code>EvalError</code>, <code>RangeError</code>, <code>ReferenceError</code>, <code>SyntaxError</code>, <code>TypeError</code>, or <code>URIError</code> object.</p>"},"descriptionHtml":"<p>Lodash's documentation makes it sound like they're checking if the value is specifically an instance of a set of built-in errors, but in reality, they're considering any <a href=\"https://lodash.com/docs/4.17.15#isPlainObject\">non-plain object</a> that has <code>message</code> and <code>name</code> properties that are strings to be errors. So, the following would return <code>true</code> despite not being an error.</p>\n<pre><code class=\"javascript language-javascript\">class NotAnError {\n  name = 'NotAnError';\n  message = 'this is not an error';\n}\n\n_.isError(new NotAnError()) // =&gt; true\n</code></pre>\n<p>If you actually want to check if a value is an error or one of its subclasses (like <code>TypeError</code>, or a user-defined subclass), you can simply do this:</p>\n<pre><code class=\"javascript language-javascript\">value instanceof Error\n</code></pre>\n<p>And if you want to check if a value is a specific error type (like <code>Error</code>, <code>TypeError</code>, or a user defined error), and you want to exclude subclasses, you can compare prototypes like this:</p>\n<pre><code class=\"javascript language-javascript\">// Replace `TypeError` with the Error class of your choice.\nObject.getPrototypeOf(value) === TypeError.prototype\n</code></pre>\n<p>For the vast majority of scenarios the above should be good enough, but those solutions do technically have a couple of flaws:</p>\n<ol>\n<li>they don't work with cross-realm values. For example, if you receive an instance of an <code>Error</code> from across an iframe boundary, that instance's prototype would link to the iframe's <code>Error</code> class, not your <code>Error</code> class, and both of the above checks would fail to recognize it as a <code>Error</code>.</li>\n<li>They will state that <code>Object.create(Error.prototype)</code> is an <code>Error</code>, but it's not. It's just a regular object who's prototype has been set to <code>Error.prototype</code>.</li>\n</ol>\n<p>Both of these issues can be solved with a helper function like this:</p>\n<pre><code class=\"javascript language-javascript\">// An isError() check that supports cross-realm Errors.\nfunction isError(value) {\n  // DOMException and its subclasses will set a `Symbol.toStringTag` property\n  // on their instances to the string 'DOMException'.\n  const errorAsString = Object.prototype.toString.call(value);\n  return ['[object Error]', '[object DOMException]'].includes(errorAsString);\n}\n</code></pre>\n<p>This helper function can unfortunately be spoofed by providing any object with a <code>Symbol.toStringTag</code> property set to one of the expected string tags, like this:</p>\n<pre><code class=\"javascript language-javascript\">isError({ [Symbol.toStringTag]: 'DOMException' })\n// =&gt; true\n</code></pre>\n<p>There's not really anything that can be done to avoid this. You could try layering on additional checks, but there will always be a way to cause your <code>isError()</code> function to return a wrong answer.</p>\n<p>If you're exclusively using Node, you can use <code>require('util').types.isNativeError(value)</code> to specifically check if the value is an instance of <code>Error</code> or one of its subclasses.</p>\n<p>Future JavaScript proposals may provide support for more robust ways to do cross-realm type checking:</p>\n<ul>\n<li><a href=\"https://github.com/tc39/proposal-is-error\">Error.isError</a></li>\n<li><a href=\"https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1\">Pattern matching's built-in matchers</a></li>\n</ul>","src":null,"test":""},{"name":"isFinite","manifest":{"fnSignature":"_.isFinite(value)","lodashLink":"https://lodash.com/docs/4.17.15#isFinite","summaryHtml":"<p>Checks if <code>value</code> is a finite primitive number.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">Number.isFinite(value)\n</code></pre>","src":null,"test":""},{"name":"isFunction","manifest":{"fnSignature":"_.isFunction(value)","lodashLink":"https://lodash.com/docs/4.17.15#isFunction","summaryHtml":"<p>Checks if <code>value</code> is classified as a <code>Function</code> object.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">typeof value === 'function'\n</code></pre>\n<p>Note that <code>typeof Function.prototype</code> is also <code>'function'</code>. While it may be overkill, you can use a helper function like the following to exclude <code>Function.prototype</code>.</p>\n<pre><code class=\"javascript language-javascript\">function isFunction(value) {\n  const protoOf = Object.getPrototypeOf;\n  return (\n    typeof value === 'function' &amp;&amp;\n    protoOf(protoOf(value)) !== null // Make sure Function.prototype was not passed in\n  );\n}\n</code></pre>","src":null,"test":""},{"name":"isInteger","manifest":{"fnSignature":"_.isInteger(value)","lodashLink":"https://lodash.com/docs/4.17.15#isInteger","summaryHtml":"<p>Checks if <code>value</code> is an integer.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">Number.isInteger(value)\n</code></pre>","src":null,"test":""},{"name":"isLength","manifest":{"fnSignature":"_.isLength(value)","lodashLink":"https://lodash.com/docs/4.17.15#isLength","summaryHtml":"<p>Checks if <code>value</code> is a valid array-like length.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">Number.isInteger(value) &amp;&amp; value &gt;= 0\n</code></pre>","src":null,"test":"function isLength(value) {\n  return Number.isInteger(value) && value >= 0;\n}\n\ndescribe('isLength()', () => {\n  it('returns true on positive integers', () => {\n    expect(isLength(2)).toBe(true);\n  });\n\n  it('returns true on the number 0', () => {\n    expect(isLength(0)).toBe(true);\n  });\n\n  it('returns false on strings', () => {\n    expect(isLength('2')).toBe(false);\n  });\n\n  it('returns false with Infinity', () => {\n    expect(isLength(Infinity)).toBe(false);\n  });\n\n  it('returns false with NaN', () => {\n    expect(isLength(NaN)).toBe(false);\n  });\n\n  it('returns false with floats', () => {\n    expect(isLength(2.3)).toBe(false);\n  });\n\n  it('returns false with large numbers (as those are represented as floats)', () => {\n    // eslint-disable-next-line no-loss-of-precision\n    expect(isLength(2e999)).toBe(false);\n  });\n});\n"},{"name":"isMap","manifest":{"fnSignature":"_.isMap(value)","lodashLink":"https://lodash.com/docs/4.17.15#isMap","summaryHtml":"<p>Checks if <code>value</code> is classified as a <code>Map</code> object.</p>"},"descriptionHtml":"<p>To check if your value is an instance of <code>Map</code>:</p>\n<pre><code class=\"javascript language-javascript\">value instanceof Map\n</code></pre>\n<p>The above should be good enough for the vast majority of use-cases.</p>\n<p>It's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:</p>\n<pre><code class=\"javascript language-javascript\">Object.getPrototypeOf(value) === Map.prototype\n</code></pre>\n<p>Both of the above type-detection mechanisms have a couple of flaws:</p>\n<ol>\n<li>they don't work with cross-realm values. For example, if you receive an instance of a <code>Map</code> from across an iframe boundary, that instance's prototype would link to the iframe's <code>Map</code> class, not your <code>Map</code> class, and both of the above checks would fail to recognize it as a <code>Map</code>.</li>\n<li>They will state that <code>Object.create(Map.prototype)</code> is a <code>Map</code>, but it's not. It's just a regular object who's prototype has been set to <code>Map.prototype</code>.</li>\n</ol>\n<p>Both of these issues can be solved with a helper function like this:</p>\n<pre><code class=\"javascript language-javascript\">// An isMap() check that supports cross-realm Maps.\nfunction isMap(value) {\n  try {\n    // If you call a Map method, like .get(),\n    // with a \"this\" value that's anything\n    // other than a Map, a TypeError is thrown.\n    Map.prototype.get.call(value, undefined);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n</code></pre>\n<p>If you additionally need to ensure your are not receiving a <code>Map</code> instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace <code>return true;</code> with the following:</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">// A Map's prototype's chain should be\n// value -&gt; Map.prototype -&gt; Object.prototype -&gt; null\n// If it's not, then we're dealing with a Map subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n</code></pre>\n<p>Lodash's <code>_.isMap()</code> also supports cross-realm <code>Map</code> checks, but it uses a less robust algorithm that can be easily fooled. For example, if you run Lodash in the browser, the following will return the wrong answer.</p>\n<pre><code class=\"javascript language-javascript\">_.isMap({ get [Symbol.toStringTag]() { return 'Map' } })\n// =&gt; true\n</code></pre>\n<p>In Node, Lodash will instead use <code>require('util').types.isMap(value)</code> for it's implementation, which you are also welcome to use if you know your code will only run in Node. This solution will also return <code>true</code> for subclasses.</p>\n<p>Future JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:</p>\n<ul>\n<li><a href=\"https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1\">Pattern matching's built-in matchers</a></li>\n</ul>","src":null,"test":""},{"name":"isNaN","manifest":{"fnSignature":"_.isNaN(value)","lodashLink":"https://lodash.com/docs/4.17.15#isMap","summaryHtml":"<p>Checks if <code>value</code> is NaN. <strong>Note:</strong> This method is based on <code>Number.isNaN</code> and is not the same as global <code>isNaN</code> which returns <code>true</code> for <code>undefined</code> and other non-number values.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">Number.isNaN(value)\n</code></pre>\n<p>Note that <code>Number.isNaN()</code> differs from the global <code>isNaN()</code> function in that the global <code>isNaN()</code> can only be used with numeric values. Non-numeric values will be coerced into numbers, potentially yielding wrong answers.</p>\n<pre><code class=\"javascript language-javascript\">isNaN(undefined) // =&gt; true\nNumber.isNaN(undefined) // =&gt; false\n</code></pre>","src":null,"test":""},{"name":"isNative","manifest":{"fnSignature":"_.isNative(value)","lodashLink":"https://lodash.com/docs/4.17.15#isNative","summaryHtml":"<p>Checks if <code>value</code> is a pristine native function.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function isNative(value) {\n  if (typeof value !== 'function') {\n    return false;\n  }\n\n  const nativeFnPattern = /^function.*?\\(\\) \\{ \\[native code\\] \\}$/;\n  const valueAsString = Function.prototype.toString.call(value);\n  return nativeFnPattern.test(valueAsString);\n}\n</code></pre>\n<p>Some good things to know about both this implementation and Lodash's <code>_.isNative()</code>:</p>\n<ul>\n<li>The return value of <code>yourNonNativeFunction.bind()</code> is considered a native function.</li>\n<li>Not all of Node's built-in functions will be considered native, for example, in Node 18, <code>Function.prototype.toString.call(setTimeout)</code> will return the source code for the function instead of the regular <code>function setTimeout() { [native code] }</code>. This is likely due to the fact that many of Node's standard library functions are implemented in JavaScript itself.</li>\n</ul>\n<p>On <a href=\"https://lodash.com/docs/4.17.15#isNative\">Lodash's website</a> you'll also see a warning about how their <code>_.isNative()</code> functions are unable to tell the difference between a core.js function and a native one, so if it detects that you are using core.js, their <code>_.isNative()</code> will always throw. The above <code>isNative()</code> is also unable to tell the difference between a core.js polyfilled function and a native one.</p>\n<p>Every code snippet provided in Snap.js is operating under the assumption that the standard library is pristine and untouched, and the above <code>isNative()</code> operates under the same assumption. As long as no one is monkey-patching the standard library, the <code>isNative()</code> function will work with any modern JavaScript engine just fine and can't be spoofed. The reason Core.js is capable of getting around these checks is because it monkey-patches <code>Function.prototype.toString</code> and replaces it with its own implementation. If you're worried about running in an environment where monkey-patching might be happening, the correct way to handle this (for any of the snap.js functions, and any code you write in general) is to locally cache the built-in functions you need when your code first loads. Then, as long as your library is imported before any monkey-patching happens, your code won't be affected by the monkey-patching at all. If your library loads after monkey patching has happened, then all bets are off - you just have to trust that your host was responsible with how they've been messing with the globals.</p>\n<p>Here's an example of how you can make the <code>isNative()</code> function in a more robust manner, so that if this module loads before core-js (or any other library that messes with the globals), it'll still work just fine. (Writing robust code as shown above adds a big toll on the readability and maintainability of your codebase - only use techniques like this when it's actually necessary).</p>\n<pre><code class=\"javascript language-javascript\">const callBind = fn =&gt; fn.call.bind(fn);\n\nconst functionToString = callBind(Function.prototype.toString);\nconst regExpTest = callBind(RegExp.prototype.test);\n\nfunction isNative(value) {\n  if (typeof value !== 'function') {\n    return false;\n  }\n\n  const nativeFnPattern = /^function.*?\\(\\) \\{ \\[native code\\] \\}$/;\n  const valueAsString = functionToString(value);\n  return regExpTest(nativeFnPattern, valueAsString);\n}\n</code></pre>\n<p>Lodash actually follows this robust code pattern throughout its library, it has just chosen to additionally check for the presence of core.js and throw an error if it found that core.js was loaded, just in case core.js loaded before lodash.</p>","src":null,"test":""},{"name":"isNil","manifest":{"fnSignature":"_.isNil(value)","lodashLink":"https://lodash.com/docs/4.17.15#isNil","summaryHtml":"<p>Checks if <code>value</code> is <code>null</code> or <code>undefined</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">value == null\n</code></pre>\n<p>In general, you should never use loose equality (<code>==</code>) in JavaScript, however, many people like to make the comparison against <code>null</code> an exception to this rule because it's a convenient way to check for either <code>null</code> or <code>undefined</code> - a fairly common operation.</p>\n<p>Alternatively, if you wish to tailor to an audience who may be unfamiliar with the <code>== null</code> trick, the following would be the most explicit and easy-to-read way to go.</p>\n<pre><code class=\"javascript language-javascript\">value === null || value === undefined\n</code></pre>\n<p>There's also some who like using the nullish coalescing operator (<code>??</code>) to get similar behavior.</p>\n<pre><code class=\"javascript language-javascript\">(value ?? null) === null\n</code></pre>","src":null,"test":""},{"name":"isNull","manifest":{"fnSignature":"_.isNull(value)","lodashLink":"https://lodash.com/docs/4.17.15#isNull","summaryHtml":"<p>Checks if <code>value</code> is <code>null</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">value === null\n</code></pre>","src":null,"test":""},{"name":"isNumber","manifest":{"fnSignature":"_.isNumber(value)","lodashLink":"https://lodash.com/docs/4.17.15#isNumber","summaryHtml":"<p>Checks if <code>value</code> is classified as a <code>Number</code> primitive or object. <strong>Note:</strong> To exclude <code>Infinity</code>, <code>-Infinity</code>, and <code>NaN</code>, which are classified as numbers, use the <code>_.isFinite</code> method.</p>"},"descriptionHtml":"<p>To check if a value is a number primitive:</p>\n<pre><code class=\"javascript language-javascript\">typeof value === 'number'\n</code></pre>\n<p>The above should be good enough for the vast majority of use-cases.</p>\n<p>Lodash will also check if the value is a number object. In practice, such objects should never be found in your codebase, and if someone ever tries to hand such an object to you you really ought to treat it the same way you would treat any other bad input (throw an error, or if you aren't explicitly trying to check for bad inputs just let your library fall over, the same way it would with any other bad input).</p>\n<p>To check if something is specifically a number object (and not a primitive), use the following:</p>\n<pre><code class=\"javascript language-javascript\">value instanceof Number\n</code></pre>\n<p>This, however, doesn't work cross realm (i.e. a number object created from inside an iframe would fail this check). It also would incorrectly state that <code>Object.create(Number.prototype)</code> is a number object, when in reality, it's just a normal object who's prototype is set to <code>Number.prototype</code>. If you need to worry about these kinds of issues, use the following solution instead:</p>\n<pre><code class=\"javascript language-javascript\">// An isNumber() check that supports cross-realm Number instances.\n// This will check if `value` is a number primitive or object.\n// Returns `true` for values that inherit from `Number` as well.\nfunction isNumber(value) {\n  try {\n    // If you call this method with a \"this\" value that's anything\n    // other than a Number primitive or object, a TypeError is thrown.\n    Number.prototype.valueOf.call(value);\n    // Makes sure Number.prototype was not passed in.\n    const protoOf = Object.getPrototypeOf;\n    return protoOf(protoOf(value)) !== null;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n</code></pre>\n<p>Lodash's <code>_.isNumber()</code> also supports cross-realm Number object checks, but it uses a less robust algorithm that can be easily fooled. For example, the following will return the wrong answer.</p>\n<pre><code class=\"javascript language-javascript\">_.isNumber({ get [Symbol.toStringTag]() { return 'Number' } })\n// =&gt; true\n</code></pre>\n<p>If you're exclusively using Node, you can use <code>require('util').types.isNumberObject(value)</code> to specifically check if the value is a number object (not a primitive). This solution will also return <code>true</code> for both subclasses and <code>Number.prototype</code>.</p>","src":null,"test":""},{"name":"isObject","manifest":{"fnSignature":"_.isObject(value)","lodashLink":"https://lodash.com/docs/4.17.15#isObject","summaryHtml":"<p>Checks if <code>value</code> is the language type of <code>Object</code>. (e.g. arrays, functions, objects, regexes, <code>new Number(0)</code>, and <code>new String('')</code>)</p>"},"descriptionHtml":"<p>All of these solutions are equivalent. Pick the one you find to be the most readable.</p>\n<pre><code class=\"javascript language-javascript\">const isObject = value =&gt; value === Object(value);\n</code></pre>\n<pre><code class=\"javascript language-javascript\">const isObject = value =&gt; ['object', 'function'].includes(typeof value) &amp;&amp; value !== null;\n</code></pre>\n<pre><code class=\"javascript language-javascript\">const isObject = value =&gt; typeof value === 'function' || (typeof value === 'object' &amp;&amp; value !== null);\n</code></pre>","src":null,"test":""},{"name":"isObjectLike","manifest":{"fnSignature":"_.isObjectLike(value)","lodashLink":"https://lodash.com/docs/4.17.15#isObjectLike","summaryHtml":"<p>Checks if <code>value</code> is object-like. A value is object-like if it's not <code>null</code> and has a <code>typeof</code> result of \"object\".</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">const isObjectLike = value =&gt; typeof value === 'object' &amp;&amp; value !== null;\n</code></pre>\n<p><code>_.isObjectLike()</code> is really the same thing as <code>_.isObject()</code> except that it excludes functions. You could be more explicit about this by naming the function something like <code>isObjectButNotFunction()</code>, or by spelling this out in code at the usage site as follows:</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">const isObject = value =&gt; value === Object(value);\n\nif (isObject(value) &amp;&amp; typeof value !== 'function') { ... }\n</code></pre>","src":null,"test":""},{"name":"isPlainObject","manifest":{"fnSignature":"_.isPlainObject(value)","lodashLink":"https://lodash.com/docs/4.17.15#isPlainObject","summaryHtml":"<p>Checks if <code>value</code> is a plain object, that is, an object created by the <code>Object</code> constructor or one with a <code>[[Prototype]]</code> of <code>null</code>.</p>"},"descriptionHtml":"<p>To check if your value is a \"plain object\" like <code>{ x: 2 }</code></p>\n<pre><code class=\"javascript language-javascript\">value != null &amp;&amp; [null, Object.prototype].includes(Object.getPrototypeOf(value))\n</code></pre>\n<p>The above should be good enough for the vast majority of use-cases.</p>\n<p>The above type-detection mechanisms has the flaw that it does not work with cross-realm values. For example, if you receive an object from across an iframe boundary, that object's prototype would link to the iframe's <code>Object</code>, not your <code>Object</code>, and the above checks would fail to recognize it as a plain object. A cross-realm compatible solution could look something like this (depending how spoof-proof you want it to be):</p>\n<pre><code class=\"javascript language-javascript\">function isPlainObject(value) {\n  if (value == null) {\n    return false;\n  }\n\n  const protoOf = Object.getPrototypeOf;\n  if (protoOf(value) === null) {\n    return true;\n  }\n\n  const objectConstructorAsString = 'function Object() { [native code] }';\n  return (\n    protoOf(protoOf(value)) === null &amp;&amp;\n    typeof protoOf(value).constructor === 'function' &amp;&amp;\n    Function.prototype.toString.call(protoOf(value).constructor) === objectConstructorAsString\n  );\n}\n</code></pre>\n<p>Unfortunately you can't have an is-plain-object check that's both cross-realm-compatible and spoof-proof. The algorithm presented above can be spoofed as follows:</p>\n<pre><code class=\"javascript language-javascript\">class SpecialClass {\n  static {\n    Object.setPrototypeOf(SpecialClass.prototype, null);\n    // This doesn't literally change the class's constructor,\n    // it just changes an informational property to be a lie.\n    SpecialClass.prototype.constructor = Object;\n  }\n}\n\nisPlainObject(new SpecialClass()); // =&gt; true\n</code></pre>\n<p>Even Lodash's algorithm can be spoofed.</p>\n<pre><code class=\"javascript language-javascript\">class SpecialClass {\n  static {\n    SpecialClass.prototype.constructor = Object;\n  }\n}\n\n_.isPlainObject(new SpecialClass()) // =&gt; true\n</code></pre>\n<p>Future JavaScript proposals may provide support for cross-realm type checking:</p>\n<ul>\n<li><a href=\"https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1\">Pattern matching's built-in matchers</a></li>\n</ul>","src":null,"test":""},{"name":"isRegExp","manifest":{"fnSignature":"_.isRegExp(value)","lodashLink":"https://lodash.com/docs/4.17.15#isRegExp","summaryHtml":"<p>Checks if <code>value</code> is classified as a <code>RegExp</code> object.</p>"},"descriptionHtml":"<p>To check if your value is a regular expression instance:</p>\n<pre><code class=\"javascript language-javascript\">value instanceof RegExp\n</code></pre>\n<p>The above should be good enough for the vast majority of use-cases.</p>\n<p>It's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:</p>\n<pre><code class=\"javascript language-javascript\">Object.getPrototypeOf(value) === RegExp.prototype\n</code></pre>\n<p>Both of the above type-detection mechanisms have a couple of flaws:</p>\n<ol>\n<li>they don't work with cross-realm values. For example, if you receive an instance of <code>RegExp</code> from across an iframe boundary, that instance's prototype would link to the iframe's <code>RegExp</code> class, not your <code>RegExp</code> class, and both of the above checks would fail to recognize it as an RegExp instance.</li>\n<li>They will state that <code>Object.create(RegExp.prototype)</code> is a regular expression instance, but it's not. It's just a regular object who's prototype has been set to <code>RegExp.prototype</code>.</li>\n</ol>\n<p>Both of these issues can be solved with a helper functions such as this:</p>\n<pre><code class=\"javascript language-javascript\">class StringifyError extends Error {}\n\n// An isRegExp() check that supports cross-realm RegExp instances.\n// This solution is loosely inspired by https://github.com/inspect-js/is-regex's implementation.\nfunction isRegExp(value) {\n  // An argument that throws when stringified will be used\n  // to prevent exec() from completing and updating value.lastIndex.\n  const badArgument = {\n    toString() { throw new StringifyError(); },\n  }\n\n  try {\n    // Calling the `.exec()` method,\n    // with a \"this\" value that's anything\n    // other than a RegExpr will throw a TypeError.\n    RegExp.prototype.exec.call(value, badArgument);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    } else if (error instanceof StringifyError) {\n      return true;\n    } else {\n      throw error;\n    }\n  }\n}\n</code></pre>\n<p>If you additionally need to ensure your are not receiving a <code>RegExp</code> instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace <code>return true;</code> with the following:</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">// A RegExp's prototype's chain should be\n// value -&gt; RegExp.prototype -&gt; Object.prototype -&gt; null\n// If it's not, then we're dealing with a RegExp subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n</code></pre>\n<p>Lodash's <code>_.isRegExp()</code> also supports cross-realm <code>RegExp</code> checks, but it uses a less robust algorithm that can be easily fooled. For example, if you run Lodash in the browser, the following will return the wrong answer.</p>\n<pre><code class=\"javascript language-javascript\">_.isRegExp({ get [Symbol.toStringTag]() { return 'RegExp' } })\n// =&gt; true\n</code></pre>\n<p>In Node, Lodash will instead use <code>require('util').types.isRegExp(value)</code> for it's implementation, which you are also welcome to use if you know your code will only run in Node. This solution will also return <code>true</code> for subclasses.</p>\n<p>Future JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:</p>\n<ul>\n<li><a href=\"https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1\">Pattern matching's built-in matchers</a></li>\n</ul>","src":null,"test":""},{"name":"isSafeInteger","manifest":{"fnSignature":"_.isSafeInteger(value)","lodashLink":"https://lodash.com/docs/4.17.15#isSafeInteger","summaryHtml":"<p>Checks if <code>value</code> is a safe integer. An integer is safe if it's an IEEE-754 double precision number which isn't the result of a rounded unsafe integer.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">Number.isSafeInteger(value)\n</code></pre>","src":null,"test":""},{"name":"isSet","manifest":{"fnSignature":"_.isSet(value)","lodashLink":"https://lodash.com/docs/4.17.15#isSet","summaryHtml":"<p>Checks if <code>value</code> is classified as a <code>Set</code> object.</p>"},"descriptionHtml":"<p>To check if your value is an instance of <code>Set</code>:</p>\n<pre><code class=\"javascript language-javascript\">value instanceof Set\n</code></pre>\n<p>The above should be good enough for the vast majority of use-cases.</p>\n<p>It's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:</p>\n<pre><code class=\"javascript language-javascript\">Object.getPrototypeOf(value) === Set.prototype\n</code></pre>\n<p>Both of the above type-detection mechanisms have a couple of flaws:</p>\n<ol>\n<li>they don't work with cross-realm values. For example, if you receive an instance of a <code>Set</code> from across an iframe boundary, that instance's prototype would link to the iframe's <code>Set</code> class, not your <code>Set</code> class, and both of the above checks would fail to recognize it as a <code>Set</code>.</li>\n<li>They will state that <code>Object.create(Set.prototype)</code> is a <code>Set</code>, but it's not. It's just a regular object who's prototype has been set to <code>Set.prototype</code>.</li>\n</ol>\n<p>Both of these issues can be solved with a helper function like this:</p>\n<pre><code class=\"javascript language-javascript\">// An isSet() check that supports cross-realm Sets.\nfunction isSet(value) {\n  try {\n    // If you call a Set method, like .size(),\n    // with a \"this\" value that's anything\n    // other than a Set, a TypeError is thrown.\n    Set.prototype.has.call(value, undefined);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n</code></pre>\n<p>If you additionally need to ensure your are not receiving a <code>Set</code> instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace <code>return true;</code> with the following:</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">// A Set's prototype's chain should be\n// value -&gt; Set.prototype -&gt; Object.prototype -&gt; null\n// If it's not, then we're dealing with a Set subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n</code></pre>\n<p>Lodash's <code>_.isSet()</code> also supports cross-realm <code>Set</code> checks, but it uses a less robust algorithm that can be easily fooled. For example, if you run Lodash in the browser, the following will return the wrong answer.</p>\n<pre><code class=\"javascript language-javascript\">_.isSet({ get [Symbol.toStringTag]() { return 'Set' } })\n// =&gt; true\n</code></pre>\n<p>In Node, Lodash will instead use <code>require('util').types.isSet(value)</code> for it's implementation, which you are also welcome to use if you know your code will only run in Node. This solution will also return <code>true</code> for subclasses.</p>\n<p>Future JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:</p>\n<ul>\n<li><a href=\"https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1\">Pattern matching's built-in matchers</a></li>\n</ul>","src":null,"test":""},{"name":"isString","manifest":{"fnSignature":"_.isString(value)","lodashLink":"https://lodash.com/docs/4.17.15#isString","summaryHtml":"<p>Checks if <code>value</code> is classified as a <code>string</code> primitive or object.</p>"},"descriptionHtml":"<p>To check if a value is a string primitive:</p>\n<pre><code class=\"javascript language-javascript\">typeof value === 'string'\n</code></pre>\n<p>The above should be good enough for the vast majority of use-cases.</p>\n<p>Lodash will also check if the value is a string object. In practice, such objects should never be found in your codebase, and if someone ever tries to hand such an object to you you really ought to treat it the same way you would treat any other bad input (throw an error, or if you aren't explicitly trying to check for bad inputs just let your library fall over, the same way it would with any other bad input).</p>\n<p>To check if something is specifically a string object (and not a primitive), use the following:</p>\n<pre><code class=\"javascript language-javascript\">value instanceof Boolean\n</code></pre>\n<p>This, however, doesn't work cross realm (i.e. a string object created from inside an iframe would fail this check). It also would incorrectly state that <code>Object.create(String.prototype)</code> is a string object, when in reality, it's just a normal object who's prototype is set to <code>String.prototype</code>. If you need to worry about these kinds of issues, use the following solution instead:</p>\n<pre><code class=\"javascript language-javascript\">// An isString() check that supports cross-realm String instances.\n// This will check if `value` is a string primitive or object.\n// Returns `true` for values that inherit from `String` as well.\nfunction isString(value) {\n  try {\n    // If you call this method with a \"this\" value that's anything\n    // other than a boolean primitive or object, a TypeError is thrown.\n    String.prototype.toString.call(value);\n    // Makes sure String.prototype was not passed in.\n    const protoOf = Object.getPrototypeOf;\n    return protoOf(protoOf(value)) !== null;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n</code></pre>\n<p>Lodash's <code>_.isString()</code> also supports cross-realm <code>String</code> object checks, but it uses a less robust algorithm that can be easily fooled. For example, the following will return the wrong answer.</p>\n<pre><code class=\"javascript language-javascript\">_.isString({ get [Symbol.toStringTag]() { return 'String' } })\n// =&gt; true\n</code></pre>\n<p>If you're exclusively using Node, you can use <code>require('util').types.isStringObject(value)</code> to specifically check if the value is a string object (not a primitive). This solution will also return <code>true</code> for both subclasses and <code>Boolean.prototype</code>.</p>","src":null,"test":""},{"name":"isSymbol","manifest":{"fnSignature":"_.isSymbol(value)","lodashLink":"https://lodash.com/docs/4.17.15#isSymbol","summaryHtml":"<p>Checks if <code>value</code> is classified as a <code>symbol</code> primitive or object.</p>"},"descriptionHtml":"<p>To check if a value is a symbol primitive:</p>\n<pre><code class=\"javascript language-javascript\">typeof value === 'symbol'\n</code></pre>\n<p>The above should be good enough for the vast majority of use-cases.</p>\n<p>Lodash will also check if the value is a symbol object. In practice, such objects should never be found in your codebase, and if someone ever tries to hand such an object to you you really ought to treat it the same way you would treat any other bad input (throw an error, or if you aren't explicitly trying to check for bad inputs just let your library fall over, the same way it would with any other bad input).</p>\n<p>To check if something is specifically a symbol object (and not a primitive), use the following:</p>\n<pre><code class=\"javascript language-javascript\">value instanceof Symbol\n</code></pre>\n<p>This, however, doesn't work cross realm (i.e. a symbol object created from inside an iframe would fail this check). It also would incorrectly state that <code>Object.create(Symbol.prototype)</code> is a symbol object, when in reality, it's just a normal object who's prototype is set to <code>Symbol.prototype</code>. If you need to worry about these kinds of issues, use the following solution instead:</p>\n<pre><code class=\"javascript language-javascript\">// An isSymbol() check that supports cross-realm Symbol instances.\n// This will check if `value` is a symbol primitive or object.\nfunction isSymbol(value) {\n  try {\n    // If you call this method with a \"this\" value that's anything\n    // other than a boolean primitive or object, a TypeError is thrown.\n    Symbol.prototype.valueOf.call(value);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n</code></pre>\n<p>Lodash's <code>_.isSymbol()</code> also supports cross-realm <code>Symbol</code> object checks, but it uses a less robust algorithm that can be easily fooled. For example, the following will return the wrong answer.</p>\n<pre><code class=\"javascript language-javascript\">_.isSymbol({ get [Symbol.toStringTag]() { return 'Symbol' } })\n// =&gt; true\n</code></pre>\n<p>If you're exclusively using Node, you can use <code>require('util').types.isSymbolObject(value)</code> to specifically check if the value is a string object (not a primitive).</p>","src":null,"test":""},{"name":"isTypedArray","manifest":{"fnSignature":"_.isTypedArray(value)","lodashLink":"https://lodash.com/docs/4.17.15#isTypedArray","summaryHtml":"<p>Checks if <code>value</code> is classified as a typed array.</p>"},"descriptionHtml":"<p>All concrete type array classes (like <code>Int8Array</code> and <code>Uint32Array</code>) inherit from the same abstract superclass <code>TypedArray</code>. This superclass isn't directly available on the global object, but it's not too hard to get your hands on it. You can use the <code>TypedArray</code> superclass to check if a value is a typed array as follows:</p>\n<pre><code class=\"javascript language-javascript\">function isTypedArray(value) {\n  // Get the super class of all typed arrays.\n  const TypedArray = Object.getPrototypeOf(Int8Array);\n\n  return value instanceof TypedArray;\n}\n\nisTypedArray(new Int8Array()); // =&gt; true\nisTypedArray(new Uint32Array()); // =&gt; true\n</code></pre>\n<p>For the vast majority of scenarios the above should be good enough, but it does technically have a couple of flaws:</p>\n<ol>\n<li>they don't work with cross-realm values. For example, if you receive an instance of an <code>Int8Array</code> from across an iframe boundary, that instance's prototype would link to the iframe's <code>TypedArray</code> class, not your <code>TypedArray</code> class, and both of the above checks would fail to recognize it as a typed array.</li>\n<li>They will state that <code>Object.create(TypedArray.prototype)</code> is a <code>TypedArray</code>, but it's not. It's just a regular object who's prototype has been set to <code>TypedArray.prototype</code>.</li>\n</ol>\n<p>Both of these issues can be solved with a helper function like this:</p>\n<pre><code class=\"javascript language-javascript\">// An isTypedArray() check that supports cross-realm typed arrays.\nfunction isTypedArray(value) {\n  const TypedArray = Object.getPrototypeOf(Int8Array);\n  try {\n    // If you call a TypedArray method, like .at(),\n    // with a \"this\" value that's anything\n    // other than a typed array, a TypeError is thrown.\n    TypedArray.prototype.at.call(value, 0);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n</code></pre>\n<p>It's generally considered a bad practice to subclass built-ins, but if you suspect that one of the concrete typed array classes might getting subclassed and handed to you, and you wish to exclude subclasses from your check, you'd also need to walk up the prototype chain. You can modify the above example and replace <code>return true;</code> with the following:</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">// A typed array prototype's chain should be\n// value -&gt; concrete class prototype (like Int8Array.prototype) -&gt; TypedArray.prototype -&gt; Object.prototype -&gt; null\n// If it's not, then we're dealing with a subclass of a concrete typed array.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(protoOf(value)))) === null;\n</code></pre>\n<p>Lodash's <code>_.isTypedArray()</code> also supports cross-realm typed array checks, but it uses a less robust algorithm that can be easily fooled. For example, if you run Lodash in the browser, the following will return the wrong answer.</p>\n<pre><code class=\"javascript language-javascript\">_.isTypedArray({ length: 0, get [Symbol.toStringTag]() { return 'Uint8Array' } })\n// =&gt; true\n</code></pre>\n<p>In Node, Lodash will instead use <code>require('util').types.isTypedArray(value)</code> for it's implementation, which you are also welcome to use if you know your code will only run in Node. This solution will also return <code>true</code> for subclasses.</p>\n<p>Future JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:</p>\n<ul>\n<li><a href=\"https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1\">Pattern matching's built-in matchers</a></li>\n</ul>","src":null,"test":""},{"name":"isUndefined","manifest":{"fnSignature":"_.isUndefined(value)","lodashLink":"https://lodash.com/docs/4.17.15#isUndefined","summaryHtml":"<p>Checks if <code>value</code> is <code>undefined</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">value === undefined\n</code></pre>\n<p>At one point in time it was often considered a good practice to compare against <code>void 0</code> instead of <code>undefined</code>, as <code>undefined</code> was just a property on the window object that could be overwritten to be any value while <code>void 0</code> (which returns the undefined value) can not be overwritten since it is syntax. The ability to globally overwrite the <code>undefined</code> value was changed in ES5, removing this concern in modern browsers. Even back then, this concern was largely over-hyped - yes you can override the value of <code>undefined</code>, but you can also override <code>Array</code>, <code>Math</code>, <code>Object</code>, <code>Function</code>, <code>setTimeout</code>, and so on - if the code you write doesn't try to defend against these globals being overwritten, then it should not try to defend against <code>undefined</code> being overwritten either.</p>\n<p>Side rant: In case you didn't know, <code>void</code> is <em>not</em> a function, it is a prefix operator with the same precedence as <code>!</code>, <code>await</code>, <code>typeof</code>, and so on. You don't try to pretend <code>await</code> is a function by always adding parentheses after it, do you? (<code>await(doSomeAsyncTask())</code>)? No. And you really don't need to do it with <code>void</code> either. Is there harm in pretending a prefix operator is a function? In general, yes, because it makes order of operations confusing - if we pretend that <code>await</code> is a function, then you might end up writing code such as <code>await(getUser(id)).username</code> that looks reasonable, except it's not going to work - <code>getUser(...)</code> is going to return a promise, and then it's going to try to access the <code>username</code> property on that promise <em>before</em> the <code>await</code> happens, which is not what the author intended. Is it bad to pretend that <code>void</code>, specifically, is a function instead of an operator. Well, technically no, there's no reasonable code that you would write using <code>void</code> where order of operations would get confusing, at least in the language as it stands today. But, the point is, <code>void</code> is an operator, not a function, and there's no reason to pretend it's something that it's not.</p>","src":null,"test":""},{"name":"isWeakMap","manifest":{"fnSignature":"_.isWeakMap(value)","lodashLink":"https://lodash.com/docs/4.17.15#isWeakMap","summaryHtml":"<p>Checks if <code>value</code> is classified as a <code>WeakMap</code> object.</p>"},"descriptionHtml":"<p>To check if your value is an instance of <code>WeakMap</code>:</p>\n<pre><code class=\"javascript language-javascript\">value instanceof WeakMap\n</code></pre>\n<p>The above should be good enough for the vast majority of use-cases.</p>\n<p>It's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:</p>\n<pre><code class=\"javascript language-javascript\">Object.getPrototypeOf(value) === WeakMap.prototype\n</code></pre>\n<p>Both of the above type-detection mechanisms have a couple of flaws:</p>\n<ol>\n<li>they don't work with cross-realm values. For example, if you receive an instance of a <code>WeakMap</code> from across an iframe boundary, that instance's prototype would link to the iframe's <code>WeakMap</code> class, not your <code>WeakMap</code> class, and both of the above checks would fail to recognize it as a <code>WeakMap</code>.</li>\n<li>They will state that <code>Object.create(WeakMap.prototype)</code> is a <code>WeakMap</code>, but it's not. It's just a regular object who's prototype has been set to <code>WeakMap.prototype</code>.</li>\n</ol>\n<p>Both of these issues can be solved with a helper function like this:</p>\n<pre><code class=\"javascript language-javascript\">// An isWeakMap() check that supports cross-realm WeakMaps.\nfunction isWeakMap(value) {\n  try {\n    // If you call a WeakMap method, like .get(),\n    // with a \"this\" value that's anything\n    // other than a WeakMap, a TypeError is thrown.\n    WeakMap.prototype.get.call(value, undefined);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n</code></pre>\n<p>If you additionally need to ensure your are not receiving a <code>WeakMap</code> instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace <code>return true;</code> with the following:</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">// A WeakMap's prototype's chain should be\n// value -&gt; WeakMap.prototype -&gt; Object.prototype -&gt; null\n// If it's not, then we're dealing with a WeakMap subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n</code></pre>\n<p>Lodash's <code>_.isWeakMap()</code> also supports cross-realm <code>WeakMap</code> checks, but it uses a less robust algorithm that can be easily fooled. For example, the following will return the wrong answer.</p>\n<pre><code class=\"javascript language-javascript\">_.isWeakMap({ get [Symbol.toStringTag]() { return 'WeakMap' } })\n// =&gt; true\n</code></pre>\n<p>If you're exclusively using Node, you can use <code>require('util').types.isWeakMap(value)</code> to specifically check if the value is a WeakMap. This solution will also return <code>true</code> for subclasses.</p>\n<p>Future JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:</p>\n<ul>\n<li><a href=\"https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1\">Pattern matching's built-in matchers</a></li>\n</ul>","src":null,"test":""},{"name":"isWeakSet","manifest":{"fnSignature":"_.isWeakSet(value)","lodashLink":"https://lodash.com/docs/4.17.15#isWeakSet","summaryHtml":"<p>Checks if <code>value</code> is classified as a <code>WeakSet</code> object.</p>"},"descriptionHtml":"<p>To check if your value is an instance of <code>WeakSet</code>:</p>\n<pre><code class=\"javascript language-javascript\">value instanceof WeakSet\n</code></pre>\n<p>The above should be good enough for the vast majority of use-cases.</p>\n<p>It's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:</p>\n<pre><code class=\"javascript language-javascript\">Object.getPrototypeOf(value) === WeakSet.prototype\n</code></pre>\n<p>Both of the above type-detection mechanisms have a couple of flaws:</p>\n<ol>\n<li>they don't work with cross-realm values. For example, if you receive an instance of a <code>WeakSet</code> from across an iframe boundary, that instance's prototype would link to the iframe's <code>WeakSet</code> class, not your <code>WeakSet</code> class, and both of the above checks would fail to recognize it as a <code>WeakSet</code>.</li>\n<li>They will state that <code>Object.create(WeakSet.prototype)</code> is a <code>WeakSet</code>, but it's not. It's just a regular object who's prototype has been set to <code>WeakSet.prototype</code>.</li>\n</ol>\n<p>Both of these issues can be solved with a helper function like this:</p>\n<pre><code class=\"javascript language-javascript\">// An isWeakSet() check that supports cross-realm WeakSets.\nfunction isWeakSet(value) {\n  try {\n    // If you call a WeakSet method, like .has(),\n    // with a \"this\" value that's anything\n    // other than a WeakSet, a TypeError is thrown.\n    WeakSet.prototype.has.call(value, undefined);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n</code></pre>\n<p>If you additionally need to ensure your are not receiving a <code>WeakSet</code> instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace <code>return true;</code> with the following:</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">// A WeakSet's prototype's chain should be\n// value -&gt; WeakSet.prototype -&gt; Object.prototype -&gt; null\n// If it's not, then we're dealing with a WeakSet subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n</code></pre>\n<p>Lodash's <code>_.isWeakSet()</code> also supports cross-realm <code>WeakSet</code> checks, but it uses a less robust algorithm that can be easily fooled. For example, the following will return the wrong answer.</p>\n<pre><code class=\"javascript language-javascript\">_.isWeakSet({ get [Symbol.toStringTag]() { return 'WeakSet' } })\n// =&gt; true\n</code></pre>\n<p>If you're exclusively using Node, you can use <code>require('util').types.isWeakSet(value)</code> to specifically check if the value is a WeakSet. This solution will also return <code>true</code> for subclasses.</p>\n<p>Future JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:</p>\n<ul>\n<li><a href=\"https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1\">Pattern matching's built-in matchers</a></li>\n</ul>","src":null,"test":""},{"name":"lt","manifest":{"fnSignature":"_.lt(value, other)","lodashLink":"https://lodash.com/docs/4.17.15#lt","summaryHtml":"<p>Checks if <code>value</code> is less than <code>other</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">value &lt; other\n</code></pre>\n<p>One reason <code>_.lt()</code> exists, is because it's a ready-made function, that can easily be passed into other functions, like this:</p>\n<pre><code class=\"javascript language-javascript\">_.zipWith([1, 2, 3], [3, 2, 1], _.lt)\n// =&gt; [true, false, false]\n</code></pre>\n<p>When Lodash was first born, the only alternative at the time would be to create an entire function, using the <code>function</code> keyword.</p>\n<pre><code class=\"javascript language-javascript\">_.zipWith([1, 2, 3], [3, 2, 1], function (a, b) {\n  return a &lt; b;\n})\n</code></pre>\n<p>Since then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.</p>\n<pre><code class=\"javascript language-javascript\">_.zipWith([1, 2, 3], [3, 2, 1], (a, b) =&gt; a &lt; b)\n</code></pre>","src":null,"test":""},{"name":"lte","manifest":{"fnSignature":"_.lte(value, other)","lodashLink":"https://lodash.com/docs/4.17.15#lte","summaryHtml":"<p>Checks if <code>value</code> is less than or equal to <code>other</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">value &lt;= other\n</code></pre>\n<p>One reason <code>_.lte()</code> exists, is because it's a ready-made function, that can easily be passed into other functions, like this:</p>\n<pre><code class=\"javascript language-javascript\">_.zipWith([1, 2, 3], [3, 2, 1], _.lte)\n// =&gt; [true, true, false]\n</code></pre>\n<p>When Lodash was first born, the only alternative at the time would be to create an entire function, using the <code>function</code> keyword.</p>\n<pre><code class=\"javascript language-javascript\">_.zipWith([1, 2, 3], [3, 2, 1], function (a, b) {\n  return a &lt;= b;\n})\n</code></pre>\n<p>Since then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.</p>\n<pre><code class=\"javascript language-javascript\">_.zipWith([1, 2, 3], [3, 2, 1], (a, b) =&gt; a &lt;= b)\n</code></pre>","src":null,"test":""},{"name":"toArray","manifest":{"fnSignature":"_.toArray(value)","lodashLink":"https://lodash.com/docs/4.17.15#toArray","summaryHtml":"<p>Converts <code>value</code> to an array.</p>"},"descriptionHtml":"<p>To get an array of values out of an object, use <code>Object.values()</code>.</p>\n<pre><code class=\"javascript language-javascript\">Object.values({ a: 1, b: 2 })\n// =&gt; [1, 2]\n</code></pre>\n<p>You can also use <code>Object.keys()</code> or <code>Object.entries()</code> to get all keys or all properties as tuples respectively.</p>\n<p>To convert a string to an array, spread it into an array.</p>\n<pre><code class=\"javascript language-javascript\">[...'abc']\n// =&gt; ['a', 'b', 'c']\n</code></pre>\n<p>If you need better unicode support and an internationalization-friendly character splitter, use <code>Intl.Segmenter()</code> instead:</p>\n<pre><code class=\"javascript language-javascript\">// Set this to your preferred locale,\n// or set it to `undefined` to use the runtime's default locale.\nconst LOCALE = 'en';\nconst segmenter = new Intl.Segmenter(LOCALE);\n\nfunction stringToArray(text) {\n  return [...segmenter.segment(text)]\n    .map(({ segment }) =&gt; segment);\n}\n\nconsole.log(stringToArray('abc')) // =&gt; ['a', 'b', 'c']\n</code></pre>\n<p>Any iterable can be converted to an array using the same syntax. Strings are just one common example of an iterable, but other built-in types such as maps, sets, argument objects, and more are all iterable.</p>\n<pre><code class=\"javascript language-javascript\">const colors = new Set(['red', 'blue', 'green']);\nconsole.log([...colors]); // =&gt; ['red', 'blue', 'green']\n</code></pre>\n<p>To convert <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#array-like_objects\">an array-like value</a> into an array, use <code>Array.from()</code>.</p>\n<pre><code class=\"javascript language-javascript\">Array.from({ 0: 'a', 1: 'b', length: 2 })\n// =&gt; ['a', 'b']\n</code></pre>\n<p>Be cautious when using Lodash to convert an object into an array with <code>_.toArray()</code>. It will inspect your object and try to guess which pattern to follow when converting it, and it may guess wrong. For example, you could try using <code>_.toArray()</code> to get a list of property values from an object, but if the given object happens to have a \"length\" key with a numeric value, it's behavior will change, and it will instead treat it like an array-like object. Thus <code>_.toArray({ width: 2, height: 5 })</code> will give you <code>[2, 5]</code>, but <code>_.toArray({ width: 2, height: 5, length: 3 })</code> will give you <code>[undefined, undefined, undefined]</code>.</p>","src":null,"test":""},{"name":"toFinite","manifest":{"fnSignature":"_.toFinite(value)","lodashLink":"https://lodash.com/docs/4.17.15#toFinite","summaryHtml":"<p>Converts <code>value</code> to a finite number.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function toFinite(value) {\n  if (Number.isNaN(value)) {\n    // Alternatively, you can choose to return NaN here.\n    // Or do what Lodash does and return 0.\n    // Or take out this check and not provide any explicit NaN handling code.\n    throw new Error('Can not convert NaN to a finite number.');\n  }\n\n  if (value === -Infinity) return -Number.MAX_VALUE;\n  if (value === Infinity) return Number.MAX_VALUE;\n  return value;\n}\n</code></pre>\n<p>The above implementation expects <code>value</code> to be a number. If you expect arguments of other types, then refer to tips in <a href=\"#!/nolodash/toNumber\">the <code>_.toNumber()</code> entry</a> for converting arbitrary values into numbers.</p>","src":null,"test":""},{"name":"toInteger","manifest":{"fnSignature":"_.toInteger(value)","lodashLink":"https://lodash.com/docs/4.17.15#toInteger","summaryHtml":"<p>Converts <code>value</code> to an integer.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">Math.trunc(value)\n</code></pre>\n<p>This does differ from Lodash's implementation in one minor way - <code>_.toInteger(NaN)</code> will return <code>0</code> while <code>Math.trunc(NaN)</code> will return <code>NaN</code>. If you need <code>NaN</code> to convert to <code>0</code>, consider checking if <code>value</code> is <code>NaN</code> using <code>Number.isNaN()</code> before calling <code>Math.trunc()</code>.</p>\n<p>Both <code>Math.trunc()</code> and <code>_.toInteger()</code> will return <code>Infinity</code> and <code>-Infinity</code> as-is, even though these values aren't integers. If you need different behavior, you will need to check for infinity up front (e.g. with <code>!Number.isFinite(value)</code>).</p>\n<p>If <code>value</code> is not a number, you may wish to explicitly convert it into one before-hand instead of relying on <code>Math.trunc()</code> to implicitly convert it for you. You can refer to <a href=\"#!/nolodash/toNumber\">the <code>_.toNumber()</code> entry</a> for tips on converting a string into a number.</p>","src":null,"test":""},{"name":"toLength","manifest":{"fnSignature":"_.toLength(value)","lodashLink":"https://lodash.com/docs/4.17.15#toLength","summaryHtml":"<p>Converts <code>value</code> to an integer suitable for use as the length of an array-like object.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// The maximum array size is the largest 32bit integer (2**32 - 1).\nconst MAX_ARRAY_SIZE = 4294967295;\n\nfunction toLength(value) {\n  if (Number.isNaN(value)) {\n    // Alternatively, you can choose to return NaN here.\n    // Or do what Lodash does and return 0.\n    // Or take out this check and not provide any explicit NaN handling code.\n    throw new Error('Can not convert NaN to a safe integer');\n  }\n\n  if (value &lt; 0) return 0;\n  if (value &gt; MAX_ARRAY_SIZE) return MAX_ARRAY_SIZE;\n  return Math.trunc(value);\n}\n</code></pre>\n<p>The above implementation expects <code>value</code> to be a number. If you expect arguments of other types, then refer to tips in <a href=\"#!/nolodash/toNumber\">the <code>_.toNumber()</code> entry</a> for converting arbitrary values into numbers.</p>","src":null,"test":""},{"name":"toNumber","manifest":{"fnSignature":"_.toNumber(value)","lodashLink":"https://lodash.com/docs/4.17.15#toNumber","summaryHtml":"<p>Converts <code>value</code> to a number.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">Number(value)\n</code></pre>\n<pre><code class=\"javascript language-javascript\">+value\n</code></pre>\n<p>Both <code>Number()</code> and the <code>+</code> unary operator behave the exact same, so either can be chosen. These can be used to convert a variety of different values, including bigint, booleans, strings, etc.</p>\n<p>If you are converting a string to a number, you will likely want to additionally compare your string against a regular expression to make sure it is in the format you expect it to be in. The following are some strings that <code>Number()</code> will happily parse for you, that you may want prevent with your regular expression, depending on your use-case:</p>\n<ul>\n<li>Strings containing numbers with leading and/or trailing spaces (e.g. <code>Number('  23  ') === 23</code>)</li>\n<li>Decimal number (e.g. <code>Number('2.3') === 2.3</code> or <code>Number('2.3E+5') === 2.3E+5</code>)</li>\n<li>Scientific notation (e.g. <code>Number('2e3') === 2e3</code>)</li>\n<li>Numbers in different basis (e.g. <code>Number('0x2a') === 0x2a</code>, <code>Number('0o47') === 0o47</code>, or <code>Number('0b101') === 0b101</code>)</li>\n<li>Empty strings and white-space-only strings (e.g. <code>Number(' \\t \\n ') === 0</code>)</li>\n<li>Numbers with a sign (e.g. <code>Number('-2') === -2</code> or <code>Number('+2') === +2</code>)</li>\n<li>Infinity and -Infinity (e.g. <code>Number('-Infinity') === -Infinity</code>)</li>\n<li>Leading zeros (e.g. <code>Number('012') === 12</code>)</li>\n</ul>\n<p>As a concrete example, if you are receiving user input, and you only want to allow integer inputs (and you are ok with leading zeros), you can use a function like the following to get your desired behavior:</p>\n<pre><code class=\"javascript language-javascript\">function parseUserInput(value) {\n  // Ensures the string only contains digits and nothing else.\n  if (!value.match(/^\\d+$/)) {\n    throw new Error('Invalid user input');\n  }\n\n  const parsedValue = Number(value);\n\n  if (Number.isNaN(parsedValue)) {\n    throw new Error('Invalid user input');\n  }\n\n  return parsedValue;\n}\n</code></pre>\n<h2>What about parseInt() and parseFloat()?</h2>\n<p>You are welcome to use either of these functions as well for string-to-number conversions. These two functions follow their own different algorithms for parsing numbers that may or may not align with what you need. One unfortunate design decision to be aware of with these functions is the fact that as soon as they come across an invalid character, instead of returning an error value (<code>NaN</code>), they just parse what they can and return a number. This means, for example, <code>parseInt('2e7')</code> will unintuitively return the number <code>2</code>, because it doesn't know how to parse the <code>e</code>. All this really means is that it is even more important to use some up-front checking with a regular expression to ensure your string is formatted the way you would expect before handing the string off to <code>parseInt()</code> or <code>parseFloat()</code> to parse. It is also for this reason that I prefer using <code>Number()</code> over <code>parseInt()</code>/<code>parseFloat()</code> - <code>Number()</code> is less likely to surprise you with an unexpected result.</p>","src":null,"test":""},{"name":"toSafeInteger","manifest":{"fnSignature":"_.toSafeInteger(value)","lodashLink":"https://lodash.com/docs/4.17.15#toSafeInteger","summaryHtml":"<p>Converts <code>value</code> to a safe integer. A safe integer can be compared and represented correctly.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function toSafeInteger(value) {\n  if (Number.isNaN(value)) {\n    // Alternatively, you can choose to return NaN here.\n    // Or do what Lodash does and return 0.\n    // Or take out this check and not provide any explicit NaN handling code.\n    throw new Error('Can not convert NaN to a safe integer');\n  }\n\n  if (value &lt; Number.MIN_SAFE_INTEGER) return Number.MIN_SAFE_INTEGER;\n  if (value &gt; Number.MAX_SAFE_INTEGER) return Number.MAX_SAFE_INTEGER;\n  return Math.trunc(value);\n}\n</code></pre>\n<p>The above implementation expects <code>value</code> to be a number. If you expect arguments of other types, then refer to tips in <a href=\"#!/nolodash/toNumber\">the <code>_.toNumber()</code> entry</a> for converting arbitrary values into numbers.</p>","src":null,"test":""}]},{"categoryHeading":"Math","entries":[{"name":"add","manifest":{"fnSignature":"_.add(augend, addend)","lodashLink":"https://lodash.com/docs/4.17.15#add","summaryHtml":"<p>Adds two numbers.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">augend + addend;\n</code></pre>\n<p>One reason <code>_.add()</code> exists, is because it's a ready-made function, that can easily be passed into other functions, like this:</p>\n<pre><code>_.reduce([2, 3, 4], _.add);\n// =&gt; 9\n</code></pre>\n<p>When Lodash was first born, the only alternative at the time would be to create an entire function, using the <code>function</code> keyword.</p>\n<pre><code class=\"javascript language-javascript\">_.reduce([2, 3, 4], function (a, b) {\n  return a + b;\n});\n</code></pre>\n<p>Since then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.</p>\n<pre><code class=\"javascript language-javascript\">_.reduce([2, 3, 4], (a, b) =&gt; a + b);\n</code></pre>","src":null,"test":""},{"name":"ceil","manifest":{"fnSignature":"_.ceil(number, precision?)","lodashLink":"https://lodash.com/docs/4.17.15#ceil","summaryHtml":"<p>Computes <code>number</code> rounded up to <code>precision</code>.</p>"},"descriptionHtml":"<p>If you don't need to use the optional precision argument, then you can simply use the following:</p>\n<pre><code class=\"javascript language-javascript\">Math.ceil(number);\n</code></pre>\n<p>Otherwise:</p>\n<pre><code class=\"javascript language-javascript\">function ceil(number, precision = 0) {\n  const factor = 10 ** precision;\n  return Math.ceil(number * factor) / factor;\n}\n</code></pre>","src":null,"test":""},{"name":"divide","manifest":{"fnSignature":"_.divide(dividend, divisor)","lodashLink":"https://lodash.com/docs/4.17.15#divide","summaryHtml":"<p>Divide two numbers.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">augend / addend;\n</code></pre>\n<p>One reason <code>_.divide()</code> exists, is because it's a ready-made function, that can easily be passed into other functions, like this:</p>\n<pre><code class=\"javascript language-javascript\">_.reduce([100, 2, 5], _.divide); // =&gt; 10\n</code></pre>\n<p>When Lodash was first born, the only alternative at the time would be to create an entire function, using the <code>function</code> keyword.</p>\n<pre><code class=\"javascript language-javascript\">_.reduce([100, 2, 5], function (a, b) {\n  return a / b;\n});\n</code></pre>\n<p>Since then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.</p>\n<pre><code class=\"javascript language-javascript\">_.reduce([100, 2, 5], (a, b) =&gt; a / b);\n</code></pre>","src":null,"test":""},{"name":"floor","manifest":{"fnSignature":"_.floor(number, precision?)","lodashLink":"https://lodash.com/docs/4.17.15#floor","summaryHtml":"<p>Computes <code>number</code> rounded down to <code>precision</code>.</p>"},"descriptionHtml":"<p>If you don't need to use the optional precision argument, then you can simply use the following:</p>\n<pre><code class=\"javascript language-javascript\">Math.floor(number);\n</code></pre>\n<p>Otherwise:</p>\n<pre><code class=\"javascript language-javascript\">function floor(number, precision = 0) {\n  const factor = 10 ** precision;\n  return Math.floor(number * factor) / factor;\n}\n</code></pre>","src":null,"test":""},{"name":"max","manifest":{"fnSignature":"_.max(array)","lodashLink":"https://lodash.com/docs/4.17.15#max","summaryHtml":"<p>Computes the maximum value of array. If array is empty or falsey, undefined is returned.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">Math.max(...array)\n</code></pre>\n<p>There's a couple of very minor differences in behavior between Lodash's <code>_.max()</code>, and JavaScript's native <code>Math.max()</code> (apart from the fact that you have to spread your array into JavaScript's version).</p>\n<ol>\n<li><p>In Lodash's version, if you provide a falsey value, <code>undefined</code> will be returned. In JavaScript, if you try to spread a falsey value into <code>Math.max()</code>, you'll get a runtime error, because falsey values aren't iterable. In practice, this difference shouldn't matter much - you should know the types of values you're trying to use, and if you suspect that it might be falsey, just check for that before calling <code>Math.max()</code>, instead of checking if the result is undefined after calling <code>_.max()</code>.</p></li>\n<li><p>In Lodash's version, if you provide an empty array, <code>undefined</code> is returned. In JavaScript, if you spread an empty array, or you provide no arguments, <code>-Infinity</code> is returned. JavaScript's <code>-Infinity</code>, while, at first, may sound odd, can actually be a useful return value. It allows you to cleanly write many algorithms capable of operating on empty arrays, without having to explicitly check if the array is empty. Not everyone likes to write algorithms this way, but <code>Math.max()</code> gives you the option when it's wanted.</p></li>\n</ol>","src":null,"test":""},{"name":"maxBy","manifest":{"fnSignature":"_.maxBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#maxBy","summaryHtml":"<p>This method is like <code>_.max</code> except that it accepts <code>iteratee</code> which is invoked for each element in <code>array</code> to generate the criterion by which the value is ranked.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function maxBy(array, iteratee) {\n  if (array.length === 0) {\n    return undefined;\n  }\n\n  return array\n    .map(value =&gt; ({ value, score: iteratee(value) }))\n    .reduce((best, cur) =&gt; cur.score &gt; best.score ? cur : best)\n    .value;\n}\n</code></pre>","src":null,"test":""},{"name":"mean","manifest":{"fnSignature":"_.mean(array)","lodashLink":"https://lodash.com/docs/4.17.15#mean","summaryHtml":"<p>Computes the mean of the values in array.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function mean(array) {\n  return array.reduce((a, b) =&gt; a + b) / array.length;\n}\n</code></pre>\n<p>There is an upcoming JavaScript proposal to add <a href=\"https://github.com/tc39/proposal-math-sum\">a native sum method</a> to the language. Once available, you'd be able to simply do this:</p>\n<pre><code class=\"javascript language-javascript\">Math.sumPrecise(array) / array.length\n</code></pre>","src":null,"test":""},{"name":"meanBy","manifest":{"fnSignature":"_.meanBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#meanBy","summaryHtml":"<p>This method is like <code>_.mean</code> except that it accepts <code>iteratee</code> which is invoked for each element in <code>array</code> to generate the value to be averaged.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function mean(array) {\n  // Or use `Math.sumPrecise(array) / array.length` once sumPrecise() is widely available\n  return array.reduce((a, b) =&gt; a + b) / array.length;\n}\n\n// Uses `iteratee` on each element of the array, to convert them to\n// new values, before taking the mean.\nmean(array.map(iteratee));\n</code></pre>\n<p>Refer to <a href=\"#!/nolodash/mean\">mean()'s page</a> for more information on its implementation.</p>","src":null,"test":""},{"name":"min","manifest":{"fnSignature":"_.min(array)","lodashLink":"https://lodash.com/docs/4.17.15#min","summaryHtml":"<p>Computes the minimum value of <code>array</code>. If <code>array</code> is empty or falsey, <code>undefined</code> is returned.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">Math.min(...array)\n</code></pre>\n<p>There's a couple of very minor differences in behavior between Lodash's <code>_.min()</code>, and JavaScript's native <code>Math.min()</code> (apart from the fact that you have to spread your array into JavaScript's version).</p>\n<ol>\n<li><p>In Lodash's version, if you provide a falsey value, <code>undefined</code> will be returned. In JavaScript, if you try to spread a falsey value into <code>Math.min()</code>, you'll get a runtime error, because falsey values aren't iterable. In practice, this difference shouldn't matter much - you should know the types of values you're trying to use, and if you suspect that it might be falsey, just check for that before calling <code>Math.min()</code>, instead of checking if the result is undefined after calling <code>_.min()</code>.</p></li>\n<li><p>In Lodash's version, if you provide an empty array, <code>undefined</code> is returned. In JavaScript, if you spread an empty array, or you provide no arguments, <code>Infinity</code> is returned. JavaScript's <code>Infinity</code>, while, at first, may sound odd, can actually be a useful return value. It allows you to cleanly write many algorithms capable of operating on empty arrays, without having to explicitly check if the array is empty. Not everyone likes to write algorithms this way, but <code>Math.min()</code> gives you the option when it's wanted.</p></li>\n</ol>","src":null,"test":""},{"name":"minBy","manifest":{"fnSignature":"_.minBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#minBy","summaryHtml":"<p>This method is like <code>_.min</code> except that it accepts <code>iteratee</code> which is invoked for each element in <code>array</code> to generate the criterion by which the value is ranked.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function minBy(array, iteratee) {\n  if (array.length === 0) {\n    return undefined;\n  }\n\n  return array\n    .map(value =&gt; ({ value, score: iteratee(value) }))\n    .reduce((best, cur) =&gt; cur.score &lt; best.score ? cur : best)\n    .value;\n}\n</code></pre>","src":null,"test":""},{"name":"multiply","manifest":{"fnSignature":"_.multiply(multiplier, multiplicand)","lodashLink":"https://lodash.com/docs/4.17.15#multiply","summaryHtml":"<p>Multiply two numbers.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">multiplier * multiplicand;\n</code></pre>\n<p>One reason <code>_.multiply()</code> exists, is because it's a ready-made function, that can easily be passed into other functions, like this:</p>\n<pre><code class=\"javascript language-javascript\">_.reduce([2, 3, 4], _.multiply)\n// =&gt; 24\n</code></pre>\n<p>When Lodash was first born, the only alternative at the time would be to create an entire function, using the <code>function</code> keyword.</p>\n<pre><code class=\"javascript language-javascript\">_.reduce([2, 3, 4], function (a, b) {\n  return a * b;\n})\n</code></pre>\n<p>Since then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.</p>\n<pre><code class=\"javascript language-javascript\">_.reduce([2, 3, 4], (a, b) =&gt; a * b)\n</code></pre>","src":null,"test":""},{"name":"round","manifest":{"fnSignature":"_.round(number, precision?)","lodashLink":"https://lodash.com/docs/4.17.15#round","summaryHtml":"<p>Computes <code>number</code> rounded to <code>precision</code>.</p>"},"descriptionHtml":"<p>If you don't need to use the optional precision argument, then you can simply use the following:</p>\n<pre><code class=\"javascript language-javascript\">Math.round(number);\n</code></pre>\n<p>Otherwise:</p>\n<pre><code class=\"javascript language-javascript\">function round(number, precision = 0) {\n  const factor = 10 ** precision;\n  return Math.round(number * factor) / factor;\n}\n</code></pre>","src":null,"test":""},{"name":"subtract","manifest":{"fnSignature":"_.subtract(minuend, subtrahend)","lodashLink":"https://lodash.com/docs/4.17.15#subtract","summaryHtml":"<p>Subtract two numbers.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">minuend - subtrahend;\n</code></pre>\n<p>One reason <code>_.subtract()</code> exists, is because it's a ready-made function, that can easily be passed into other functions, like this:</p>\n<pre><code class=\"javascript language-javascript\">_.reduce([10, 3, 4], _.subtract);\n// =&gt; 3\n</code></pre>\n<p>When Lodash was first born, the only alternative at the time would be to create an entire function, using the <code>function</code> keyword.</p>\n<pre><code class=\"javascript language-javascript\">_.reduce([10, 3, 4], function (a, b) {\n  return a - b;\n});\n</code></pre>\n<p>Since then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.</p>\n<pre><code class=\"javascript language-javascript\">_.reduce([10, 3, 4], (a, b) =&gt; a - b);\n</code></pre>","src":null,"test":""},{"name":"sum","manifest":{"fnSignature":"_.sum(array)","lodashLink":"https://lodash.com/docs/4.17.15#sum","summaryHtml":"<p>Computes the sum of the values in <code>array</code>.</p>"},"descriptionHtml":"<p>If you want an empty array to throw an error:</p>\n<pre><code class=\"javascript language-javascript\">array.reduce((a, b) =&gt; a + b)\n</code></pre>\n<p>If you want an empty array to cause <code>0</code> to be returned:</p>\n<pre><code class=\"javascript language-javascript\">array.reduce((a, b) =&gt; a + b, 0)\n</code></pre>\n<p>There is an upcoming JavaScript proposal to add <a href=\"https://github.com/tc39/proposal-math-sum\">a native sum method</a> to the language. Once available, you'd be able to simply do this:</p>\n<pre><code class=\"javascript language-javascript\">Math.sumPrecise([1, 2, 3]) // =&gt; 6\n</code></pre>","src":null,"test":""},{"name":"sumBy","manifest":{"fnSignature":"_.sumBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#sumBy","summaryHtml":"<p>This method is like <code>_.sum</code> except that it accepts <code>iteratee</code> which is invoked for each element in <code>array</code> to generate the value to be summed.</p>"},"descriptionHtml":"<p>Simply map over your array with <code>iteratee</code>, before trying to sum it:</p>\n<pre><code class=\"javascript language-javascript\">array\n  .map(iteratee)\n  .reduce((a, b) =&gt; a + b);\n</code></pre>","src":null,"test":""}]},{"categoryHeading":"Number","entries":[{"name":"clamp","manifest":{"fnSignature":"_.clamp(number, lower?, upper)","lodashLink":"https://lodash.com/docs/4.17.15#clamp","summaryHtml":"<p>Clamps number within the inclusive <code>lower</code> and <code>upper</code> bounds.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">Math.max(Math.min(number, upper), lower);\n</code></pre>","src":null,"test":""},{"name":"inRange","manifest":{"fnSignature":"_.inRange(number, start?, end)","lodashLink":"https://lodash.com/docs/4.17.15#clamp","summaryHtml":"<p>Checks if <code>n</code> is between <code>start</code> and up to, but not including, <code>end</code>. If <code>start</code> is greater than <code>end</code> the params are swapped to support negative ranges.</p>"},"descriptionHtml":"<p>To simply check if a number is between two others, use the following:</p>\n<pre><code class=\"javascript language-javascript\">start &lt;= number &amp;&amp; number &lt; end\n</code></pre>\n<p>If you're uncertain which of the two numbers are lower, use the following:</p>\n<pre><code class=\"javascript language-javascript\">function inRange(number, start, end) {\n  const bounds = start &lt; end\n    ? [start, end]\n    : [end, start];\n\n  return bounds[0] &lt;= number &amp;&amp; number &lt; bounds[1];\n}\n</code></pre>","src":null,"test":""},{"name":"random","manifest":{"fnSignature":"_.random(lower?, upper?, floating?)","lodashLink":"https://lodash.com/docs/4.17.15#random","summaryHtml":"<p>Produces a random number between the inclusive <code>lower</code> and <code>upper</code> bounds. If <code>floating</code> is true, or either <code>lower</code> or <code>upper</code> are floats, a floating-point number is returned instead of an integer.</p>"},"descriptionHtml":"<h2>For random floats</h2>\n<p>If you want a random float between 0 and <code>upper</code>:</p>\n<pre><code class=\"javascript language-javascript\">Math.random() * upper;\n</code></pre>\n<p>If you want a random float between <code>lower</code> and <code>upper</code>:</p>\n<pre><code class=\"javascript language-javascript\">lower + Math.random() * (upper - lower);\n</code></pre>\n<h2>For random integers</h2>\n<p>All of these examples will treat <code>upper</code> as exclusive, not inclusive. If you want it to be inclusive like it is in Lodash (i.e. you want it to be possible for the upper bound to be returned), add one to <code>upper</code>.</p>\n<p>If you want a random integer between 0 and <code>upper</code>:</p>\n<pre><code class=\"javascript language-javascript\">Math.floor(Math.random() * upper);\n</code></pre>\n<p>If you want a random integer between lower and upper:</p>\n<pre><code class=\"javascript language-javascript\">lower + Math.floor(Math.random() * (upper - lower));\n</code></pre>","src":null,"test":""}]},{"categoryHeading":"Object","entries":[{"name":"assign","manifest":{"fnSignature":"_.assign(object, ...sources)","lodashLink":"https://lodash.com/docs/4.17.15#assign","summaryHtml":"<p>Assigns own enumerable string keyed properties of source objects to the destination object.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">Object.assign(object, sourceObj1, sourceObj2);\n</code></pre>\n<p>Or, if all you want to do is merge objects together, and you don't wish to mutate anything, you can use the spread syntax.</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">{ ...sourceObj1, ...sourceObj2 };\n</code></pre>","src":null,"test":""},{"name":"assignIn","manifest":{"fnSignature":"_.assignIn(object, ...sources)","lodashLink":"https://lodash.com/docs/4.17.15#assignIn","summaryHtml":"<p>This method is like <code>_.assign</code> except that it iterates over own and inherited source properties.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function assignIn(object, ...sources) {\n  for (const source of sources) {\n    for (const key in source) {\n      object[key] = source[key];\n    }\n  }\n\n  return object;\n}\n</code></pre>\n<p>It's very likely that you don't actually need this function. The only way this function is different from <code>_.assign()</code> (or <code>Object.assign()</code>), is that it'll also copy over non-enumerable inherited fields. But</p>\n<ol>\n<li>Class syntax will automatically make all methods on the prototype chain non-enumerable, which means the <code>assignIn()</code> function won't copy them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.</li>\n<li>Why are you even trying to copy both the data and the inherited methods off of an object? If you want one object to share the same methods as another object, consider using normal inheritance.</li>\n</ol>\n<p>Perhaps there's some niche use-cases for this sort of function that arise from fairly abnormal and tricky uses of the JavaScript prototype, but, for day-to-day development, it's best to stay away from this function. If you just want to copy data over from one object to another, please look at <code>_.assign()</code> instead.</p>","src":null,"test":""},{"name":"assignInWith","manifest":{"fnSignature":"_.assignInWith(object, ...sources, customizer)","lodashLink":"https://lodash.com/docs/4.17.15#assignInWith","summaryHtml":"<p>This method is like <code>_.assignIn</code> except that it accepts <code>customizer</code> which is invoked to produce the assigned values. If <code>customizer</code> returns <code>undefined</code>, assignment is handled by the method instead.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function assignInWith(object, sources, customizer) {\n  for (const source of sources) {\n    for (const key in source) {\n      const customizerResult = customizer(object[key], value, key, object, source);\n      object[key] = customizerResult !== undefined ? customizerResult : source[key];\n    }\n  }\n\n  return object;\n}\n</code></pre>\n<p>It's very likely that you don't actually need this function. The only way this function is different from <code>_.assignWith()</code>, is that it'll also copy over non-enumerable inherited fields. But class syntax will automatically make all methods on the prototype chain non-enumerable, which means the <code>assignInWith()</code> function won't copy them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.</p>\n<p>Perhaps there's some niche use-cases for this sort of function that arise from fairly abnormal and tricky uses of the JavaScript prototype, but, for day-to-day development, it's best to stay away from this function. If you just want to copy data over from one object to another with a customizer function (and don't need to worry about inherited fields), please look at the JavaScript equivalent to <code>_.assignWith()</code> instead.</p>","src":null,"test":""},{"name":"assignWith","manifest":{"fnSignature":"_.assignWith(object, ...sources, customizer?)","lodashLink":"https://lodash.com/docs/4.17.15#assignWith","summaryHtml":"<p>This method is like <code>_.assign</code> except that it accepts <code>customizer</code> which is invoked to produce the assigned values. If <code>customizer</code> returns <code>undefined</code>, assignment is handled by the method instead.</p>"},"descriptionHtml":"<p>A complete implementation would look like this:</p>\n<pre><code class=\"javascript language-javascript\">function assignWith(object, sources, customizer) {\n  for (const source of sources) {\n    for (const [key, value] of Object.entries(source)) {\n      const customizerResult = customizer(object[key], value, key, object, source);\n      object[key] = customizerResult !== undefined ? customizerResult : source[key];\n    }\n  }\n\n  return object;\n}\n</code></pre>\n<p>However, it's possible that all you really need to do is map over your source objects before merging them, like this:</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">// Merge your sources together, then map over each entry, updating them as you map over them.\nconst updatedEntries = Object.entries({ ...source1, ...source2, ...source3 })\n  .map(([key, value]) =&gt; [key, ...operate on `value` however you want...]);\n\n// Construct a new object from the mapped entries\nconst updatedSource = Object.fromEntries(updatedEntries);\n\n// If needed, assign the updated entries to `object`, mutating it so it contains this new data.\nObject.assign(object, updatedSource);\n</code></pre>","src":null,"test":""},{"name":"at","manifest":{"fnSignature":"_.at(object, paths?)","lodashLink":"https://lodash.com/docs/4.17.15#at","summaryHtml":"<p>Creates an array of values corresponding to <code>paths</code> of <code>object</code>.</p>"},"descriptionHtml":"<p>We will use a plain JavaScript implementation of <code>_.get()</code> to solve this problem.</p>\n<p>Let's start with <a href=\"#!/nolodash/get\">a plain JavaScript implementation for Lodash's <code>_.get()</code></a>:</p>\n<pre><code class=\"javascript language-javascript\">function get(object, path, defaultValue = undefined) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\"]+/).filter(x =&gt; x);\n  }\n\n  if (path.length === 0) {\n    return object;\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return defaultValue;\n  }\n\n  return get(object[head], tail, defaultValue);\n}\n</code></pre>\n<p>You can achieve the behavior of <code>_.at()</code> by using the above <code>get()</code> function as follows:</p>\n<pre><code class=\"javascript language-javascript\">// Maps over the paths array, fetching each field value from `object` corresponding to that path.\npaths.map(path =&gt; get(object, path))\n</code></pre>\n<p>One of the primary reasons Lodash's <code>_.get()</code> and <code>_.at()</code> functions was commonly used was as a way to easily access a nested property without having to worry about in-between fields being undefined. This is now possible today using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining\">optional chaining</a> (<code>?.</code>) whenever you suspect a property might be undefined, and the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing\">nullish coalescing operator</a> to provide a default value.</p>\n<p>For example, these two are the same:</p>\n<pre><code class=\"javascript language-javascript\">_.at(obj, ['a.b', 'c.d'])\n</code></pre>\n<pre><code class=\"javascript language-javascript\">[obj?.a?.b, obj?.c?.d]\n</code></pre>\n<p>Note that the support for string paths in the above <code>get()</code> implementation isn't very robust. It'll take invalid-looking input, such as <code>\"prop1.[prop2\"</code>, ignore the invalid parts, and attempt to work with it anyways. Lodash's <code>_.get()</code> and <code>_.at()</code> isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.</p>","src":null,"test":""},{"name":"create","manifest":{"fnSignature":"_.create(prototype, properties?)","lodashLink":"https://lodash.com/docs/4.17.15#create","summaryHtml":"<p>Creates an object that inherits from the <code>prototype</code> object. If a <code>properties</code> object is given, its own enumerable string keyed properties are assigned to the created object.</p>"},"descriptionHtml":"<p>If you just need to create an object that inherits from another object:</p>\n<pre><code class=\"javascript language-javascript\">Object.create(prototype)\n</code></pre>\n<p>If you also need to assign some fields to the newly created object, either of these options work:</p>\n<pre><code class=\"javascript language-javascript\">Object.assign(Object.create(prototype), properties);\n\nObject.create(prototype, Object.getOwnPropertyDescriptors(properties));\n</code></pre>","src":null,"test":""},{"name":"defaults","manifest":{"fnSignature":"_.defaults(object, ...sources)","lodashLink":"https://lodash.com/docs/4.17.15#defaults","summaryHtml":"<p>Assigns own and inherited enumerable string keyed properties of source objects to the destination object for all destination properties that resolve to <code>undefined</code>. Source objects are applied from left to right. Once a property is set, additional values of the same property are ignored.</p>"},"descriptionHtml":"<p>There's a handful of different patterns that can be used when you need to apply default values to your object. Each of these methods will handle <code>null</code>, <code>undefined</code>, and absent properties differently.</p>\n<ol>\n<li>Destructuring with defaults</li>\n</ol>\n<p>Defaults will be applied if the properties on <code>object</code> are absent or set to <code>undefined</code>.</p>\n<pre><code class=\"javascript language-javascript\">function addDefaultValues(object) {\n  const {\n    prop1 = 'default 1',\n    prop2 = 'default 2',\n    prop3 = 'default 3',\n  } = object;\n\n  return { prop1, prop2, prop3 };\n}\n</code></pre>\n<ol start=\"2\">\n<li>Using the nullish coalescing operator (<code>??</code>)</li>\n</ol>\n<p>Defaults will be applied if the properties on <code>object</code> are absent, set to <code>undefined</code>, or set to <code>null</code>.</p>\n<pre><code class=\"javascript language-javascript\">const result = {\n  prop1: object.prop1 ?? 'default 1',\n  prop2: object.prop2 ?? 'default 2',\n  prop3: object.prop3 ?? 'default 3',\n};\n</code></pre>\n<ol start=\"3\">\n<li>Spreading a defaults object with your target object</li>\n</ol>\n<p>Defaults will only be applied if the properties on <code>object</code> are absent.</p>\n<pre><code class=\"javascript language-javascript\">const defaults = {\n  prop1: 'default 1',\n  prop2: 'default 2',\n  prop3: 'default 3',\n};\n\n// Note that if you happen to have multiple objects with defaults, you can easily\n// spread them all together here.\nconst result = { ...defaults, ...object };\n</code></pre>\n<p>If you already have an object containing default values, option 3 fits the nicest, but it can't be used as-is if you need the defaults to be applied against <code>undefined</code> and/or <code>null</code> fields. This can be handled by removing <code>undefined</code>/<code>null</code> from <code>object</code> before applying default values, as follows:</p>\n<pre><code class=\"javascript language-javascript\">// The behavior of this function can easily be tweaked if, for example,\n// you also wish to remove `null` fields from an object.\nfunction removeUndefinedProps(object) {\n  const filteredEntries = Object.entries(object)\n    .filter(([key, value]) =&gt; value !== undefined);\n\n  return Object.fromEntries(filteredEntries);\n}\n\nconst result = { ...defaults, ...removeUndefinedProps(object) };\n</code></pre>\n<p>Note that the Lodash implementation would pick both own and inherited properties from the default objects, while this third pattern of spreading objects does not. In practice, this shouldn't matter much because 1. Generally, your default objects won't have inherited fields, and 2. Even if they did, if those inherited fields are set up \"properly\" (i.e. the same way the class syntax automatically does for you), they should also be non-enumerable, and Lodash's <code>_.defaults()</code> does not pick non-enumerable fields from the defaults object.</p>","src":null,"test":""},{"name":"defaultsDeep","manifest":{"fnSignature":"_.defaultsDeep(object, ...sources)","lodashLink":"https://lodash.com/docs/4.17.15#defaultsDeep","summaryHtml":"<p>This method is like <code>_.defaults</code> except that it recursively assigns default properties.</p>"},"descriptionHtml":"<p>There's a handful of different patterns that can be used when you need to apply default values deeply to your object. Each of these methods will handle <code>null</code>, <code>undefined</code>, and absent properties differently.</p>\n<ol>\n<li>Destructuring with defaults</li>\n</ol>\n<p>Defaults will be applied if the properties on <code>object</code> are absent or set to <code>undefined</code>.</p>\n<pre><code class=\"javascript language-javascript\">function addDefaultValues(object) {\n  const {\n    prop1 = 'default 1',\n    subObj = {\n      prop2 = 'default 2',\n      prop3 = 'default 3',\n    } = {},\n  } = object;\n\n  return { prop1, subObj: { prop2, prop3 } };\n}\n</code></pre>\n<ol start=\"2\">\n<li>Using the nullish coalescing operator (<code>??</code>)</li>\n</ol>\n<p>Defaults will be applied if the properties on <code>object</code> are absent, set to <code>undefined</code>, or set to <code>null</code>.</p>\n<pre><code class=\"javascript language-javascript\">const result = {\n  prop1: object.prop1 ?? 'default 1',\n  subObj: {\n    prop2: object.subObj?.prop2 ?? 'default 2',\n    prop3: object.subObj?.prop3 ?? 'default 3',\n  },\n};\n</code></pre>\n<ol start=\"3\">\n<li>Spreading a defaults object with your target object</li>\n</ol>\n<p>Defaults will only be applied if the properties on <code>object</code> are absent.</p>\n<pre><code class=\"javascript language-javascript\">const defaults = {\n  prop1: 'default 1',\n};\n\nconst subObjDefault = {\n  prop2: 'default 2',\n  prop3: 'default 3',\n};\n\nconst result = {\n  ...defaults,\n  ...object,\n  subObj: {\n    ...subObjDefaults,\n    ...object.subObj ?? {},\n  },\n};\n</code></pre>\n<p>If you already have an object containing default values, option 3 fits the nicest, but it can't be used as-is if you need the defaults to be applied against <code>undefined</code> and/or <code>null</code> fields. This can be handled by removing <code>undefined</code>/<code>null</code> from <code>object</code> before applying default values, as follows:</p>\n<pre><code class=\"javascript language-javascript\">// The behavior of this function can easily be tweaked if, for example,\n// you also wish to remove `null` fields from an object.\nfunction removeUndefinedProps(object) {\n  const filteredEntries = Object.entries(object)\n    .filter(([key, value]) =&gt; value !== undefined);\n\n  return Object.fromEntries(filteredEntries);\n}\n\nconst result = {\n  ...defaults,\n  ...removeUndefinedProps(object),\n  subObj: {\n    ...subObjDefaults,\n    ...removeUndefinedProps(object.subObj ?? {}),\n  },\n};\n</code></pre>\n<p>Finally, if you don't feel any of these patterns will fit your use-case very well, you can use the following helper function, which mimics <code>_.defaultsDeep()</code>.</p>\n<pre><code class=\"javascript language-javascript\">const isObject = value =&gt; ['object', 'function'].includes(typeof value) &amp;&amp; value !== null;\n\n// NOTE: This mutates `object`.\nfunction defaultsDeep(object, ...sources) {\n  for (const source of sources) {\n    for (const [key, value] of Object.entries(source)) {\n      if (object[key] === undefined) {\n        object[key] = value;\n      } else if (isObject(value) &amp;&amp; isObject(source[key])) {\n        defaultsDeep(object[key], value);\n      }\n    }\n  }\n\n  return object;\n}\n</code></pre>\n<p>Note that the Lodash implementation would pick both own and inherited properties from the default objects, while this third pattern of spreading objects does not. In practice, this shouldn't matter much because 1. Generally, your default objects won't have inherited fields, and 2. Even if they did, if those inherited fields are set up \"properly\" (i.e. the same way the class syntax automatically does for you), they should also be non-enumerable, and Lodash's <code>_.defaultsDeep()</code> does not pick non-enumerable fields from the defaults object.</p>","src":null,"test":""},{"name":"findKey","manifest":{"fnSignature":"_.findKey(object, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#findKey","summaryHtml":"<p>This method is like <code>_.find</code> except that it returns the key of the first element predicate returns truthy for instead of the element itself.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">Object.entries(object)\n  .find(([key, value]) =&gt; predicate(value))?.[0]\n</code></pre>","src":null,"test":""},{"name":"findLastKey","manifest":{"fnSignature":"_.findLastKey(object, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#findLastKey","summaryHtml":"<p>This method is like <code>_.findKey</code> except that it iterates over elements of a collection in the opposite order.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">Object.entries(object)\n  .findLast(([key, value]) =&gt; predicate(value))?.[0]\n</code></pre>\n<p>Please don't actually use this solution.</p>\n<p>Objects are supposed to be treated as unordered collections. Yes, it's technically true that the JavaScript committee has standardized a stable ordering for object properties, but they only did this so your JavaScript programs will run exactly the same, no matter which engine they run on. They don't provide any tools to modify the ordering of an object (like, \"move this property, so that it's second in iteration order, instead of last\"), and the lack of these types of tools exist for a reason - they don't want you to write code that relies on the order, nor does anyone trying to read and understand your code. Conceptually, objects are supposed to be unordered, please treat them that way. Because of this, there's no reason to iterate over an object from the end to the beginning, you should be able to just use <code>_.findKey()</code> instead of <code>_.findLastKey()</code>.</p>","src":null,"test":""},{"name":"forIn","manifest":{"fnSignature":"_.forIn(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#forIn","summaryHtml":"<p>Iterates over own and inherited enumerable string keyed properties of an object and invokes iteratee for each property. Iteratee functions may exit iteration early by explicitly returning <code>false</code>.</p>"},"descriptionHtml":"<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">for (const key in object) {\n  const value = object[key];\n  ...\n}\n</code></pre>\n<p>It's very likely that you don't actually want this behavior. The only way this solution different from the solutions for <code>_.forOwn()</code>, is that it'll also iterate over non-enumerable inherited properties. But</p>\n<ol>\n<li>Class syntax will automatically make all methods on the prototype chain non-enumerable, which means the for-in loop won't iterate over them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.</li>\n<li>It's long been considered a good practice whenever using a for-in loop, to also check if the property you're iterating over is non-inherited, by nesting an <code>if (Object.prototype.hasOwnProperty.call(object, key)) { ... }</code> check into your loop. This was done, among other reasons, to guard against the case where someone may have improperly mutated <code>Object.prototype</code>, and added an enumerable property to it. This <code>for-in</code> + <code>is-own</code> check isn't seen as much in the wild anymore, because the language has since come out with a better way to iterate over non-inherited keys, which is discussed in the <code>_.forOwn()</code> entry.</li>\n</ol>\n<p>For day-to-day development, it's best to stay away from the raw for-in loop. If you just want to iterate over object keys, and don't want to worry about inherited fields, look at <code>_.forOwn()</code> instead.</p>","src":null,"test":""},{"name":"forInRight","manifest":{"fnSignature":"_.forInRight(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#forInRight","summaryHtml":"<p>This method is like <code>_.forIn</code> except that it iterates over properties of <code>object</code> in the opposite order.</p>"},"descriptionHtml":"<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">const keys = [];\nfor (const key in object) {\n  keys.push(key);\n}\nkeys.reverse();\n\nfor (const key of keys) {\n  const value = object[key];\n  ...\n}\n</code></pre>\n<p>Please don't actually use this solution.</p>\n<p>Objects are supposed to be treated as unordered collections. Yes, it's technically true that the JavaScript committee has standardized a stable ordering for object properties, but they only did this so your JavaScript programs will run exactly the same, no matter which engine they run on. They don't provide any tools to modify the ordering of an object (like, \"move this property, so that it's second in iteration order, instead of last\"), and the lack of these types of tools exist for a reason - they don't <em>want</em> you to write code that relies on the order, nor does anyone trying to read and understand your code. Conceptually, objects are supposed to be unordered, please treat them that way. Because of this, there's no reason to iterate over an object from the end to the beginning, you should be able to just use <code>_.forIn()</code> instead of <code>_.forInRight()</code>.</p>\n<p>Except, both <code>_.forIn()</code> and <code>_.forInRight()</code> have another problem.</p>\n<p>It's very likely that you don't actually want to iterate over the enumerable, inherited properties, because:</p>\n<ol>\n<li>Class syntax will automatically make all methods on the prototype chain non-enumerable, which means the for-in loop won't iterate over them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.</li>\n<li>It's long been considered a good practice whenever using a for-in loop, to also check if the property you're iterating over is non-inherited, by nesting an <code>if (Object.prototype.hasOwnProperty.call(object, key)) { ... }</code> check into your loop. This was done, among other reasons, to guard against the case where someone may have improperly mutated <code>Object.prototype</code>, and added an enumerable property to it. This <code>for-in</code> + <code>is-own</code> check isn't seen as much in the wild anymore, because the language has since come out with a better way to iterate over non-inherited keys, which is discussed in the <code>_.forOwn()</code> entry.</li>\n</ol>\n<p>If you just want to iterate over object keys, and don't want to worry about inherited properties or the ordering of keys, look at <code>_.forOwn()</code> instead.</p>","src":null,"test":""},{"name":"forOwn","manifest":{"fnSignature":"_.forOwn(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#forOwn","summaryHtml":"<p>Iterates over own enumerable string keyed properties of an object and invokes <code>iteratee</code> for each property. Iteratee functions may exit iteration early by explicitly returning <code>false</code>.</p>"},"descriptionHtml":"<p>If you wish to iterate over both keys and values:</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">for (const [key, value] of Object.entries(object)) {\n  ...\n}\n</code></pre>\n<p>If, instead, you just want values, you can use <code>Object.values(object)</code>.</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">for (const value of Object.values(object)) {\n  ...\n}\n</code></pre>\n<p>And if you just want keys, you can use <code>Object.keys(object)</code>.</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">for (const key of Object.keys(object)) {\n  ...\n}\n</code></pre>\n<p>You'll find the <code>.forEach()</code> method to be very popular in the JavaScript community as well.</p>\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">Object.entries(object).forEach(([key, value]) =&gt; {\n  ...\n});\n</code></pre>\n<p>Using <code>.forEach()</code> will certainly feel closer to Lodash's <code>_.forOwn()</code>, but it does have a number of drawbacks:</p>\n<ul>\n<li>You can't use <code>break</code> in a <code>.forEach()</code>. (You can mimic <code>continue</code> via an early return).</li>\n<li><code>.forEach()</code> doesn't provide proper support for <code>await</code>. If you need to run tasks in parallel, use <code>await Promise.all(items.map(...))</code>, and if you want to run tasks in a series, you can just use a for-of loop.</li>\n<li><code>.forEach()</code> doesn't work with generators. You can't <code>yield</code> from inside a <code>.forEach()</code>.</li>\n<li><code>.forEach()</code> only works with arrays, and any other collection that happens to implement the <code>.forEach()</code> function. <code>for-of</code> works with all iterators, including strings, the legacy <code>arguments</code> object, your own iterators made via generator functions, etc.</li>\n<li><code>for-of</code> is newer than <code>.forEach()</code> and was intended to be the better version of <code>.forEach()</code>. It's a shame it's still struggling to gain traction.</li>\n</ul>","src":null,"test":""},{"name":"forOwnRight","manifest":{"fnSignature":"_.forOwnRight(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#forOwnRight","summaryHtml":"<p>This method is like <code>_.forOwn</code> except that it iterates over properties of <code>object</code> in the opposite order.</p>"},"descriptionHtml":"<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">for (const [key, value] of Object.entries(object).reverse()) {\n  ...\n}\n</code></pre>\n<p>Please don't actually use this solution.</p>\n<p>Objects are supposed to be treated as unordered collections. Yes, it's technically true that the JavaScript committee has standardized a stable ordering for object properties, but they only did this so your JavaScript programs will run exactly the same, no matter which engine they run on. They don't provide any tools to modify the ordering of an object (like, \"move this property, so that it's second in iteration order, instead of last\"), and the lack of these types of tools exist for a reason - they don't <em>want</em> you to write code that relies on the order, nor does anyone trying to read and understand your code. Conceptually, objects are supposed to be unordered, please treat them that way. Because of this, there's no reason to iterate over an object from the end to the beginning, you should be able to just use <code>_.forOwn()</code> instead of <code>_.forOwnRight()</code>.</p>","src":null,"test":""},{"name":"functions","manifest":{"fnSignature":"_.functions(object)","lodashLink":"https://lodash.com/docs/4.17.15#functions","summaryHtml":"<p>Creates an array of function property names from own enumerable properties of <code>object</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function functions(object) {\n  const result = [];\n  for (const [key, value] of Object.entries(object)) {\n    if (typeof value === 'function') {\n      result.push(key);\n    }\n  }\n\n  return result;\n}\n</code></pre>","src":null,"test":""},{"name":"functionsIn","manifest":{"fnSignature":"_.functionsIn(object)","lodashLink":"https://lodash.com/docs/4.17.15#functionsIn","summaryHtml":"<p>Creates an array of function property names from own and inherited enumerable properties of object.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function functionsIn(object) {\n  const result = [];\n  for (const key in object) {\n    if (typeof object[key] === 'function') {\n      result.push(key);\n    }\n  }\n\n  return result;\n}\n</code></pre>\n<p>It's very likely that you don't actually need this function. The only way this function is different from <code>_.functions()</code>, is that it'll also search for non-enumerable inherited fields. But class syntax will automatically make all methods on the prototype chain non-enumerable, which means the <code>functionsIn()</code> function won't look for them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable, i.e. if the methods were attached to the prototype \"properly\", the <code>functionsIn()</code> implementation wouldn't be able to find anything on there anyways, since they'd all be marked as non-enumerable.</p>\n<p>Perhaps there's some niche use-cases for this sort of function, that arise from using the prototype in abnormal or legacy ways, but, for day-to-day development, it's best to stay away from this function. If you just want to search for non-inherited function names, use <code>_.functions()</code> instead. If you need to get all non-enumerable, inherited method names, first double check how you're designing your program to see if, perhaps, there's a better way to approach the problem, and if not, you can use <code>Object.getOwnPropertyNames()</code> to get non-inherited, non-enumerable properties in combination with manually walking up the prototype chain to achieve your desired effect.</p>","src":null,"test":""},{"name":"get","manifest":{"fnSignature":"_.get(object, path, defaultValue?)","lodashLink":"https://lodash.com/docs/4.17.15#get","summaryHtml":"<p>Gets the value at <code>path</code> of <code>object</code>. If the resolved value is <code>undefined</code>, the <code>defaultValue</code> is returned in its place.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function get(object, path, defaultValue = undefined) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\"]+/).filter(x =&gt; x);\n  }\n\n  if (path.length === 0) {\n    return object;\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return defaultValue;\n  }\n\n  return get(object[head], tail, defaultValue);\n}\n</code></pre>\n<p>One of the primary reasons Lodash's <code>_.get()</code> function was commonly used, was as a way to easily access a nested property without having to worry about in-between fields being undefined. This is now possible today using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining\">optional chaining</a> (<code>?.</code>) whenever you suspect a property might be undefined, and the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing\">nullish coalescing operator</a> to provide a default value.</p>\n<p>For example, these two are effectively the same:</p>\n<pre><code class=\"javascript language-javascript\">_.get(obj, 'a.b', null)\n\nobj?.a?.b ?? null\n</code></pre>\n<p>Note that the support for string paths in the above <code>get()</code> implementation isn't very robust. It'll take invalid-looking input, such as <code>\"prop1.[prop2\"</code>, ignore the invalid parts, and attempt to work with it anyways. Lodash's <code>_.get()</code> isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.</p>","src":null,"test":""},{"name":"has","manifest":{"fnSignature":"_.has(object, path)","lodashLink":"https://lodash.com/docs/4.17.15#has","summaryHtml":"<p>Checks if path is a direct property of object.</p>"},"descriptionHtml":"<p>If you have a simple key, then <code>Object.hasOwn()</code> can be used to check if it's a non-inherited property.</p>\n<pre><code class=\"javascript language-javascript\">Object.hasOwn({}, 'toString') // =&gt; false\nObject.hasOwn({ toString() { return '{}' } }, 'toString') // =&gt; true\n</code></pre>\n<p>If you have an array of path keys you wish to travel down, or perhaps, a string containing nested property access (like <code>x.y.z</code>), use this:</p>\n<pre><code class=\"javascript language-javascript\">function has(object, path) {\n  // Optional nested-property string support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\"]+/).filter(x =&gt; x);\n  }\n\n  const [head, ...tail] = path;\n  if (!Object.hasOwn(object, head)) {\n    return false;\n  }\n\n  if (tail.length === 0) {\n    return true;\n  }\n\n  return has(object[head], tail);\n}\n</code></pre>\n<p>Note that the support for nested string paths in the above <code>has()</code> implementation isn't very robust. It'll take invalid-looking input, such as <code>\"prop1.[prop2\"</code>, ignore the invalid parts, and attempt to work with it anyways. Lodash's <code>_.has()</code> isn't all that different in this regard. If you really need support for nested string paths, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability. Just provide the path you desire as an array instead.</p>\n<p>If you don't have dynamic strings being provided to you, and you don't need to do the \"is-not-inherited\" checks, then you can simply use the <code>in</code> operator with \"optional chaining\" (<code>?.</code>) to check for the existence of a nested property.</p>\n<pre><code class=\"javascript language-javascript\">'z' in (object?.x?.y ?? {})\n</code></pre>\n<p>The <code>?? {}</code> portion of this example is necessary since <code>?.</code> may produce <code>undefined</code>, and executing <code>... in undefined</code> causes an error to be thrown.</p>","src":null,"test":""},{"name":"hasIn","manifest":{"fnSignature":"_.hasIn(object, path)","lodashLink":"https://lodash.com/docs/4.17.15#hasIn","summaryHtml":"<p>Checks if <code>path</code> is a direct or inherited property of <code>object</code>.</p>"},"descriptionHtml":"<p>If you have a simple key, then the <code>in</code> operator can be used to check if the property is found in the object.</p>\n<pre><code class=\"javascript language-javascript\">'x' in { x: 2 }; // true\n'toString' in { x: 2 }; // true - `in` checks for inherited properties as well\n</code></pre>\n<p>If you have an array of path keys you wish to travel down, or perhaps, a string containing nested property access (like <code>x.y.z</code>), use this:</p>\n<pre><code class=\"javascript language-javascript\">function hasIn(object, path) {\n  // Optional nested-property string support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\"]+/).filter(x =&gt; x);\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return false;\n  }\n\n  if (tail.length === 0) {\n    return true;\n  }\n\n  return hasIn(object[head], tail);\n}\n</code></pre>\n<p>One of the primary reasons Lodash's <code>_.hasIn()</code> function was commonly used, was as a way to easily check if a nested property existed, without having to worry about in-between fields being undefined. This is now possible today using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining\">optional chaining</a> (<code>?.</code>) whenever you suspect a property might be undefined.</p>\n<p>For example, these two are the same:</p>\n<pre><code class=\"javascript language-javascript\">_.hasIn(obj, 'a.b.c');\n\n// `... in undefined` causes an error to be thrown, the use of `?? {}`\n// prevents `undefined` from ever appearing on the right-hand side.\n'c' in (obj?.a?.b ?? {});\n</code></pre>\n<p>Note that the support for nested string paths in the above <code>hasIn()</code> implementation isn't very robust. It'll take invalid-looking input, such as <code>\"prop1.[prop2\"</code>, ignore the invalid parts, and attempt to work with it anyways. Lodash's <code>_.hasIn()</code> isn't all that different in this regard. If you really need support for nested string paths, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability. Just provide the path you desire as an array instead.</p>","src":null,"test":""},{"name":"invert","manifest":{"fnSignature":"_.invert(object)","lodashLink":"https://lodash.com/docs/4.17.15#invert","summaryHtml":"<p>Creates an object composed of the inverted keys and values of object. If object contains duplicate values, subsequent values overwrite property assignments of previous values.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function invert(obj) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    newObj[value] = key;\n  }\n  return newObj;\n}\n</code></pre>","src":null,"test":""},{"name":"invertBy","manifest":{"fnSignature":"_.invertBy(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#invertBy","summaryHtml":"<p>This method is like <code>_.invert</code> except that the inverted object is generated from the results of running each element of <code>object</code> thru <code>iteratee</code>. The corresponding inverted value of each inverted key is an array of keys responsible for generating the inverted value.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function invertBy(obj, iteratee = x =&gt; x) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const newValue = iteratee(value);\n    newObj[newValue] ??= [];\n    newObj[newValue].push(key);\n  }\n  return newObj;\n}\n</code></pre>","src":null,"test":""},{"name":"invoke","manifest":{"fnSignature":"_.invoke(object, path, ...args)","lodashLink":"https://lodash.com/docs/4.17.15#invoke","summaryHtml":"<p>Invokes the method at <code>path</code> of <code>object</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function invoke(object, path, ...args) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\"]+/).filter(x =&gt; x);\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return undefined;\n  }\n\n  if (tail.length === 0) {\n    return object[head](...args);\n  }\n\n  return invoke(object[head], tail, ...args);\n}\n</code></pre>\n<p>Be aware that, like Lodash's <code>_.invoke()</code>, the above implementation doesn't do anything to guard against prototype look-ups, for example, <code>invoke({}, 'toString')</code> will work, and will return the string <code>'[object Object]'</code>. To guard against this, use <code>if (!(Object.hasOwn(head, object)))</code> instead of <code>if(!(head in object))</code>.</p>\n<p>One of the primary reasons Lodash's <code>_.invoke()</code> function was commonly used, was as a way to easily invoke a function nested in an object without having to worry about in-between fields being undefined. This is now possible today using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining\">optional chaining</a> (<code>?.</code>) whenever you suspect a property might be undefined.</p>\n<p>For example, these two are effectively the same:</p>\n<pre><code class=\"javascript language-javascript\">_.invoke(obj, 'subObj.fn', 2, 4)\n\nobj?.subObj?.fn?.(2, 4)\n</code></pre>\n<p>Note that the support for string paths in the above <code>invoke()</code> implementation isn't very robust. It'll take invalid-looking input, such as <code>\"prop1.[prop2\"</code>, ignore the invalid parts, and attempt to work with it anyways. Lodash's <code>_.invoke()</code> isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.</p>","src":null,"test":""},{"name":"keys","manifest":{"fnSignature":"_.keys(object)","lodashLink":"https://lodash.com/docs/4.17.15#keys","summaryHtml":"<p>Creates an array of the own enumerable property names of <code>object</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">Object.keys(object)\n</code></pre>","src":null,"test":""},{"name":"keysIn","manifest":{"fnSignature":"_.keysIn(object)","lodashLink":"https://lodash.com/docs/4.17.15#keysIn","summaryHtml":"<p>Creates an array of the own and inherited enumerable property names of <code>object</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function keysIn(object) {\n  const keys = [];\n  for (let key in object) {\n    keys.push(key);\n  }\n\n  return keys;\n}\n</code></pre>\n<p>It's very likely that you don't actually need this function. The only way this function is different from <code>_.keys()</code> (or <code>Object.keys()</code>), is that it'll also grab over non-enumerable inherited keys. But class syntax will automatically make all methods on the prototype chain non-enumerable, which means the <code>keysIn()</code> function won't consider those inherited methods anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.</p>\n<p>Perhaps there's some niche use-cases for this sort of function, that arise from using the prototype in abnormal or legacy ways, but, for day-to-day development, it's best to stay away from this function. If you just want to get the non-inherited keys from an object, use <code>Object.keys(object)</code> instead.</p>","src":null,"test":""},{"name":"mapKeys","manifest":{"fnSignature":"_.mapKeys(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#mapKeys","summaryHtml":"<p>The opposite of <code>_.mapValues</code>; this method creates an object with the same values as <code>object</code> and keys generated by running each own enumerable string keyed property of <code>object</code> thru <code>iteratee</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function mapKeys(obj, iteratee) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const newKey = iteratee(value, key, obj);\n    newObj[newKey] = value;\n  }\n\n  return newObj;\n}\n</code></pre>","src":null,"test":""},{"name":"mapValues","manifest":{"fnSignature":"_.mapValues(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#mapValues","summaryHtml":"<p>Creates an object with the same keys as <code>object</code> and values generated by running each own enumerable string keyed property of <code>object</code> thru <code>iteratee</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function mapValues(obj, iteratee) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    newObj[key] = iteratee(value, key, obj);\n  }\n\n  return newObj;\n}\n</code></pre>","src":null,"test":""},{"name":"merge","manifest":{"fnSignature":"_.merge(object, ...sources)","lodashLink":"https://lodash.com/docs/4.17.15#merge","summaryHtml":"<p>This method is like <code>_.assign</code> except that it recursively merges own and inherited enumerable string keyed properties of source objects into the destination object. Source properties that resolve to <code>undefined</code> are skipped if a destination value exists. Source objects are applied from left to right. Subsequent sources overwrite property assignments of previous sources.</p>"},"descriptionHtml":"<p>If you know the shape of the objects you're wishing to merge, you can just use the spread syntax, like this:</p>\n<pre><code class=\"javascript language-javascript\">const result = {\n  ...object1,\n  ...object2,\n  subObject: {\n    ...object1.subObject,\n    ...object2.subObject,\n  },\n};\n</code></pre>\n<p>Otherwise, the following <code>merge()</code> function can be used to roughly mirror Lodash's <code>_.merge()</code>.</p>\n<pre><code class=\"javascript language-javascript\">const isObject = value =&gt; ['object', 'function'].includes(typeof value) &amp;&amp; value !== null;\n\n// A \"plain\" object is an object who's a direct instance of Object\n// (or, who has a null prototype).\nconst isPlainObject = value =&gt; {\n  if (!isObject(value)) return false;\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n};\n\n// NOTE: This mutates `object`.\n// It also may mutate anything that gets attached to `object` during the merge.\nfunction merge(object, ...sources) {\n  for (const source of sources) {\n    for (const [key, value] of Object.entries(source)) {\n      if (value === undefined) {\n        continue;\n      }\n\n      // These checks are a week attempt at mimicking the various edge-case behaviors\n      // that Lodash's `_.merge()` exhibits. Feel free to simplify and\n      // remove checks that you don't need.\n      if (!isPlainObject(value) &amp;&amp; !Array.isArray(value)) {\n        object[key] = value;\n      } else if (Array.isArray(value) &amp;&amp; !Array.isArray(object[key])) {\n        object[key] = value;\n      } else if (!isObject(object[key])) {\n        object[key] = value;\n      } else {\n        merge(object[key], value);\n      }\n    }\n  }\n\n  return object;\n}\n</code></pre>\n<p>The Lodash implementation would pick both own and inherited properties from the default objects, while this implementation does not. In practice, this shouldn't matter much because 1. Generally, your default objects won't have inherited fields, and 2. Even if they did, if those inherited fields are set up \"properly\" (i.e. the same way the class syntax automatically does for you), they should also be non-enumerable, and Lodash's <code>_.merge()</code> does not pick non-enumerable fields from the defaults object.</p>\n<p>The implementation above also does not support circular references. There's a handful of different ways you could support circular references depending on your needs:</p>\n<ul>\n<li>Don't bother checking for them at all (what the above implementation does)</li>\n<li>Check for them on the source objects and throw an error if you encounter one (another good option)</li>\n<li>When traversing a <code>source</code> object, stop before using a source node that you've seen before (what <code>lodash</code> was probably trying to do).</li>\n<li>When traversing a <code>source</code> object, if you encounter a node in <code>source</code> that you have seen before, merge its immediate properties but do not recurse into it anymore (what <code>lodash</code> does).</li>\n<li>When traversing a <code>source</code> object, stop if you find yourself trying to merge a source node to the same target node a second time. (This is arguably the most correct algorithm)</li>\n</ul>\n<p>In practice, it's not common to need support for circular references, so you will probably be fine just leaving out support or throwing an error if you detect a circular reference.</p>\n<p>If all you want to do is deeply merge some plain objects, and you don't need to worry about odd scenarios, like \"what happens when I merge an array with a number\", or, \"how does a Map instance get merged with a plain object\", then an implementation like this should be sufficient.</p>\n<pre><code class=\"javascript language-javascript\">const isObject = value =&gt; ['object', 'function'].includes(typeof value) &amp;&amp; value !== null;\n\n// NOTE: This mutates `object`.\n// It also may mutate anything that gets attached to `object` during the merge.\nfunction merge(object, ...sources) {\n  if (!isObject(object)) {\n    throw new Error(`Expected ${object} to be an object.`);\n  }\n\n  for (const source of sources) {\n    for (const [key, value] of Object.entries(source)) {\n      if (value === undefined) {\n        continue;\n      }\n\n      if (object[key] === undefined) {\n        object[key] = value;\n      } else {\n        merge(object[key], value);\n      }\n    }\n  }\n\n  return object;\n}\n</code></pre>","src":null,"test":""},{"name":"mergeWith","manifest":{"fnSignature":"_.mergeWith(object, ...sources, customizer)","lodashLink":"https://lodash.com/docs/4.17.15#mergeWith","summaryHtml":"<p>This method is like <code>_.merge</code> except that it accepts <code>customizer</code> which is invoked to produce the merged values of the destination and source properties. If <code>customizer</code> returns <code>undefined</code>, merging is handled by the method instead.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">const isObject = value =&gt; ['object', 'function'].includes(typeof value) &amp;&amp; value !== null;\n\n// A \"plain\" object is an object who's a direct instance of Object\n// (or, who has a null prototype).\nconst isPlainObject = value =&gt; {\n  if (!isObject(value)) return false;\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n};\n\n// NOTE: This mutates `object`.\n// It also may mutate anything that gets attached to `object` during the merge.\nfunction mergeWith(object, sources, customizer) {\n  for (const source of sources) {\n    for (const [key, value] of Object.entries(source)) {\n      const mergedValue = customizer(object[key], value, key, object, source);\n      if (mergedValue !== undefined) {\n        object[key] = mergedValue;\n        continue;\n      }\n      // Otherwise, fall back to default behavior\n\n      if (value === undefined) {\n        continue;\n      }\n\n      // These checks are a week attempt at mimicking the various edge-case behaviors\n      // that Lodash's `_.merge()` exhibits. Feel free to simplify and\n      // remove checks that you don't need.\n      if (!isPlainObject(value) &amp;&amp; !Array.isArray(value)) {\n        object[key] = value;\n      } else if (Array.isArray(value) &amp;&amp; !Array.isArray(object[key])) {\n        object[key] = value;\n      } else if (!isObject(object[key])) {\n        object[key] = value;\n      } else {\n        mergeWith(object[key], value, customizer);\n      }\n    }\n  }\n\n  return object;\n}\n</code></pre>\n<p>Lodash implementation will pick both own and inherited properties from the default objects, while this implementation does not. In practice, this shouldn't matter much because 1. Generally, your default objects won't have inherited fields, and 2. Even if they did, if those inherited fields are set up \"properly\" (i.e. the same way the class syntax automatically does for you), they should also be non-enumerable, and Lodash's <code>_.merge()</code> does not pick non-enumerable fields from the defaults object.</p>\n<p>In Lodash, the customizer function would be called with a sixth \"stack\" argument. Some probing shows that it's an instance of an internal \"Stack\" class that provides some methods which, presumably, can be used to gather information about the objects you're merging. Due to the fact that this seems to be a rather complex feature that's entirely undocumented, it'll be assumed that the vast majority of users do not use this parameter, and so it's functionality won't be recreated here either.</p>\n<p>The implementation above also does not support circular references. There's a handful of different ways you could support circular references depending on your needs:</p>\n<ul>\n<li>Don't bother checking for them at all (what the above implementation does)</li>\n<li>Check for them on the source objects and throw an error if you encounter one (another good option)</li>\n<li>When traversing a <code>source</code> object, stop before using a source node that you've seen before (what <code>lodash</code> was probably trying to do).</li>\n<li>When traversing a <code>source</code> object, if you encounter a node in <code>source</code> that you have seen before, merge its immediate properties but do not recurse into it anymore (what <code>lodash</code> does).</li>\n<li>When traversing a <code>source</code> object, stop if you find yourself trying to merge a source node to the same target node a second time. (This is arguably the most correct algorithm)</li>\n</ul>\n<p>In practice, it's not common to need support for circular references, so you will probably be fine just leaving out support or throwing an error if you detect a circular reference.</p>","src":null,"test":""},{"name":"omit","manifest":{"fnSignature":"_.omit(object, ...paths)","lodashLink":"https://lodash.com/docs/4.17.15#omit","summaryHtml":"<p>This method is like <code>_.merge</code> except that it accepts <code>customizer</code> which is invoked to produce the merged values of the destination and source properties. If <code>customizer</code> returns <code>undefined</code>, merging is handled by the method instead.</p>"},"descriptionHtml":"<p>If the properties you wish to omit are known in advance, you can use destructuring to omit them (possibly putting this in a helper function, to avoid polluting your scope with unnecessary variables).</p>\n<pre><code class=\"javascript language-javascript\">// `partialObject` will contain everything that's in `object`,\n// except, `propA` and `propB` will be omitted.\nconst { propA, propB, ...partialObject } = object;\n</code></pre>\n<p>If you need to also omit nested properties, a similar pattern can still be followed.</p>\n<pre><code class=\"javascript language-javascript\">// omit properties from `object`\nconst { propA, propB, nestedObj, ...partialObject } = object;\n\n// omit properties from `object.nestedObj`\nconst { nestedPropA, ...partialNestedObject } = nestedObj;\n\n// Combine the two partial objects, to build the final result.\nconst result = { ...partialObject, partialNestedObject };\n</code></pre>\n<p>If you don't know the keys you need to remove in advance, the following helper function can be utilized.</p>\n<pre><code class=\"javascript language-javascript\">function omit(object, keys_) {\n  const keys = new Set(keys_);\n  const newObject = {};\n  for (const [key, value] of Object.entries(object)) {\n    if (!keys.has(key)) {\n      newObject[key] = value;\n    }\n  }\n\n  return newObject;\n}\n</code></pre>\n<p>There is an early <a href=\"https://github.com/tc39/proposal-object-pick-or-omit\">Object.omit() proposal</a>, which, if implemented, would provide functionality similar to the above helper function.</p>\n<p>If you need a version of the omit function that can omit nested properties, you can use this:</p>\n<pre><code class=\"javascript language-javascript\">const isObject = value =&gt; ['object', 'function'].includes(typeof value) &amp;&amp; value !== null;\n\nfunction omit(object, keys) {\n  const newObject = Array.isArray(object) ? [...object] : { ...object };\n\n  for (const key of keys) {\n    let keyPath;\n    if (typeof key === 'string') {\n      // Optional string-path support.\n      // You can remove this key.split() stuff, and simply use `keyPath = [key];`\n      // if you don't need it.\n      keyPath = key.split(/[.\\[\\]\"]+/).filter(x =&gt; x);\n    } else if (Array.isArray(key)) {\n      keyPath = key;\n    } else {\n      throw new Error(`Received a key ${key}, which is of an invalid type.`);\n    }\n\n    const [head, ...tail] = keyPath;\n    if (tail.length === 0) {\n      delete newObject[key];\n    } else if (isObject(newObject[head]) || Array.isArray(newObject[head])) {\n      newObject[head] = omit(newObject[head], [tail]);\n    }\n  }\n\n  return newObject;\n}\n</code></pre>\n<p>If you're only passing in a handful of keys at a time, the above implementation should work just fine, but if you think your keys array may become fairly large, you may need to do some work to optimize the above implementation a bit.</p>\n<p>Note that the support for string paths (e.g. keys like <code>key.nestedKey</code>) in the above <code>omit()</code> implementation isn't very robust. It'll take invalid-looking input, such as <code>\"prop1.[prop2\"</code>, ignore the invalid parts, and attempt to work with it anyways. Lodash's <code>_.omit()</code> isn't all that different in this regard. If you really need support for string-path inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability.</p>\n<p>Note that none of these implementations will actually copy non-enumerable properties from the prototype chain like Lodash's <code>_.omit()</code>. It's very likely that you don't actually want this kind of behavior anyways. Generally, all properties found on the prototype chain should be marked as enumerable (this is the default for class syntax) - this is standard practice, and there's really no reason to create a prototype with non-enumerable properties, with the possible exception of dealing with classes that were created before the class syntax came out, where the authors didn't want to put in the work of manually marking each method on the prototype as non-enumerable (it wasn't a common thing to do back in the day, even if it would have technically been more proper).</p>","src":null,"test":""},{"name":"omitBy","manifest":{"fnSignature":"_.omitBy(object, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#omitBy","summaryHtml":"<p>The opposite of <code>_.pickBy</code>; this method creates an object composed of the own and inherited enumerable string keyed properties of <code>object</code> that <code>predicate</code> doesn't return truthy for.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function omitBy(object, predicate) {\n  const newObject = {};\n  for (const [key, value] of Object.entries(object)) {\n    if (!predicate(value, key)) {\n      newObject[key] = value;\n    }\n  }\n\n  return newObject;\n}\n</code></pre>\n<p><code>_.omitBy(object, x =&gt; &lt;condition&gt;)</code> is exactly the same as <code>_.pickBy(object, x =&gt; !&lt;condition&gt;)</code>. This means, you only really need one of these helper functions, not both.</p>\n<p>There is also an early <a href=\"https://github.com/tc39/proposal-object-pick-or-omit\">Object.omit() proposal</a>, which, if implemented, would provide functionality similar to the above helper function.</p>\n<p>Note that this implementation will not actually copy non-enumerable properties from the prototype chain like Lodash's <code>_.omitBy()</code>. It's very likely that you don't actually want this kind of behavior anyways. Generally, all properties found on the prototype chain should be marked as enumerable (this is the default for class syntax) - this is standard practice, and there's really no reason to create a prototype with non-enumerable properties, with the possible exception of dealing with classes that were created before the class syntax came out, where the authors didn't want to put in the work of manually marking each method on the prototype as non-enumerable (it wasn't a common thing to do back in the day, even if it would have technically been more proper).</p>","src":null,"test":""},{"name":"pick","manifest":{"fnSignature":"_.pick(object, ...paths)","lodashLink":"https://lodash.com/docs/4.17.15#pick","summaryHtml":"<p>Creates an object composed of the picked <code>object</code> properties.</p>"},"descriptionHtml":"<p>If the properties you wish to pick are known in advance, you can use destructuring to pick them (possibly putting this in a helper function, to avoid polluting your scope with unnecessary variables).</p>\n<pre><code class=\"javascript language-javascript\">const { propA, propB } = object;\nconst newObject = { propA, propB };\n</code></pre>\n<p>If you need to also omit nested properties, a similar pattern can still be followed.</p>\n<pre><code class=\"javascript language-javascript\">// omit properties from `object`\nconst { propA, propB, nestedObj, ...partialObject } = object;\n\n// omit properties from `object.nestedObj`\nconst { nestedPropA, ...partialNestedObject } = nestedObj;\n\n// Combine the two partial objects, to build the final result.\nconst result = { ...partialObject, partialNestedObject };\n</code></pre>\n<p>If you don't know the keys you need to pick in advance, the following helper function can be utilized.</p>\n<pre><code class=\"javascript language-javascript\">function pick(object, keys) {\n  const newObject = {};\n  for (const key of keys) {\n    if (key in object) {\n      if (key in object) {\n        newObject[key] = object[key];\n      }\n    }\n  }\n\n  return newObject;\n}\n</code></pre>\n<p>There is an early <a href=\"https://github.com/tc39/proposal-object-pick-or-omit\">Object.pick() proposal</a>, which, if implemented, would provide functionality similar to the above helper function.</p>\n<p>If you need a version of the pick function that can pick nested properties, you can use this:</p>\n<pre><code class=\"javascript language-javascript\">const isObject = value =&gt; ['object', 'function'].includes(typeof value) &amp;&amp; value !== null;\n\nfunction pick(object, keys) {\n  if (object == null) {\n    return {};\n  }\n  const newObject = {};\n\n  for (const key of keys) {\n    let keyPath;\n    if (typeof key === 'string') {\n      // Optional string-path support.\n      // You can remove this key.split() stuff, and simply use `keyPath = [key];`\n      // if you don't need it.\n      keyPath = key.split(/[.\\[\\]\"]+/).filter(x =&gt; x);\n    } else if (Array.isArray(key)) {\n      keyPath = key;\n    } else {\n      throw new Error(`Received a key ${key}, which is of an invalid type.`);\n    }\n\n    const [head, ...tail] = keyPath;\n    if (!(head in object)) {\n      continue;\n    } else if (tail.length === 0) {\n      newObject[key] = object[key];\n    } else if (isObject(object[head]) || Array.isArray(object[head])) {\n      newObject[head] = {\n        ...newObject[head] ?? {},\n        ...pick(object[head], [tail]),\n      };\n    }\n  }\n\n  return newObject;\n}\n</code></pre>\n<p>If you're only passing in a handful of keys at a time, the above implementation should work just fine, but if you think your keys array may become fairly large, you may need to do some work to optimize the above implementation a bit.</p>\n<p>Note that the support for string paths (e.g. keys like <code>key.nestedKey</code>) in the above <code>pick()</code> implementation isn't very robust. It'll take invalid-looking input, such as <code>\"prop1.[prop2\"</code>, ignore the invalid parts, and attempt to work with it anyways. Lodash's <code>_.pick()</code> isn't all that different in this regard. If you really need support for string-path inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability.</p>\n<p>In all of these implementations, you'll be able to pick own properties and inherited properties. This can lead to issues if you accept arbitrary untrusted user input in your keys array. For example, even though the object passed into <code>pick({}, [untrustedUserInput])</code> is empty, you can still pick inherited methods off of it, e.g. if untrustedUserInput is set to <code>'toString'</code>, you'd pick the <code>'toString'</code> method off of the empty object.</p>","src":null,"test":""},{"name":"pickBy","manifest":{"fnSignature":"_.pickBy(object, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#pickBy","summaryHtml":"<p>Creates an object composed of the object properties <code>predicate</code> returns truthy for. </p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function pickBy(object, predicate) {\n  const newObject = {};\n  for (const [key, value] of Object.entries(object)) {\n    if (predicate(value, key)) {\n      newObject[key] = value;\n    }\n  }\n\n  return newObject;\n}\n</code></pre>\n<p>There is also an early <a href=\"https://github.com/tc39/proposal-object-pick-or-omit\">Object.pick() proposal</a>, which, if implemented, would provide functionality similar to the above helper function.</p>\n<p>Note that this implementation will not actually copy non-enumerable properties from the prototype chain like Lodash's <code>_.pickBy()</code>. It's very likely that you don't actually want this kind of behavior anyways. Generally, all properties found on the prototype chain should be marked as enumerable (this is the default for class syntax) - this is standard practice, and there's really no reason to create a prototype with non-enumerable properties, with the possible exception of dealing with classes that were created before the class syntax came out, where the authors didn't want to put in the work of manually marking each method on the prototype as non-enumerable (it wasn't a common thing to do back in the day, even if it would have technically been more proper).</p>","src":null,"test":""},{"name":"result","manifest":{"fnSignature":"_.result(object, path, defaultValue?)","lodashLink":"https://lodash.com/docs/4.17.15#result","summaryHtml":"<p>This method is like <code>_.get</code> except that if the resolved value is a function it's invoked with the <code>this</code> binding of its parent object and its result is returned.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function result(object, path, defaultValue = undefined) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\"]+/).filter(x =&gt; x);\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return defaultValue;\n  }\n\n  if (tail.length === 0) {\n    return object[head]();\n  }\n\n  return result(object[head], tail, defaultValue);\n}\n</code></pre>\n<p>One of the primary reasons Lodash's <code>_.result()</code> function was commonly used, was as a way to easily invoke a function nested in an object without having to worry about in-between fields being undefined. This is now possible today using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining\">optional chaining</a> (<code>?.</code>) whenever you suspect a property might be undefined, and the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing\">nullish coalescing operator</a> to provide a default value.</p>\n<p>For example, these two are effectively the same:</p>\n<pre><code class=\"javascript language-javascript\">_.result(obj, 'subObj.fn', 'fallback');\n\nobj?.subObj?.fn?.() ?? 'fallback';\n</code></pre>\n<p>Note that the support for string paths in the above <code>result()</code> implementation isn't very robust. It'll take invalid-looking input, such as <code>\"prop1.[prop2\"</code>, ignore the invalid parts, and attempt to work with it anyways. Lodash's <code>_.result()</code> isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.</p>","src":null,"test":""},{"name":"set","manifest":{"fnSignature":"_.set(object, path, value)","lodashLink":"https://lodash.com/docs/4.17.15#set","summaryHtml":"<p>Sets the value at <code>path</code> of <code>object</code>. If a portion of <code>path</code> doesn't exist, it's created. Arrays are created for missing index properties while objects are created for all other missing properties.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function set(object, path, value) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str =&gt; str[0] === '\"' &amp;&amp; str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x =&gt; x)\n      .map(x =&gt; !isNaN(Number(x)) ? Number(x) : x)\n      .map(x =&gt; typeof x === 'string' &amp;&amp; isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = value;\n    return object;\n  }\n\n  if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  set(object[head], tail, value);\n  return object;\n}\n</code></pre>\n<p>One of the primary reasons Lodash's <code>_.set()</code> function was commonly used, was as a way to easily update a nested property without having to worry about in-between fields being undefined. This is now possible today using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining\">optional chaining</a> (<code>?.</code>) whenever you suspect a property might be undefined.</p>\n<p>For example, these two accomplish the same objective:</p>\n<pre><code class=\"javascript language-javascript\">_.set(obj, 'a.b.c', true);\n\nif (obj?.a?.b) {\n  obj.a.b.c = true;\n}\n</code></pre>\n<p>Note that the support for string paths in the above <code>set()</code> implementation isn't very robust. It'll take invalid-looking input, such as <code>\"prop1.[prop2\"</code>, ignore the invalid parts, and attempt to work with it anyways. Lodash's <code>_.set()</code> isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.</p>","src":null,"test":""},{"name":"setWith","manifest":{"fnSignature":"_.setWith(object, path, value, customizer?)","lodashLink":"https://lodash.com/docs/4.17.15#setWith","summaryHtml":"<p>This method is like <code>_.set</code> except that it accepts <code>customizer</code> which is invoked to produce the objects of <code>path</code>. If <code>customizer</code> returns <code>undefined</code> path creation is handled by the method instead.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function setWith(object, path, value, customizer) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str =&gt; str[0] === '\"' &amp;&amp; str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x =&gt; x)\n      .map(x =&gt; !isNaN(Number(x)) ? Number(x) : x)\n      .map(x =&gt; typeof x === 'string' &amp;&amp; isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = value;\n    return object;\n  }\n\n  let pathSegment = customizer(object[head], head, object);\n\n  if (pathSegment !== undefined) {\n    object[head] = pathSegment;\n  } else if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  setWith(object[head], tail, value, customizer);\n  return object;\n}\n</code></pre>\n<p>Note that the support for string paths in the above <code>setWith()</code> implementation isn't very robust. It'll take invalid-looking input, such as <code>\"prop1.[prop2\"</code>, ignore the invalid parts, and attempt to work with it anyways. Lodash's <code>_.setWith()</code> isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability, since you can always provide an array of keys to form a path, instead of a dot-separated string.</p>","src":null,"test":""},{"name":"toPairs","manifest":{"fnSignature":"_.toPairs(object)","lodashLink":"https://lodash.com/docs/4.17.15#toPairs","summaryHtml":"<p>Creates an array of own enumerable string keyed-value pairs for <code>object</code> which can be consumed by <code>_.fromPairs</code>. If object is a map or set, its entries are returned.</p>"},"descriptionHtml":"<p>If you have a normal object, use <code>Object.entries(object)</code>.</p>\n<p>If you have a map, use <code>[...map]</code>.</p>\n<p>And, while it's not all that useful, you can get the contents of a set, formatted in pairs the same way Lodash's <code>_.toPairs()</code> does it, as follows:</p>\n<pre><code class=\"javascript language-javascript\">[...set].map(value =&gt; [value, value])\n</code></pre>","src":null,"test":""},{"name":"toPairsIn","manifest":{"fnSignature":"_.toPairsIn(object)","lodashLink":"https://lodash.com/docs/4.17.15#toPairsIn","summaryHtml":"<p>Creates an array of own and inherited enumerable string keyed-value pairs for <code>object</code> which can be consumed by <code>_.fromPairs</code>. If <code>object</code> is a map or set, its entries are returned.</p>"},"descriptionHtml":"<p>If you have a normal object, the following:</p>\n<pre><code class=\"javascript language-javascript\">function toPairsIn(object) {\n  const pairs = [];\n  for (let key in object) {\n    pairs.push([key, object[key]]);\n  }\n\n  return pairs;\n}\n</code></pre>\n<p>If you have a map, use <code>[...map]</code>.</p>\n<p>And, while it's not all that useful, you can get the contents of a set, formatted in pairs the same way Lodash's <code>_.toPairs()</code> does it, as follows:</p>\n<pre><code class=\"javascript language-javascript\">[...set].map(value =&gt; [value, value])\n</code></pre>\n<p>It's very likely that you don't actually need the above <code>toPairsIn()</code> function. The only way this function is different from <code>_.toPairs()</code> (or <code>Object.entries()</code>), is that it'll also operate on non-enumerable inherited fields. But class syntax will automatically make all methods on the prototype chain non-enumerable, which means the <code>toPairsIn()</code> function won't operate on them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.</p>\n<p>Perhaps there's some niche use-cases for this sort of function that arise from fairly abnormal and tricky uses of the JavaScript prototype, but, for day-to-day development, it's best to stay away from this function. If you just want to get a list of non-inherited pairs (entries), please look at <code>_.toPairs()</code> instead.</p>","src":null,"test":""},{"name":"transform","manifest":{"fnSignature":"_.transform(object)","lodashLink":"https://lodash.com/docs/4.17.15#transform","summaryHtml":"<p>An alternative to <code>_.reduce</code>; this method transforms <code>object</code> to a new <code>accumulator</code> object which is the result of running each of its own enumerable string keyed properties thru <code>iteratee</code>, with each invocation potentially mutating the <code>accumulator</code> object. If <code>accumulator</code> is not provided, a new object with the same <code>[[Prototype]]</code> will be used.</p>"},"descriptionHtml":"<p>Using <code>_.transform()</code> really isn't any different from using the built-in <code>array.reduce()</code> method, except for a couple of minor things.</p>\n<ol>\n<li>If you're dealing with objects, you need to use <code>Object.entries(yourObject)</code> to turn it into an array of tuples first.</li>\n<li>With <code>array.reduce()</code>, you need to always return the accumulator</li>\n</ol>\n<p>Here's what it looks like in practice to convert from a <code>_.transform()</code> call to <code>.reduce()</code>, starting with an example from their website:</p>\n<!-- eslint-disable @stylistic/quote-props-->\n<!-- eslint-disable @stylistic/space-before-function-paren -->\n<pre><code class=\"javascript language-javascript\">_.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n  (result[value] || (result[value] = [])).push(key);\n}, {});\n// =&gt; { '1': ['a', 'c'], '2': ['b'] }\n\n// Note the use of `Object.entries()` (point 1) here.\nObject.entries({ 'a': 1, 'b': 2, 'c': 1 }).reduce((result, [key, value]) =&gt; {\n  (result[value] || (result[value] = [])).push(key);\n  return result; // Note how we return the accumulator (point 2) here.\n}, {});\n</code></pre>\n<p>A simple for loop will work just as well, if that's your preference.</p>\n<!-- eslint-disable @stylistic/quote-props -->\n<pre><code class=\"javascript language-javascript\">const result = {};\nfor (const [key, value] of Object.entries({ 'a': 1, 'b': 2, 'c': 1 })) {\n  (result[value] || (result[value] = [])).push(key);\n}\n</code></pre>","src":null,"test":""},{"name":"unset","manifest":{"fnSignature":"_.unset(object, path)","lodashLink":"https://lodash.com/docs/4.17.15#unset","summaryHtml":"<p>Removes the property at <code>path</code> of <code>object</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function unset(object, path) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str =&gt; str[0] === '\"' &amp;&amp; str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x =&gt; x)\n      .map(x =&gt; !isNaN(Number(x)) ? Number(x) : x)\n      .map(x =&gt; typeof x === 'string' &amp;&amp; isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    delete object[head];\n  } else if (head in object) {\n    unset(object[head], tail);\n  }\n\n  return object;\n}\n</code></pre>\n<p>One of the primary reasons Lodash's <code>_.unset()</code> function was commonly used, was as a way to easily delete a nested property without having to worry about in-between fields being undefined. This is now possible today using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining\">optional chaining</a> (<code>?.</code>) whenever you suspect a property might be undefined.</p>\n<p>For example, these two are the same:</p>\n<pre><code class=\"javascript language-javascript\">_.unset(obj, 'a.b');\n\ndelete obj?.a?.b;\n</code></pre>\n<p>Note that the support for string paths in the above <code>unset()</code> implementation isn't very robust. It'll take invalid-looking input, such as <code>\"prop1.[prop2\"</code>, ignore the invalid parts, and attempt to work with it anyways. Lodash's <code>_.unset()</code> isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.</p>","src":null,"test":""},{"name":"update","manifest":{"fnSignature":"_.set(object, path, value)","lodashLink":"https://lodash.com/docs/4.17.15#set","summaryHtml":"<p>Sets the value at <code>path</code> of <code>object</code>. If a portion of <code>path</code> doesn't exist, it's created. Arrays are created for missing index properties while objects are created for all other missing properties.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function update(object, path, updater) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str =&gt; str[0] === '\"' &amp;&amp; str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x =&gt; x)\n      .map(x =&gt; !isNaN(Number(x)) ? Number(x) : x)\n      .map(x =&gt; typeof x === 'string' &amp;&amp; isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = updater();\n    return object;\n  }\n\n  if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  update(object[head], tail, updater);\n  return object;\n}\n</code></pre>\n<p>One of the primary reasons Lodash's <code>_.update()</code> function was commonly used, was as a way to easily update a nested property without having to worry about in-between fields being undefined. This is now possible today using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining\">optional chaining</a> (<code>?.</code>) whenever you suspect a property might be undefined.</p>\n<p>For example, these two accomplish the same objective:</p>\n<pre><code class=\"javascript language-javascript\">_.update(obj, 'a.b.c', () =&gt; new Something());\n\nif (obj?.a?.b) {\n  obj.a.b.c = new Something();\n}\n</code></pre>\n<p>Note that the support for string paths in the above <code>update()</code> implementation isn't very robust. It'll take invalid-looking input, such as <code>\"prop1.[prop2\"</code>, ignore the invalid parts, and attempt to work with it anyways. Lodash's <code>_.update()</code> isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.</p>","src":null,"test":""},{"name":"updateWith","manifest":{"fnSignature":"_.updateWith(object, path, updater, customizer?)","lodashLink":"https://lodash.com/docs/4.17.15#set","summaryHtml":"<p>This method is like <code>_.update</code> except that it accepts <code>customizer</code> which is invoked to produce the objects of <code>path</code>. If <code>customizer</code> returns <code>undefined</code> path creation is handled by the method instead.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function updateWith(object, path, updater, customizer) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str =&gt; str[0] === '\"' &amp;&amp; str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x =&gt; x)\n      .map(x =&gt; !isNaN(Number(x)) ? Number(x) : x)\n      .map(x =&gt; typeof x === 'string' &amp;&amp; isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = updater();\n    return object;\n  }\n\n  let pathSegment = customizer(object[head], head, object);\n\n  if (pathSegment !== undefined) {\n    object[head] = pathSegment;\n  } else if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  updateWith(object[head], tail, updater, customizer);\n  return object;\n}\n</code></pre>\n<p>Note that the support for string paths in the above <code>updateWith()</code> implementation isn't very robust. It'll take invalid-looking input, such as <code>\"prop1.[prop2\"</code>, ignore the invalid parts, and attempt to work with it anyways. Lodash's <code>_.updateWith()</code> isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.</p>","src":null,"test":""},{"name":"values","manifest":{"fnSignature":"_.values(object)","lodashLink":"https://lodash.com/docs/4.17.15#values","summaryHtml":"<p>Creates an array of the own enumerable string keyed property values of <code>object</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">Object.values(object)\n</code></pre>","src":null,"test":""},{"name":"valuesIn","manifest":{"fnSignature":"_.valuesIn(object)","lodashLink":"https://lodash.com/docs/4.17.15#valuesIn","summaryHtml":"<p>Creates an array of the own and inherited enumerable string keyed property values of <code>object</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function valuesIn(object) {\n  const values = [];\n  for (let key in object) {\n    values.push(object[key]);\n  }\n\n  return values;\n}\n</code></pre>\n<p>It's very likely that you don't actually need the above <code>valuesIn()</code> function. The only way this function is different from <code>_.values()</code> (or <code>Object.values()</code>), is that it'll also operate on non-enumerable inherited fields. But class syntax will automatically make all methods on the prototype chain non-enumerable, which means the <code>valuesIn()</code> function won't operate on them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.</p>\n<p>Perhaps there's some niche use-cases for this sort of function that arise from fairly abnormal and tricky uses of the JavaScript prototype, but, for day-to-day development, it's best to stay away from this function. If you just want to get an object's non-inherited property values, please look at <code>_.values()</code> instead.</p>","src":null,"test":""}]},{"categoryHeading":"String","entries":[{"name":"camelCase","manifest":{"fnSignature":"_.camelCase(string)","lodashLink":"https://lodash.com/docs/4.17.15#camelCase","summaryHtml":"<p>Converts <code>string</code> to camel case.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function camelCase(string) {\n  const capitalize = ([first = '', ...rest]) =&gt; first.toUpperCase() + rest.join('').toLowerCase();\n  const [firstWord, ...remainingWords] = string.split(' ');\n  return [\n    firstWord.toLowerCase(),\n    ...remainingWords.map(capitalize),\n  ].join('');\n}\n</code></pre>\n<p>The above generates the word list by simply splitting on space characters. Refer to <a href=\"#!/nolodash/words\">the entry for <code>_.words()</code></a> for alternative ways to extract words from text (which includes information on dealing with different languages).</p>\n<p>Refer to the <a href=\"#!/nolodash/capitalize\"><code>_.capitalize()</code> entry</a> to learn more about its implementations, and alternative ways to implement it in a more i18n-friendly manner.</p>\n<p>If you need to support internationalization, swap <code>.toUpperCase()</code>/<code>.toLowerCase()</code> with <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleUpperCase\"><code>.toLocalUpperCase()</code></a>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase\"><code>.toLocaleLowerCase()</code></a>, and, if needed, provide the target language as an argument to these functions. This solution isn't perfect - read <a href=\"https://stackoverflow.com/a/53930826/7696223\">this great post for a more nuanced exploration on internationalization and casing</a>.</p>\n<p>For reference, Lodash's algorithm is implemented roughly as follows:</p>\n<ul>\n<li><a href=\"#!/nolodash/deburr\">Deburr</a> the string (which mostly means that accent marks are removed from characters).</li>\n<li>Removes apostrophes (the ' and  characters).</li>\n<li>Split the string into words using the algorithm that powers <a href=\"#!/nolodash/words\"><code>_.words()</code></a>.</li>\n<li>Runs the first letter of each word (except the first) through <code>.toUpperCase()</code>, and runs the rest of the characters through <code>.toLowerCase()</code>.</li>\n</ul>","src":null,"test":"describe('camelCase()', () => {\n  function camelCase(string) {\n    const capitalize = ([first = '', ...rest]) => first.toUpperCase() + rest.join('').toLowerCase();\n    const [firstWord, ...remainingWords] = string.split(' ');\n    return [\n      firstWord.toLowerCase(),\n      ...remainingWords.map(capitalize),\n    ].join('');\n  }\n\n  it('converts text into camel case', () => {\n    expect(camelCase('HELLO aWeSoMe world')).toEqual('helloAwesomeWorld');\n  });\n\n  it('handles an empty string', () => {\n    expect(camelCase('')).toEqual('');\n  });\n});\n"},{"name":"capitalize","manifest":{"fnSignature":"_.capitalize(string)","lodashLink":"https://lodash.com/docs/4.17.15#capitalize","summaryHtml":"<p>Converts the first character of <code>string</code> to upper case and the remaining to lower case.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function capitalize([first = '', ...rest]) {\n  return first.toUpperCase() + rest.join('').toLowerCase();\n}\n</code></pre>\n<p>If you need better unicode support and an internationalization-friendly capitalize implementation, use the following instead instead:</p>\n<pre><code class=\"javascript language-javascript\">// Set this to your preferred locale,\n// or set it to `undefined` to use the runtime's default locale.\nconst LOCALE = 'en';\nconst segmenter = new Intl.Segmenter(LOCALE);\n\nfunction capitalize(text) {\n  let result = '';\n  for (const { segment, index } of segmenter.segment(text)) {\n    if (index === 0) {\n      result += segment.toLocaleUpperCase(LOCALE);\n    } else {\n      result += segment.toLocaleLowerCase(LOCALE);\n    }\n  }\n\n  return result;\n}\n</code></pre>","src":null,"test":"function capitalize([first = '', ...rest]) {\n  return first.toUpperCase() + rest.join('').toLowerCase();\n}\n\ndescribe('capitalize()', () => {\n  it('It converts the first character to upper case and the remaining to lower case', () => {\n    expect(capitalize('a b C')).toEqual('A b c');\n  });\n\n  it('works on empty strings', () => {\n    expect(capitalize('')).toEqual('');\n  });\n\n  // I would have a test case that shows how it can properly uppercase a multi-code-unit character,\n  // but I'm not actually aware of any specific scenarios that would show the different.\n  // Upper casing an entire character vs upper casing the first first part of a character usually yields the same results,\n  // but languages are weird, and I'm sure there's scenarios where the two differ.\n});\n"},{"name":"deburr","manifest":{"fnSignature":"_.deburr(string)","lodashLink":"https://lodash.com/docs/4.17.15#deburr","summaryHtml":"<p>Deburrs <code>string</code> by converting <a href=\"https://en.wikipedia.org/wiki/Latin-1_Supplement#Character_table\">Latin-1 Supplement</a> and <a href=\"https://en.wikipedia.org/wiki/Latin_Extended-A\">Latin Extended-A</a> letters to basic Latin letters and <a href=\"https://en.wikipedia.org/wiki/Combining_Diacritical_Marks\">removing combining diacritical marks</a>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// Credit for this implementation:\n// https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript/37511463#37511463\nfunction deburr(string) {\n  return string.normalize('NFKD').replace(/\\p{Diacritic}/gu, '');\n}\n</code></pre>\n<p>This will <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize\">normalize a unicode string</a> using the standard \"Compatibility Decomposition\" algorithm, which will cause accent characters to be represented as separate code point from its base character. Afterwords, all stray accent characters are removed with the <code>.replace()</code> call.</p>\n<p>The NFKD \"compatibility normalization\" algorithm will also normalize multiple characters that are supposed to represent the same abstract character, for example, a D in a circle (\"\") will be normalized into a normal \"D\". A circled C (\"\") would likewise be normalized into a \"C\", however, the copyright symbol (\"\") (which is a different code point from a circled C) will not be normalized into a \"C\", because, conceptually, the copyright symbol isn't intended to simply be a variation on the character \"C\".</p>\n<p>Depending on your use-case, you may find the NFD \"Canonical Decomposition\" algorithm to be a more appropriate choice. This algorithm will only normalize characters that are literally the same but have multiple representations. For example, the \"\" character is a single code point while the \"n\" character is an \"n\" followed by a tilde modifier - since these are just two different ways to represent the exact same character, they'll be normalized by the \"Canonical Decomposition\" algorithm into the decomposed variant - the \"n\" followed by a tilde modifier.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize\">Learn more about normalization algorithms, including other available algorithms on MDN</a>.</p>\n<p>The above <code>deburr()</code> implementation isn't exactly the same as Lodash's. Lodash implemented its <code>deburr()</code> function before <code>.normalize()</code> was available. It opted to use a large look-up table to convert one unicode character into another, and some of the choices it made was different from what <code>.normalize()</code> chose to do.</p>\n<p>Before reaching for <code>deburr()</code>, try looking around to see if there's a more specific solution to handle your use-case. Are you wanting to sort unicode strings? Consider using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Collator\">Intl.Collator</a> instead. Are you wanting to just do length-checking? Consider <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize#form\">using <code>.normalize()</code> with the \"NFC\" or \"NFKC\" algorithm instead</a>. In general, it could be good to google around to see if there are solutions available for your more specific problems. <code>deburr()</code> is a very blunt solution that could cause your text to be mangled in less-than-ideal ways.</p>","src":null,"test":"describe('deburr() with NFKD', () => {\n  function deburr(string) {\n    return string.normalize('NFKD').replace(/\\p{Diacritic}/gu, '');\n  }\n\n  it('deburrs accented characters that do not use combination marks', () => {\n    // This \"\" is of length 1 - it only uses a single code point to represent the character.\n    expect(deburr('')).toEqual('n');\n  });\n\n  it('deburrs combination marks', () => {\n    // This \"n\" is of length 2 - it encodes the \"n\" with one code point and the combining tilde with another.\n    expect(deburr('n')).toEqual('n');\n  });\n\n  it('deburrs compatible characters', () => {\n    // A \"D\" and a \"D\" inside of a circle are considered compatible.\n    expect(deburr('')).toEqual('D');\n  });\n});\n\ndescribe('deburr() with NFD', () => {\n  function deburr(string) {\n    return string.normalize('NFD').replace(/\\p{Diacritic}/gu, '');\n  }\n\n  it('deburrs accented characters that do not use combination marks', () => {\n    // This \"\" is of length 1 - it only uses a single code point to represent the character.\n    expect(deburr('')).toEqual('n');\n  });\n\n  it('deburrs combination marks', () => {\n    // This \"n\" is of length 2 - it encodes the \"n\" with one code point and the combining tilde with another.\n    expect(deburr('n')).toEqual('n');\n  });\n\n  it('does not deburr compatible characters', () => {\n    // A \"D\" and a \"D\" inside of a circle are considered compatible,\n    // but we aren't using the compatible deburring algorithm,\n    // so the string should be left alone.\n    expect(deburr('')).toEqual('');\n  });\n});\n"},{"name":"endsWith","manifest":{"fnSignature":"_.endsWith(string, target, position?)","lodashLink":"https://lodash.com/docs/4.17.15#endsWith","summaryHtml":"<p>Checks if <code>string</code> ends with the given target string.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">'abc'.endsWith('bc'); // =&gt; true\n</code></pre>\n<p>If you need to search from a particular location, use the following:</p>\n<pre><code class=\"javascript language-javascript\">const end = 3;\n'abcde'.slice(0, end).endsWith('bc'); // =&gt; true\n</code></pre>","src":null,"test":""},{"name":"escape","manifest":{"fnSignature":"_.escape(string)","lodashLink":"https://lodash.com/docs/4.17.15#escape","summaryHtml":"<p>Converts the characters \"&amp;\", \"<\", \">\", '\"', and \"'\" in string to their corresponding HTML entities.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function escapeHtmlChars(string) {\n  return string\n    .replaceAll('&amp;', '&amp;amp;')\n    .replaceAll('&lt;', '&amp;lt;')\n    .replaceAll('&gt;', '&amp;gt;')\n    .replaceAll('\"', '&amp;quot;')\n    .replaceAll(\"'\", '&amp;#39;');\n}\n</code></pre>\n<p>Please be careful when using functions like this as improper usage can result in XSS vulnerabilities. The following is a quick guideline on how this <code>escapeHtmlChars()</code> function should and should not be used.</p>\n<pre><code class=\"javascript language-javascript\">//  - It is safe to use escaped user input between most HTML tags.\n// (Just don't put it inside something silly like the &lt;script&gt; tag).\n`&lt;p&gt;${escapeHtmlChars(untrustedUserInput)}&lt;/p&gt;`\n</code></pre>\n<pre><code class=\"javascript language-javascript\">//  - It is generally safe to use escaped user input inside of HTML attributes.\n// (Just don't put it inside something silly like onclick=\"...\")\n`&lt;div data-author=\"${escapeHtmlChars(untrustedUserInput)}\"&gt;...&lt;/div&gt;`\n</code></pre>\n<pre><code class=\"javascript language-javascript\">//  - Attribute values should always be quoted when they are being populated\n// with user-supplied data.\n`&lt;img data-author=${escapeHtmlChars(untrustedUserInput)}&gt;`\n</code></pre>\n<pre><code class=\"javascript language-javascript\">//  - Using escapeHtmlChars() isn't enough if you want to place\n// the value where a URL is expected. This is because HTML\n// supports fake protocols like `javascript:` that, when used, will execute\n// arbitrary code.\n`&lt;img src=\"${escapeHtmlChars(untrustedUserInput)}\"&gt;`\n</code></pre>\n<p>For a deep dive on how to prevent XSS attacks, I would recommend <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html\">this guide on escaping characters for various different contexts</a>.</p>\n<h2>Don't use escapeHtmlChars() unless you have to</h2>\n<p>Do you <em>really</em> need an <code>escape()</code> function? Or would an alternative, less-error-prone solution work instead? There are valid reasons to need a function like <code>_.escape()</code>, but there are also some coding styles that force you to use it much more often than necessary. For example, perhaps you like to build your webpages via string interpolation and <code>.innerHTML</code>, such as in the following:</p>\n<pre><code class=\"javascript language-javascript\">document.body.innerHTML = `&lt;p&gt;${_.escape(userSuppliedString)}&lt;/p&gt;`;\n</code></pre>\n<p>This has the appearance of being simple and concise, but managing when and how to use <code>_.escape()</code> can be error-prone. There are a number of alternative solutions out there that remove many of these pitfalls (but not all, so you still need to look out for XSS vulnerabilities no matter how you code). For example, you can use the browser APIs to manually build up your HTML instead of using string manipulation + <code>.innerHTML</code>.</p>\n<pre><code class=\"javascript language-javascript\">const paragraph = document.createElement('p');\n// .textContent will automatically escape HTML characters for you.\nparagraph.textContent = userSuppliedString;\ndocument.body.replaceWith(paragraph);\n</code></pre>\n<p>If you find this APIs to be cumbersome to use, you may enjoy <a href=\"#!/utils/el\">a little helper function</a> to make using it more tolerable.</p>\n<p>Or you can consider installing a third-party tool such as <a href=\"https://handlebarsjs.com/guide/\">Handlebars</a> for a simple templating library or <a href=\"https://lit.dev/\">Lit</a> for a mini framework.</p>\n<p>Or if you don't want to add an installation step to your project, you can copy some or all of the <a href=\"#!/framework\">Snap Framework</a> (The <code>html</code> template tag is especially useful for solving this problem).</p>\n<p>All of these options will provide ways to auto-escape user-input for you, allowing you to focus more on UI building and less on data sanitization.</p>","src":null,"test":"function escapeHtmlChars(string) {\n  return string\n    .replaceAll('&', '&amp;')\n    .replaceAll('<', '&lt;')\n    .replaceAll('>', '&gt;')\n    .replaceAll('\"', '&quot;')\n    .replaceAll(\"'\", '&#39;');\n}\n\ndescribe('escapeHtmlChars()', () => {\n  it('escapes all characters', () => {\n    const res = escapeHtmlChars('&<>\"\\'');\n    expect(res).toEqual('&amp;&lt;&gt;&quot;&#39;');\n  });\n\n  it('escapes all instances', () => {\n    const res = escapeHtmlChars('&<&<&');\n    expect(res).toEqual('&amp;&lt;&amp;&lt;&amp;');\n  });\n\n  it(\"doesn't panic on the empty string\", () => {\n    expect(escapeHtmlChars('')).toEqual('');\n  });\n});\n"},{"name":"escapeRegExp","manifest":{"fnSignature":"_.escapeRegExp(string)","lodashLink":"https://lodash.com/docs/4.17.15#escapeRegExp","summaryHtml":"<p>Escapes the <code>RegExp</code> special characters \"^\", \"$\", \"\", \".\", \"*\", \"+\", \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in <code>string</code>.</p>"},"descriptionHtml":"<p>JavaScript has a new, native method for escaping regular expressions, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/escape\">RegExp.escape()</a>. Please check browser compatibility before using it, and if needed, use a polyfill.</p>\n<pre><code class=\"javascript language-javascript\">console.log(RegExp.escape('[lodash](https://lodash.com/)'));\n// =&gt; \\[lodash\\]\\(https\\x3a\\/\\/lodash\\.com\\/\\)\n</code></pre>\n<p>If you strip out Lodash's automatic coercion behavior and what-not, its escape function becomes essentially the following:</p>\n<pre><code class=\"javascript language-javascript\">function escapeRegExp(string) {\n  const reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n  return string.replace(reRegExpChar, '\\\\$&amp;');\n}\n</code></pre>\n<p>While this mostly works, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/escape\">MDN warns against solutions like this</a>.</p>\n<blockquote>\n  <p>don't try to re-implement [RegExp.escape()]'s functionality by, [] insert[ing] a <code>\\</code> before all syntax characters. <code>RegExp.escape()</code> is designed to use escape sequences that work in many more edge cases/contexts than hand-crafted code is likely to achieve.</p>\n</blockquote>","src":null,"test":""},{"name":"kebabCase","manifest":{"fnSignature":"_.kebabCase(string)","lodashLink":"https://lodash.com/docs/4.17.15#kebabCase","summaryHtml":"<p>Converts <code>string</code> to kebab case.</p>"},"descriptionHtml":"<p>A bare-bones implementation can be done as follows:</p>\n<pre><code class=\"javascript language-javascript\">string.toLowerCase().replaceAll(' ', '-')\n\n// 'Hello World'.toLowerCase().replaceAll(' ', '-')\n// =&gt; 'hello-world'\n</code></pre>\n<p>The above assumes that each word is separated by a single space. The <code>' '</code> string can be swapped for a regular expression, such as <code>/\\s+/g</code>, to cause it to separate words based on any grouping of whitespace instead.</p>\n<p>For other ways to separate a string into words, refer to <a href=\"#!/nolodash/words\">the entry for <code>_.words()</code></a>, which includes internationalization-related information as well. After separating a string into a list of words, simply do <code>&lt;list of words&gt;.join('-').toLowerCase()</code> on the result to create your snake case text (or use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase\"><code>.toLocaleLowerCase()</code></a> to make it i18n-compatible)</p>\n<p>For reference, Lodash's algorithm is implemented roughly as follows:</p>\n<ul>\n<li><a href=\"#!/nolodash/deburr\">Deburr</a> the string (which mostly means that accent marks are removed from characters).</li>\n<li>Removes apostrophes (the ' and  characters).</li>\n<li>Split the string into words using the algorithm that powers <a href=\"#!/nolodash/words\"><code>_.words()</code></a>.</li>\n<li>lower case each word with <code>.toLowerCase()</code>.</li>\n<li>Joins the words back together with a <code>-</code> character.</li>\n</ul>","src":null,"test":"describe('snakeCase()', () => {\n  function snakeCase(string) {\n    const words = string.split(/\\s+/);\n    return words.map(word => word.toLowerCase()).join(' ');\n  }\n\n  it('converts the words from the supplied string into lower-case', () => {\n    expect(snakeCase('HELLO    aWeSoMe\\nworld')).toEqual('hello awesome world');\n  });\n\n  it('handles an empty string', () => {\n    expect(snakeCase('')).toEqual('');\n  });\n});\n"},{"name":"lowerCase","manifest":{"fnSignature":"_.lowerCase(string)","lodashLink":"https://lodash.com/docs/4.17.15#lowerCase","summaryHtml":"<p>Converts <code>string</code>, as space separated words, to lower case.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function lowerCase(string) {\n  const words = string.split(/\\s+/);\n  return words.map(word =&gt; word.toLowerCase()).join(' ');\n}\n</code></pre>\n<p>The above generates the word list by simply splitting on whitespace characters. Refer to <a href=\"#!/nolodash/words\">the entry for <code>_.words()</code></a> for alternative ways to extract words from text (which includes information on dealing with different languages).</p>\n<p>If you need to support internationalization, swap <code>.toLowerCase()</code> with <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase\"><code>.toLocalLowerCase()</code></a>, and, if needed, provide the target language as an argument to these functions. This solution isn't perfect - read <a href=\"https://stackoverflow.com/a/53930826/7696223\">this great post for a more nuanced exploration on internationalization and casing</a>.</p>\n<p>For reference, Lodash's algorithm is implemented roughly as follows:</p>\n<ul>\n<li><a href=\"#!/nolodash/deburr\">Deburr</a> the string (which mostly means that accent marks are removed from characters).</li>\n<li>Removes apostrophes (the ' and  characters).</li>\n<li>Split the string into words using the algorithm that powers <a href=\"#!/nolodash/words\"><code>_.words()</code></a>.</li>\n<li>Lower case each word with <code>.toLowerCase()</code>.</li>\n</ul>","src":null,"test":"describe('lowerCase()', () => {\n  function lowerCase(string) {\n    const words = string.split(/\\s+/);\n    return words.map(word => word.toLowerCase()).join(' ');\n  }\n\n  it('converts the words from the supplied string into lower-case', () => {\n    expect(lowerCase('HELLO    aWeSoMe\\nworld')).toEqual('hello awesome world');\n  });\n\n  it('handles an empty string', () => {\n    expect(lowerCase('')).toEqual('');\n  });\n});\n"},{"name":"lowerFirst","manifest":{"fnSignature":"_.lowerFirst(string)","lodashLink":"https://lodash.com/docs/4.17.15#lowerFirst","summaryHtml":"<p>Converts the first character of <code>string</code> to lower case.</p>"},"descriptionHtml":"<p>I'm not entirely sure what the use-case is behind this function aside from trying to provide a lowercase version of every uppercasing-related function available. But it can be done as follows:</p>\n<pre><code class=\"javascript language-javascript\">function lowerFirst([first = '', ...rest]) {\n  return first.toLowerCase() + rest.join('');\n}\n</code></pre>\n<p>The above implementation is carefully implemented to rely on the iterator protocol to split the string into separate characters (destructuring syntax uses the iterator protocol under the hood). This is done because iteration will properly split a string into characters while string indexing and slicing can cause you to accidentally split a string in between a character (e.g. <code>const firstChar = ''[0];</code> produces an invalid character while <code>const [firstChar] = '';</code> will properly retrieve the first character as <code></code>).</p>\n<p>If you need to support internationalization, swap <code>.toLowerCase()</code> with <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase\"><code>.toLocalLowerCase()</code></a>, and, if needed, provide the target language as an argument. This solution isn't perfect - read <a href=\"https://stackoverflow.com/a/53930826/7696223\">this great post for a more nuanced exploration on internationalization and casing</a>.</p>","src":null,"test":"describe('lowerFirst()', () => {\n  function lowerFirst([first = '', ...rest]) {\n    return first.toLowerCase() + rest.join('');\n  }\n\n  it('It only converts the first character to lower case', () => {\n    expect(lowerFirst('a b C')).toEqual('a b C');\n  });\n\n  it('does not touch the string if the first character can not be converted to lower-case', () => {\n    expect(lowerFirst('+a')).toEqual('+a');\n  });\n\n  it('works on empty strings', () => {\n    expect(lowerFirst('')).toEqual('');\n  });\n\n  // I would have a test case that shows how it can properly lowercase a multi-code-unit character,\n  // but I'm not actually aware of any specific scenarios that would show the different.\n  // Lower casing an entire character vs lower casing the first first part of a character usually yields the same results,\n  // but languages are weird, and I'm sure there's scenarios where the two differ.\n});\n"},{"name":"pad","manifest":{"fnSignature":"_.pad(string, length, chars?)","lodashLink":"https://lodash.com/docs/4.17.15#pad","summaryHtml":"<p>Pads <code>string</code> on the left and right sides if it's shorter than <code>length</code>. Padding characters are truncated if they can't be evenly divided by <code>length</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function pad(string, length, chars = ' ') {\n  const charsToAdd = Math.max(0, length - string.length);\n  const leftPadLength = string.length + Math.floor(charsToAdd / 2);\n  return string.padStart(leftPadLength, chars).padEnd(length, chars);\n}\n</code></pre>","src":null,"test":""},{"name":"padEnd","manifest":{"fnSignature":"_.padEnd(string, length, chars?)","lodashLink":"https://lodash.com/docs/4.17.15#padEnd","summaryHtml":"<p>Pads <code>string</code> on the right side if it's shorter than <code>length</code>. Padding characters are truncated if they exceed <code>length</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">string.padEnd(length, chars)\n</code></pre>","src":null,"test":""},{"name":"padStart","manifest":{"fnSignature":"_.padStart(string, length, chars?)","lodashLink":"https://lodash.com/docs/4.17.15#padStart","summaryHtml":"<p>Pads <code>string</code> on the left side if it's shorter than <code>length</code>. Padding characters are truncated if they exceed <code>length</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">string.padStart(length, chars)\n</code></pre>","src":null,"test":""},{"name":"parseInt","manifest":{"fnSignature":"_.parseInt(string, radix?)","lodashLink":"https://lodash.com/docs/4.17.15#parseInt","summaryHtml":"<p>Converts <code>string</code> to an integer of the specified radix.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">parseInt(string, radix)\n</code></pre>\n<p>Be aware that <code>parseInt()</code> may exhibit some surprising and undesirable behaviors, for example, if it's unable to parse a portion of a string, it'll discard the rest and parse what it can, leading to strings such as <code>parseInt('2e7')</code> resulting in <code>2</code> being returned.</p>\n<p>For a larger discussion on string-to-number conversion, see <a href=\"#!/nolodash/toNumber\">the doc entry for <code>_.toNumber()</code></a>.</p>","src":null,"test":""},{"name":"repeat","manifest":{"fnSignature":"_.repeat(string, n)","lodashLink":"https://lodash.com/docs/4.17.15#repeat","summaryHtml":"<p>Repeats the given string <code>n</code> times.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">string.repeat(n)\n</code></pre>","src":null,"test":""},{"name":"replace","manifest":{"fnSignature":"_.replace(string, pattern, replacement)","lodashLink":"https://lodash.com/docs/4.17.15#replace","summaryHtml":"<p>Replaces matches for <code>pattern</code> in <code>string</code> with <code>replacement</code>.</p>"},"descriptionHtml":"<p>If you want to replace all occurrences:</p>\n<pre><code class=\"javascript language-javascript\">string.replaceAll(pattern, replacement)\n\n// -- Examples --\n\n'a-b-c'.replaceAll('-', '.') // =&gt; 'a.b.c'\n'a-b-c'.replaceAll(/-/g, '.') // =&gt; 'a.b.c'\n\n// If the g flag is unset, an error will be thrown\n'a-b-c'.replaceAll(/-/, '.') // =&gt; TypeError!\n</code></pre>\n<p>If you only want to replace the first occurrence:</p>\n<pre><code class=\"javascript language-javascript\">string.replace(pattern, replacement)\n\n// -- Examples --\n\n'a-b-c'.replace('-', '.') // =&gt; 'a.b-c'\n'a-b-c'.replace(/-/, '.') // =&gt; 'a.b-c'\n\n// If the g flag is set, it will actually replace all\n// occurrences, just like .replaceAll()\n'a-b-c'.replace(/-/g, '.') // =&gt; 'a-b-c'\n</code></pre>\n<p>Lodash's <code>_.replace()</code> will behave like <code>string.replaceAll()</code> when you give it a string <code>pattern</code>, in that it'll replace all occurrences of that string, and it will behave like <code>string.replace()</code> if you give it a regular expression pattern, in that it'll replace all occurrences if the global flag is set, otherwise it will only replace the first occurrence.</p>","src":null,"test":""},{"name":"snakeCase","manifest":{"fnSignature":"_.snakeCase(string)","lodashLink":"https://lodash.com/docs/4.17.15#snakeCase","summaryHtml":"<p>Converts <code>string</code> to snake case.</p>"},"descriptionHtml":"<p>A bare-bones implementation can be done as follows:</p>\n<pre><code class=\"javascript language-javascript\">string.toLowerCase().replaceAll(' ', '_')\n\n// 'Hello World'.toLowerCase().replaceAll(' ', '_')\n// =&gt; 'hello_world'\n</code></pre>\n<p>The above assumes that each word is separated by a single space. The <code>' '</code> string can be swapped for a regular expression, such as <code>/\\s+/g</code>, to cause it to separate words based on any grouping of whitespace instead.</p>\n<p>For other ways to separate a string into words, refer to <a href=\"#!/nolodash/words\">the entry for <code>_.words()</code></a>, which includes internationalization-related information as well. After separating a string into a list of words, simply do <code>&lt;list of words&gt;.join('_').toLowerCase()</code> on the result to create your snake case text (or use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase\"><code>.toLocaleLowerCase()</code></a> to make it i18n-compatible)</p>\n<p>For reference, Lodash's algorithm is implemented roughly as follows:</p>\n<ul>\n<li><a href=\"#!/nolodash/deburr\">Deburr</a> the string (which mostly means that accent marks are removed from characters).</li>\n<li>Removes apostrophes (the ' and  characters).</li>\n<li>Split the string into words using the algorithm that powers <a href=\"#!/nolodash/words\"><code>_.words()</code></a>.</li>\n<li>lower case each word with <code>.toLowerCase()</code>.</li>\n<li>Joins the words back together with a <code>_</code> character.</li>\n</ul>","src":null,"test":"describe('snakeCase()', () => {\n  function snakeCase(string) {\n    const words = string.split(/\\s+/);\n    return words.map(word => word.toLowerCase()).join(' ');\n  }\n\n  it('converts the words from the supplied string into lower-case', () => {\n    expect(snakeCase('HELLO    aWeSoMe\\nworld')).toEqual('hello awesome world');\n  });\n\n  it('handles an empty string', () => {\n    expect(snakeCase('')).toEqual('');\n  });\n});\n"},{"name":"split","manifest":{"fnSignature":"_.split(string, separator, limit?)","lodashLink":"https://lodash.com/docs/4.17.15#split","summaryHtml":"<p>Splits <code>string</code> by <code>separator</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">string.split(separator, limit)\n</code></pre>","src":null,"test":""},{"name":"startCase","manifest":{"fnSignature":"_.startCase(string)","lodashLink":"https://lodash.com/docs/4.17.15#startCase","summaryHtml":"<p>Converts <code>string</code> to start case.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function startCase(string) {\n  const capitalize = ([first = '', ...rest]) =&gt; first.toUpperCase() + rest.join('');\n  return string.split(' ').map(capitalize).join(' ');\n}\n</code></pre>\n<p>The above generates the word list by simply splitting on space characters. Refer to <a href=\"#!/nolodash/words\">the entry for <code>_.words()</code></a> for alternative ways to extract words from text (which includes information on dealing with different languages).</p>\n<p>Refer to the <a href=\"#!/nolodash/capitalize\"><code>_.capitalize()</code> entry</a> to learn more about its implementations, and alternative ways to implement it in a more i18n-friendly manner. The <code>capitalize()</code> implementation used above is slightly different from <code>_.capitalize()</code> in that it doesn't lowercase the rest of the string in order to align with Lodash's behavior for <code>_.startCase()</code>.</p>\n<p>If you need to support internationalization, swap <code>.toUpperCase()</code>/<code>.toLowerCase()</code> with <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleUpperCase\"><code>.toLocalUpperCase()</code></a>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase\"><code>.toLocaleLowerCase()</code></a>, and, if needed, provide the target language as an argument to these functions. This solution isn't perfect - read <a href=\"https://stackoverflow.com/a/53930826/7696223\">this great post for a more nuanced exploration on internationalization and casing</a>.</p>\n<p>For reference, Lodash's algorithm is implemented roughly as follows:</p>\n<ul>\n<li><a href=\"#!/nolodash/deburr\">Deburr</a> the string (which mostly means that accent marks are removed from characters).</li>\n<li>Removes apostrophes (the ' and  characters).</li>\n<li>Split the string into words using the algorithm that powers <a href=\"#!/nolodash/words\"><code>_.words()</code></a>.</li>\n<li>Runs the first letter of each word through <code>.toUpperCase()</code>.</li>\n<li>Joins the words back together with a space.</li>\n</ul>","src":null,"test":"describe('startCase()', () => {\n  function startCase(string) {\n    const capitalize = ([first = '', ...rest]) => first.toUpperCase() + rest.join('');\n    return string.split(' ').map(capitalize).join(' ');\n  }\n\n  it('converts text into start case', () => {\n    expect(startCase('HELLO aWeSoMe world')).toEqual('HELLO AWeSoMe World');\n  });\n\n  it('handles an empty string', () => {\n    expect(startCase('')).toEqual('');\n  });\n});\n"},{"name":"startsWith","manifest":{"fnSignature":"_.startsWith(string, target, position?)","lodashLink":"https://lodash.com/docs/4.17.15#startsWith","summaryHtml":"<p>Checks if <code>string</code> starts with the given target string.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">'abc'.startsWith('ab') // =&gt; true\n</code></pre>\n<p>If you search from a particular location, use the following:</p>\n<pre><code class=\"javascript language-javascript\">const start = 2;\n'abcde'.slice(start).startsWith('cd'); // =&gt; true\n</code></pre>","src":null,"test":""},{"name":"template","manifest":{"fnSignature":"_.template(string, options?)","lodashLink":"https://lodash.com/docs/4.17.15#template","summaryHtml":"<p>Creates a compiled template function that can interpolate data properties in \"interpolate\" delimiters, HTML-escape interpolated data properties in \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters.</p>"},"descriptionHtml":"<p>The templating syntax was built to mimic templating syntax from other languages that were commonly used when Lodash's was first created. But we can instead embrace the features JavaScript already provides, including some of its newer syntax, and find that we already have everything we need to achieve what Lodash had accomplished. Let's walk through some of Lodash's templating examples and show what it takes to replicate the same kind of behavior without Lodash.</p>\n<p>In some of the non-lodash examples, I will use an \"esc\" function, derived from the <a href=\"#!/nolodash/escape\">_.escape</a> entry to escape HTML characters. This function is defined as follows:</p>\n<pre><code class=\"javascript language-javascript\">function esc(string) {\n  return string\n    .replaceAll('&amp;', '&amp;amp;')\n    .replaceAll('&lt;', '&amp;lt;')\n    .replaceAll('&gt;', '&amp;gt;')\n    .replaceAll('\"', '&amp;quot;')\n    .replaceAll(\"'\", '&amp;#39;');\n}\n</code></pre>\n<p>With Lodash:</p>\n<!-- eslint-disable @stylistic/quote-props -->\n<pre><code class=\"javascript language-javascript\">// Use the \"interpolate\" delimiter to create a compiled template.\nvar compiled = _.template('hello &lt;%= user %&gt;!');\ncompiled({ 'user': 'fred' });\n// =&gt; 'hello fred!'\n</code></pre>\n<p>Without Lodash:</p>\n<!-- eslint-disable @stylistic/quote-props -->\n<pre><code class=\"javascript language-javascript\">const compiled = ({ user }) =&gt; `hello ${user}!`;\ncompiled({ 'user': 'fred' });\n// =&gt; 'hello fred!'\n</code></pre>\n<p>With Lodash:</p>\n<!-- eslint-disable @stylistic/quote-props -->\n<pre><code class=\"javascript language-javascript\">// Use the HTML \"escape\" delimiter to escape data property values.\nvar compiled = _.template('&lt;b&gt;&lt;%- value %&gt;&lt;/b&gt;');\ncompiled({ 'value': '&lt;script&gt;' });\n// =&gt; '&lt;b&gt;&amp;lt;script&amp;gt;&lt;/b&gt;'\n</code></pre>\n<p>Without Lodash:</p>\n<!-- eslint-disable @stylistic/quote-props -->\n<pre><code class=\"javascript language-javascript\">const compiled = ({ value }) =&gt; `&lt;b&gt;${esc(value)}&lt;/b&gt;`;\ncompiled({ 'value': '&lt;script&gt;' });\n// =&gt; '&lt;b&gt;&amp;lt;script&amp;gt;&lt;/b&gt;'\n</code></pre>\n<p>With Lodash:</p>\n<!-- eslint-disable @stylistic/quote-props -->\n<pre><code class=\"javascript language-javascript\">// Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\nvar compiled = _.template('&lt;% _.forEach(users, function(user) { %&gt;&lt;li&gt;&lt;%- user %&gt;&lt;/li&gt;&lt;% }); %&gt;');\ncompiled({ 'users': ['fred', 'barney'] });\n// =&gt; '&lt;li&gt;fred&lt;/li&gt;&lt;li&gt;barney&lt;/li&gt;'\n</code></pre>\n<p>Without Lodash:</p>\n<!-- eslint-disable @stylistic/quote-props -->\n<pre><code class=\"javascript language-javascript\">const compiled = ({ users }) =&gt; {\n  let result = '';\n  for (const user of users) result += `&lt;li&gt;${esc(user)}&lt;/li&gt;`;\n  return result;\n}\ncompiled({ 'users': ['fred', 'barney'] });\n// =&gt; '&lt;li&gt;fred&lt;/li&gt;&lt;li&gt;barney&lt;/li&gt;'\n</code></pre>\n<p>As a bonus, in the non-lodash versions, you will get proper editor support for the JavaScript code you're writing inside the template, such as syntax highlighting, variable name suggestions, bracket matching, etc.</p>\n<p>If you aren't satisfied with the above solution, and really want something more terse like Lodash provides, consider using a generator function instead, with perhaps another helper function to convert the generator's output into a string, as follows:</p>\n<!-- eslint-disable @stylistic/quote-props -->\n<pre><code class=\"javascript language-javascript\">const stringBuilder = generator =&gt; (...args) =&gt; {\n  let result = '';\n  for (const subString of generator(...args)) {\n    result += subString;\n  }\n  return result;\n};\n\n// Usage example:\n\nconst compiled = stringBuilder(function* ({ users }) {\n  for (const user of users) yield `&lt;li&gt;${esc(user)}&lt;/li&gt;`;\n});\ncompiled({ 'users': ['fred', 'barney'] });\n// =&gt; '&lt;li&gt;fred&lt;/li&gt;&lt;li&gt;barney&lt;/li&gt;'\n</code></pre>\n<h2>A caution</h2>\n<p>Be careful when using a templating solution, like Lodash's <code>_.template()</code>, or the string-building patterns describe above - in both cases you're required to know when and how to manually escape HTML characters to avoid XSS vulnerabilities. The following is a quick guideline on how HTML escaping should and should not be done:</p>\n<pre><code class=\"javascript language-javascript\">//  - It is safe to use escaped user input between most HTML tags.\n// (Just don't put it inside something silly like the &lt;script&gt; tag).\n_.template('&lt;p&gt;&lt;%- untrustedUserInput %&gt;&lt;/p&gt;')\nopts =&gt; `&lt;p&gt;${esc(opts.untrustedUserInput)}&lt;/p&gt;`\n\n//  - It is generally safe to use escaped user input inside of HTML attributes.\n// (Just don't put it inside something silly like onclick=\"...\")\n_.template('&lt;div data-author=\"&lt;%- untrustedUserInput %&gt;\"&gt;...&lt;/div&gt;')\nopts =&gt; `&lt;div data-author=\"${esc(opts.untrustedUserInput)}\"&gt;...&lt;/div&gt;`\n\n//  - Attribute values should always be quoted when they are being populated\n// with user-supplied data.\n_.template('&lt;img data-author=&lt;%- untrustedUserInput %&gt;&gt;')\nopts =&gt; `&lt;img data-author=${esc(opts.untrustedUserInput)}&gt;`\n\n//  - Using escapeHtmlChars() isn't enough if you want to place\n// the value where a URL is expected. This is because HTML\n// supports fake protocols like `javascript:` that, when used, will execute\n// arbitrary code.\n_.template('&lt;img src=\"&lt;%- untrustedUserInput %&gt;\"&gt;')\nopts =&gt; `&lt;img src=\"${esc(opts.untrustedUserInput)}\"&gt;`\n</code></pre>\n<p>For a deep dive on how to prevent XSS attacks, I would recommend <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html\">this guide on escaping characters for various different contexts</a>.</p>\n<p>Consider using a solution that handles most of the HTML escaping concerns for you. You can't ever fully eliminate the need to consider XXS attacks as you code, but you can reduce the number of places where mistakes could happen. Some alternatives include:</p>\n<ul>\n<li>Building your HTML with the native DOM APIs (using <code>document.createElement()</code> and such).</li>\n<li>Using an <a href=\"#!/utils/el\"><code>el()</code></a> helper function to make the native DOM APIs a little nicer to use.</li>\n<li>Installing a third-party tool such as <a href=\"https://handlebarsjs.com/guide/\">Handlebars</a> for a simple templating library or <a href=\"https://lit.dev/\">Lit</a> for a mini framework.</li>\n<li>If you don't want to add an installation step to your project, you can copy some or all of the <a href=\"#!/framework\">Snap Framework</a> (The <code>html</code> template tag is especially useful for solving this problem).</li>\n</ul>","src":null,"test":""},{"name":"toLower","manifest":{"fnSignature":"_.toLower(string)","lodashLink":"https://lodash.com/docs/4.17.15#toLower","summaryHtml":"<p>Converts string, as a whole, to lower case.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">string.toLowerCase()\n</code></pre>\n<p>If you need to be language-sensitive, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase\"><code>toLocaleLowerCase()</code></a> instead, and supply the chosen locale as an argument.</p>","src":null,"test":""},{"name":"toUpper","manifest":{"fnSignature":"_.toUpper(string)","lodashLink":"https://lodash.com/docs/4.17.15#toUpper","summaryHtml":"<p>Converts string, as a whole, to upper case.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">string.toUpperCase()\n</code></pre>\n<p>If you need to be language-sensitive, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleUpperCase\"><code>toLocaleUpperCase()</code></a> instead, and supply the chosen locale as an argument.</p>","src":null,"test":""},{"name":"trim","manifest":{"fnSignature":"_.trim(string, chars?)","lodashLink":"https://lodash.com/docs/4.17.15#trim","summaryHtml":"<p>Removes leading and trailing whitespace or specified characters from <code>string</code>.</p>"},"descriptionHtml":"<p>If you simply want to remove whitespace from both ends of the string, use the following:</p>\n<pre><code class=\"javascript language-javascript\">string.trim()\n</code></pre>\n<p>If you want to specify which characters to trim, use the following:</p>\n<!-- Due to the repeated variable names, eslint can't lint this. You'll need to manually lint it through other means. -->\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">/*# METADATA\n[\n  {\n    \"id\": \"unicodeSupport\",\n    \"type\": \"radio\",\n    \"message\": \"Do you need proper unicode/i18n support?\",\n    \"default\": \"no\",\n    \"options\": {\n      \"no\": \"No - I only plan on trimming ASCII strings containing English text.\",\n      \"yes\": \"Yes - I'd like to be able to properly support accent marks, emojis, etc, with an i18n-sensitive solution.\"\n    }\n  }\n]\n#*/\n\n//# CONFIG { \"unicodeSupport\": \"no\" }\n\nfunction trim(str, chars) {\n  let left = 0;\n  while (left &lt; str.length &amp;&amp; chars.includes(str[left])) {\n    left++;\n  }\n\n  let right = str.length - 1;\n  while (right &gt;= left &amp;&amp; chars.includes(str[right])) {\n    right--;\n  }\n\n  return str.slice(left, right + 1);\n}\n\n// Normal usage:\n// trim('-_-abc-_-', '_-') // =&gt; 'abc'\n\n// Characters that don't fit in 16 bits,\n// such as \"\", can cause unexpected behavior.\n// trim('hi!', '') // =&gt; 'hi!'\n\n//# CONFIG { \"unicodeSupport\": \"yes\" }\n\n// Set this to your preferred locale,\n// or set it to `undefined` to use the runtime's default locale.\nconst LOCALE = 'en';\nconst segmenter = new Intl.Segmenter(LOCALE);\nconst collator = new Intl.Collator(LOCALE)\n\nfunction trim(str, chars) {\n  const charList = [...segmenter.segment(chars)]\n    .map(({ segment }) =&gt; segment);\n\n  let left = 0;\n  let right = 0;\n  let onlySeenTrimmableChars = true;\n  for (const { segment, index } of segmenter.segment(str)) {\n    const isTrimmable = charList.some(\n      char =&gt; collator.compare(char, segment) === 0,\n    );\n    if (onlySeenTrimmableChars &amp;&amp; isTrimmable) {\n      left = index + segment.length;\n    }\n    if (!isTrimmable) {\n      onlySeenTrimmableChars = false;\n      right = index + segment.length;\n    }\n  }\n\n  return str.slice(left, right);\n}\n\n// Normal usage:\n// trim('-_-abc-_-', '_-') // =&gt; 'abc'\n\n// Characters that don't fit in 16 bits,\n// such as \"\", will work as expected.\n// trim('hi!', '') // =&gt; 'hi!'\n</code></pre>\n<p>Lodash provides some unicode support with its <code>_.trim()</code> implementation, but it isn't as robust as using the native <code>Intl</code> APIs that the unicode-aware variant of the above solution utilizes.</p>","src":null,"test":""},{"name":"trimEnd","manifest":{"fnSignature":"_.trimEnd(string, chars?)","lodashLink":"https://lodash.com/docs/4.17.15#trimEnd","summaryHtml":"<p>Removes trailing whitespace or specified characters from <code>string</code>.</p>"},"descriptionHtml":"<p>If you simply want to remove whitespace from the end of the string, use the following:</p>\n<pre><code class=\"javascript language-javascript\">string.trimEnd()\n</code></pre>\n<p>If you want to specify which characters to trim, use the following:</p>\n<!-- Due to the repeated variable names, eslint can't lint this. You'll need to manually lint it through other means. -->\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">/*# METADATA\n[\n  {\n    \"id\": \"unicodeSupport\",\n    \"type\": \"radio\",\n    \"message\": \"Do you need proper unicode/i18n support?\",\n    \"default\": \"no\",\n    \"options\": {\n      \"no\": \"No - I only plan on trimming ASCII strings containing English text.\",\n      \"yes\": \"Yes - I'd like to be able to properly support accent marks, emojis, etc, with an i18n-sensitive solution.\"\n    }\n  }\n]\n#*/\n\n//# CONFIG { \"unicodeSupport\": \"no\" }\n\nfunction trimEnd(str, chars) {\n  const strArray = [...str];\n  while (strArray.length &gt; 0 &amp;&amp; chars.includes(strArray.at(-1))) {\n    strArray.pop();\n  }\n\n  return strArray.join('');\n}\n\n// Normal usage:\n// trimEnd('-_-abc-_-', '_-') // =&gt; '-_-abc'\n\n// Characters that don't fit in 16 bits,\n// such as \"\", can cause unexpected behavior.\n// trimEnd('hi!', '') // =&gt; 'hi!'\n\n//# CONFIG { \"unicodeSupport\": \"yes\" }\n\n// Set this to your preferred locale,\n// or set it to `undefined` to use the runtime's default locale.\nconst LOCALE = 'en';\nconst segmenter = new Intl.Segmenter(LOCALE);\nconst collator = new Intl.Collator(LOCALE)\n\nfunction trimEnd(str, chars) {\n  const charList = [...segmenter.segment(chars)]\n    .map(({ segment }) =&gt; segment);\n\n  let right = 0;\n  for (const { segment, index } of segmenter.segment(str)) {\n    const isTrimmable = charList.some(\n      char =&gt; collator.compare(char, segment) === 0,\n    );\n\n    if (!isTrimmable) {\n      right = index + segment.length;\n    }\n  }\n\n  return str.slice(0, right);\n}\n\n// Normal usage:\n// trimEnd('-_-abc-_-', '_-') // =&gt; '-_-abc'\n\n// Characters that don't fit in 16 bits,\n// such as \"\", will work as expected.\n// trimEnd('hi!', '') // =&gt; 'hi!'\n</code></pre>\n<p>Lodash provides some unicode support with its <code>_.trim()</code> implementation, but it isn't as robust as using the native <code>Intl</code> APIs that the unicode-aware variant of the above solution utilizes.</p>","src":null,"test":""},{"name":"trimStart","manifest":{"fnSignature":"_.trimStart(string, chars?)","lodashLink":"https://lodash.com/docs/4.17.15#trimStart","summaryHtml":"<p>Removes leading whitespace or specified characters from <code>string</code>.</p>"},"descriptionHtml":"<p>If you simply want to remove whitespace from the start of the string, use the following:</p>\n<pre><code class=\"javascript language-javascript\">string.trimStart()\n</code></pre>\n<p>If you want to specify which characters to trim, use the following:</p>\n<!-- Due to the repeated variable names, eslint can't lint this. You'll need to manually lint it through other means. -->\n<!-- eslint-skip -->\n<pre><code class=\"javascript language-javascript\">/*# METADATA\n[\n  {\n    \"id\": \"unicodeSupport\",\n    \"type\": \"radio\",\n    \"message\": \"Do you need proper unicode/i18n support?\",\n    \"default\": \"no\",\n    \"options\": {\n      \"no\": \"No - I only plan on trimming ASCII strings containing English text.\",\n      \"yes\": \"Yes - I'd like to be able to properly support accent marks, emojis, etc, with an i18n-sensitive solution.\"\n    }\n  }\n]\n#*/\n\n//# CONFIG { \"unicodeSupport\": \"no\" }\n\nfunction trimStart(str, chars) {\n  let left = 0;\n  while (left &lt; str.length &amp;&amp; chars.includes(str[left])) {\n    left++;\n  }\n\n  return str.slice(left);\n}\n\n// Normal usage:\n// trimStart('-_-abc-_-', '_-') // =&gt; 'abc-_-'\n\n// Characters that don't fit in 16 bits,\n// such as \"\", can cause unexpected behavior.\n// trimStart('hi!', '') // =&gt; 'hi!'\n\n//# CONFIG { \"unicodeSupport\": \"yes\" }\n\n// Set this to your preferred locale,\n// or set it to `undefined` to use the runtime's default locale.\nconst LOCALE = 'en';\nconst segmenter = new Intl.Segmenter(LOCALE);\nconst collator = new Intl.Collator(LOCALE)\n\nfunction trimStart(str, chars) {\n  const charList = [...segmenter.segment(chars)]\n    .map(({ segment }) =&gt; segment);\n\n  let left = 0;\n  for (const { segment, index } of segmenter.segment(str)) {\n    const isTrimmable = charList.some(\n      char =&gt; collator.compare(char, segment) === 0,\n    );\n\n    if (!isTrimmable) {\n      break;\n    }\n\n    left = index + segment.length;\n  }\n\n  return str.slice(left);\n}\n\n// Normal usage:\n// trimStart('-_-abc-_-', '_-') // =&gt; 'abc-_-'\n\n// Characters that don't fit in 16 bits,\n// such as \"\", will work as expected.\n// trimStart('hi!', '') // =&gt; 'hi!'\n</code></pre>\n<p>Lodash provides some unicode support with its <code>_.trimStart()</code> implementation, but it isn't as robust as using the native <code>Intl</code> APIs that the unicode-aware variant of the above solution utilizes.</p>","src":null,"test":""},{"name":"truncate","manifest":{"fnSignature":"_.truncate(string, options)","lodashLink":"https://lodash.com/docs/4.17.15#truncate","summaryHtml":"<p>Truncates <code>string</code> if it's longer than the given maximum string length. The last characters of the truncated string are replaced with the omission string which defaults to \"\".</p>"},"descriptionHtml":"<p>A basic implementation that does not support the <code>separator</code> parameter can be achieved as follows:</p>\n<pre><code class=\"javascript language-javascript\">function truncate(string, { length, omission = '...' }) {\n  if (string.length &lt;= length) {\n    return string;\n  }\n\n  return string.slice(0, length - omission.length) + omission;\n}\n</code></pre>\n<p>A more complete implementation that supports truncating at a string or regular expression separator can be implemented as follows:</p>\n<pre><code class=\"javascript language-javascript\">function truncate(string, { length, separator = '', omission = '...' }) {\n  if (string.length &lt;= length) {\n    return string;\n  }\n\n  // Largest size you can slice `string` while remaining in the `length` restriction.\n  const maxSliceLength = length - omission.length;\n\n  if (typeof separator === 'string') {\n    let index = string.lastIndexOf(separator, maxSliceLength);\n    if (index === -1) {\n      index = maxSliceLength;\n    }\n    return string.slice(0, index) + omission;\n  } else if (separator instanceof RegExp) {\n    let bestMatch = undefined;\n    for (const match of string.matchAll(separator)) {\n      if (match.index &lt;= maxSliceLength) {\n        bestMatch = match;\n      }\n    }\n\n    const index = bestMatch?.index ?? maxSliceLength;\n    return string.slice(0, index) + omission;\n  } else {\n    throw new Error('Invalid separator type received.');\n  }\n}\n</code></pre>\n<p>One difference with the above implementation and Lodash's version is that a separator regular expression must have the \"g\" flag set. If you have a regular expression on hand that does not have the <code>g</code> flag set, and you would like it to, you can convert it as follows:</p>\n<pre><code class=\"javascript language-javascript\">const regexWithGlobalFlag = regex.global\n  ? regex\n  : new RegExp(regex.source, regex.flags + 'g');\n</code></pre>\n<p>If you're wanting to truncate a string before displaying it in the browser, you may wish to instead use the <code>text-overflow: ellipsis</code> rule on the container holding to text. This rule is able to smartly truncate the text just before it would overflow out of the container, as opposed to truncating based on character count (remember that different characters can have different widths). To make the text-overflow property work, you'll also need to limit the container's size (e.g. by setting the <code>width</code> rule), set <code>overflow: hidden</code>, and set <code>white-space: nowrap</code>.</p>","src":null,"test":"describe('truncate() without separator support', () => {\n  function truncate(string, { length, omission = '...' }) {\n    if (string.length <= length) {\n      return string;\n    }\n\n    return string.slice(0, length - omission.length) + omission;\n  }\n\n  it('does not truncate a string that is within the length limit', () => {\n    expect(truncate('abcde', { length: 6 })).toEqual('abcde');\n    expect(truncate('abcde', { length: 5 })).toEqual('abcde');\n    expect(truncate('abcde', { length: 4 })).not.toEqual('abcde');\n  });\n\n  it('appends the omission string when truncating', () => {\n    expect(truncate('abcde', { length: 4 })).toEqual('a...');\n    expect(truncate('abcde', { length: 4, omission: '' })).toEqual('abc');\n  });\n});\n\ndescribe('truncate() with separator support', () => {\n  function truncate(string, { length, separator = '', omission = '...' }) {\n    if (string.length <= length) {\n      return string;\n    }\n\n    // Largest size you can slice `string` while remaining in the `length` restriction.\n    const maxSliceLength = length - omission.length;\n\n    if (typeof separator === 'string') {\n      let index = string.lastIndexOf(separator, maxSliceLength);\n      if (index === -1) {\n        index = maxSliceLength;\n      }\n      return string.slice(0, index) + omission;\n    } else if (separator instanceof RegExp) {\n      let bestMatch = undefined;\n      for (const match of string.matchAll(separator)) {\n        if (match.index <= maxSliceLength) {\n          bestMatch = match;\n        }\n      }\n\n      const index = bestMatch?.index ?? maxSliceLength;\n      return string.slice(0, index) + omission;\n    } else {\n      throw new Error('Invalid separator type received.');\n    }\n  }\n\n  it('does not truncate a string that is within the length limit', () => {\n    expect(truncate('abcde', { length: 6 })).toEqual('abcde');\n    expect(truncate('abcde', { length: 5 })).toEqual('abcde');\n    expect(truncate('abcde', { length: 4 })).not.toEqual('abcde');\n  });\n\n  it('appends the omission string when truncating', () => {\n    expect(truncate('abcde', { length: 4 })).toEqual('a...');\n    expect(truncate('abcde', { length: 4, omission: '' })).toEqual('abc');\n  });\n\n  it('can truncate using a string separator', () => {\n    expect(truncate('abcd~=efgh~=ijklmn', { separator: '~=', length: 'abcd~=efgh~=i...'.length })).toEqual('abcd~=efgh...');\n    expect(truncate('abcd~=efgh~=ijklmn', { separator: '~=', length: 'abcd~=efgh~=...'.length })).toEqual('abcd~=efgh...');\n    expect(truncate('abcd~=efgh~=ijklmn', { separator: '~=', length: 'abcd~=efgh~...'.length })).toEqual('abcd~=efgh...');\n    expect(truncate('abcd~=efgh~=ijklmn', { separator: '~=', length: 'abcd~=efgh...'.length })).toEqual('abcd~=efgh...');\n    expect(truncate('abcd~=efgh~=ijklmn', { separator: '~=', length: 'abcd~=efg...'.length })).toEqual('abcd...');\n  });\n\n  it('falls back to truncating anywhere if the string separator fails to find a match', () => {\n    expect(truncate('abcdefg', { separator: ' ', length: 5 })).toEqual('ab...');\n  });\n\n  it('can truncate using a regular expression separator', () => {\n    expect(truncate('abcd~=efgh~=ijklmn', { separator: /[~=]+/g, length: 'abcd~=efgh~=i...'.length })).toEqual('abcd~=efgh...');\n    expect(truncate('abcd~=efgh~=ijklmn', { separator: /[~=]+/g, length: 'abcd~=efgh~=...'.length })).toEqual('abcd~=efgh...');\n    expect(truncate('abcd~=efgh~=ijklmn', { separator: /[~=]+/g, length: 'abcd~=efgh~...'.length })).toEqual('abcd~=efgh...');\n    expect(truncate('abcd~=efgh~=ijklmn', { separator: /[~=]+/g, length: 'abcd~=efgh...'.length })).toEqual('abcd~=efgh...');\n    expect(truncate('abcd~=efgh~=ijklmn', { separator: /[~=]+/g, length: 'abcd~=efg...'.length })).toEqual('abcd...');\n  });\n\n  it('falls back to truncating anywhere if the regular expression separator fails to find a match', () => {\n    expect(truncate('abcdefg', { separator: / /g, length: 5 })).toEqual('ab...');\n  });\n});\n"},{"name":"unescape","manifest":{"fnSignature":"_.unescape(string)","lodashLink":"https://lodash.com/docs/4.17.15#unescape","summaryHtml":"<p>The inverse of _.escape; this method converts the HTML entities &amp;, &lt;, &gt;, &quot;, and &#39; in string to their corresponding characters.</p>"},"descriptionHtml":"<p>If you wish to unescape all HTML-encoded characters and you're in a browser environment, you can use the following:</p>\n<pre><code class=\"javascript language-javascript\">function unescapeHtmlChars(string) {\n  const doc = new DOMParser().parseFromString(string, 'text/html');\n  return doc.documentElement.textContent;\n}\n</code></pre>\n<p>If your JavaScript is not running in a browser, you can instead use a library such as <a href=\"https://www.npmjs.com/package/jsdom\">jsdom</a> to mimic the DOM and provide the same kind of API, or you can use a lighter-weight package that only provides this HTML-character-unescaping functionality and nothing else, such as <a href=\"https://www.npmjs.com/package/html-entities\">html-entities</a>.</p>\n<p>Lodash's <code>_.unescape()</code> function does not unescape all HTML characters, only those that get escaped when using <code>_.escape()</code>, which means using its implementation would be insufficient in most situations. Nevertheless, if you are wanting an implementation like Lodash's, you can use the following:</p>\n<pre><code class=\"javascript language-javascript\">function unescapeHtmlChars(string) {\n  // Unecoding \"&amp;\" needs to be done last.\n  // If it is done first, something like \"&amp;amp;lt;\" would incorrectly\n  // get unencoded to \"&lt;\", when it should be \"&amp;lt;\"\n  return string\n    .replaceAll('&amp;lt;', '&lt;')\n    .replaceAll('&amp;gt;', '&gt;')\n    .replaceAll('&amp;quot;', '\"')\n    .replaceAll('&amp;#39;', \"'\")\n    .replaceAll('&amp;amp;', '&amp;');\n}\n</code></pre>\n<h2>Don't use unescapeHtmlChars() unless you have to</h2>\n<p>The use of <code>unescapeHtmlChars()</code> may (or may not) indicate an issue with how you're storing and transfering data. Escaping HTML characters is an operation that is generally done the moment before you insert it into your page. If this pattern is followed, you will generally have an unescaped version of your string on-hand as well, which removes the need for using an <code>unescapeHtmlChars()</code> function. <a href=\"https://security.stackexchange.com/questions/32394/when-to-escape-user-input/32396#32396\">Further information about when to escape your HTML characters</a>.</p>","src":null,"test":"function unescapeHtmlChars(string) {\n  // Unecoding \"&\" needs to be done last.\n  // If it is done first, something like \"&amp;lt;\" would incorrectly\n  // get unencoded to \"<\", when it should be \"&lt;\"\n  return string\n    .replaceAll('&lt;', '<')\n    .replaceAll('&gt;', '>')\n    .replaceAll('&quot;', '\"')\n    .replaceAll('&#39;', \"'\")\n    .replaceAll('&amp;', '&');\n}\n\ndescribe('unescape()', () => {\n  it('unescapes all characters', () => {\n    const res = unescapeHtmlChars('&amp;&lt;&gt;&quot;&#39;');\n    expect(res).toEqual('&<>\"\\'');\n  });\n\n  it('unescapes all instances', () => {\n    const res = unescapeHtmlChars('&amp;&lt;&amp;&lt;&amp;');\n    expect(res).toEqual('&<&<&');\n  });\n\n  it(\"doesn't panic on the empty string\", () => {\n    expect(unescapeHtmlChars('')).toEqual('');\n  });\n\n  it('does not double-unescape characters', () => {\n    const res = unescapeHtmlChars('&amp;lt;');\n    // Should equal \"&lt;\", not \"<\"\n    expect(res).toEqual('&lt;');\n  });\n});\n"},{"name":"upperCase","manifest":{"fnSignature":"_.upperCase(string)","lodashLink":"https://lodash.com/docs/4.17.15#upperCase","summaryHtml":"<p>Converts <code>string</code>, as space separated words, to upper case.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function upperCase(string) {\n  const words = string.split(/\\s+/);\n  return words.map(word =&gt; word.toUpperCase()).join(' ');\n}\n</code></pre>\n<p>The above generates the word list by simply splitting on whitespace characters. Refer to <a href=\"#!/nolodash/words\">the entry for <code>_.words()</code></a> for alternative ways to extract words from text (which includes information on dealing with different languages).</p>\n<p>If you need to support internationalization, swap <code>.toUpperCase()</code> with <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleUpperCase\"><code>.toLocalUpperCase()</code></a>, and, if needed, provide the target language as an argument to these functions. This solution isn't perfect - read <a href=\"https://stackoverflow.com/a/53930826/7696223\">this great post for a more nuanced exploration on internationalization and casing</a>.</p>\n<p>For reference, Lodash's algorithm is implemented roughly as follows:</p>\n<ul>\n<li><a href=\"#!/nolodash/deburr\">Deburr</a> the string (which mostly means that accent marks are removed from characters).</li>\n<li>Removes apostrophes (the ' and  characters).</li>\n<li>Split the string into words using the algorithm that powers <a href=\"#!/nolodash/words\"><code>_.words()</code></a>.</li>\n<li>upper case each word with <code>.toUpperCase()</code>.</li>\n</ul>","src":null,"test":"describe('upperCase()', () => {\n  function upperCase(string) {\n    const words = string.split(/\\s+/);\n    return words.map(word => word.toUpperCase()).join(' ');\n  }\n\n  it('converts the words from the supplied string into upper-case', () => {\n    expect(upperCase('HELLO    aWeSoMe\\nworld')).toEqual('HELLO AWESOME WORLD');\n  });\n\n  it('handles an empty string', () => {\n    expect(upperCase('')).toEqual('');\n  });\n});\n"},{"name":"upperFirst","manifest":{"fnSignature":"_.upperFirst(string)","lodashLink":"https://lodash.com/docs/4.17.15#upperFirst","summaryHtml":"<p>Converts the first character of <code>string</code> to upper case.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function upperFirst([first = '', ...rest]) {\n  return first.toUpperCase() + rest.join('');\n}\n</code></pre>\n<p>The above implementation is carefully implemented to rely on the iterator protocol to split the string into separate characters (destructuring syntax uses the iterator protocol under the hood). This is done because iteration will properly split a string into characters while string indexing and slicing can cause you to accidentally split a string in between a character (e.g. <code>const firstChar = ''[0];</code> produces an invalid character while <code>const [firstChar] = '';</code> will properly retrieve the first character as <code></code>).</p>\n<p>If you need to support internationalization, swap <code>.toUpperCase()</code> with <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleUpperCase\"><code>.toLocalUpperCase()</code></a>, and, if needed, provide the target language as an argument. This solution isn't perfect - read <a href=\"https://stackoverflow.com/a/53930826/7696223\">this great post for a more nuanced exploration on internationalization and casing</a>.</p>","src":null,"test":"describe('upperFirst()', () => {\n  function upperFirst([first = '', ...rest]) {\n    return first.toUpperCase() + rest.join('');\n  }\n\n  it('It only converts the first character to upper case', () => {\n    expect(upperFirst('a b C')).toEqual('A b C');\n  });\n\n  it('does not touch the string if the first character can not be converted to upper-case', () => {\n    expect(upperFirst('+a')).toEqual('+a');\n  });\n\n  it('works on empty strings', () => {\n    expect(upperFirst('')).toEqual('');\n  });\n\n  // I would have a test case that shows how it can properly uppercase a multi-code-unit character,\n  // but I'm not actually aware of any specific scenarios that would show the different.\n  // Upper casing an entire character vs upper casing the first first part of a character usually yields the same results,\n  // but languages are weird, and I'm sure there's scenarios where the two differ.\n});\n"},{"name":"words","manifest":{"fnSignature":"_.words(string)","lodashLink":"https://lodash.com/docs/4.17.15#words","summaryHtml":"<p>Splits <code>string</code> into an array of its words.</p>"},"descriptionHtml":"<p>To split a string into words:</p>\n<pre><code class=\"javascript language-javascript\">string.split(' ')\n</code></pre>\n<p>The above will simply split the string on a single space. You can alternatively use one of these as an argument instead:</p>\n<ul>\n<li><code>/ +/</code> - split on one or more spaces. This will correctly split the string <code>\"a    b\"</code> into <code>[\"a\", \"b\"]</code>.</li>\n<li><code>/\\s+/</code> - split on one or more white-space characters (spaces, new lines, etc).</li>\n<li><code>/[^a-zA-Z0-9]+/</code> - split on any non-alpha-numeric text.</li>\n</ul>\n<p>If you need a more robust solution that's language-sensitive, consider using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter\"><code>Intl.Segmenter</code></a> instead.</p>\n<pre><code class=\"javascript language-javascript\">const str = '';\nconst segmenterJa = new Intl.Segmenter('ja-JP', { granularity: 'word' });\n\nconsole.log(\n  [...segmenterJa.segment(str)]\n    .filter(segmentInfo =&gt; segmentInfo.isWordLike)\n    .map(segmentInfo =&gt; segmentInfo.segment),\n);\n// =&gt; ['', '', '', '', '', '', '', '']\n</code></pre>\n<p>Lodash attempts to get fancy with how it determines whether or not something should be considered a word or not, but it doesn't do as good of a job as <code>Intl.Segmenter()</code> (which wasn't available when Lodash was being created). As always, remember that language is messy and even <code>Intl.Segmenter()</code> isn't a perfect solution, but it is the best option that's natively available.</p>\n<p>Lodash also lets you define what a word is via a pattern argument to <code>_.words()</code>. Using the pattern argument is really the same as doing <code>string.match(pattern) ?? []</code>. (This is different from doing <code>string.split(pattern)</code> in that the regular expression needs to define what characters are inside of a word, instead of defining what characters are between the words).</p>\n<pre><code class=\"javascript language-javascript\">'fred, barney, &amp; pebbles'.match(/[^, ]+/g) ?? []\n// =&gt; [ 'fred', 'barney', '&amp;', 'pebbles' ]\n</code></pre>","src":null,"test":""}]},{"categoryHeading":"Util","entries":[{"name":"attempt","manifest":{"fnSignature":"_.attempt(func, ...args)","lodashLink":"https://lodash.com/docs/4.17.15#attempt","summaryHtml":"<p>Attempts to invoke <code>func</code>, returning either the result or the caught error object. Any additional arguments are provided to <code>func</code> when it's invoked.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function attempt(func, ...args) {\n  try {\n    // Using .call() may be overkill.\n    // You could just do `return func(...args)` if you\n    // don't need to worry about preserving the \"this\" argument.\n    return func.call(...args);\n  } catch (error) {\n    return error instanceof Error ? error : new Error(error);\n  }\n}\n</code></pre>","src":null,"test":""},{"name":"bindAll","manifest":{"fnSignature":"_.bindAll(object, methodNames)","lodashLink":"https://lodash.com/docs/4.17.15#bindAll","summaryHtml":"<p>Binds methods of an object to the object itself, overwriting the existing method.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">function bindAll(object, methodNames) {\n  for (const method of methodNames) {\n    object[method] = object[method].bind(object);\n  }\n}\n</code></pre>","src":null,"test":""},{"name":"constant","manifest":{"fnSignature":"_.constant(value)","lodashLink":"https://lodash.com/docs/4.17.15#constant","summaryHtml":"<p>Creates a function that returns <code>value</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">() =&gt; value\n</code></pre>\n<p>The <code>_.constant()</code> method was created before arrow function syntax was standard, which meant it used to be a bit more verbose to accomplish this task without Lodash.</p>","src":null,"test":""},{"name":"defaultTo","manifest":{"fnSignature":"_.defaultTo(value, defaultValue)","lodashLink":"https://lodash.com/docs/4.17.15#defaultTo","summaryHtml":"<p>Checks <code>value</code> to determine whether a default value should be returned in its place. The <code>defaultValue</code> is returned if value is <code>NaN</code>, <code>null</code>, or <code>undefined</code>.</p>"},"descriptionHtml":"<p>The recommended way to fall back to a default value is the following:</p>\n<pre><code class=\"javascript language-javascript\">value ?? defaultValue\n</code></pre>\n<p>This will cause <code>defaultValue</code> to be used if <code>value</code> is either <code>null</code> or <code>undefined</code>. Unlike Lodash, it will <em>not</em> cause the <code>defaultValue</code> to be given when <code>NaN</code> is provided - this is a good thing, both <code>null</code> and <code>undefined</code> are used to represent the absent of a value while <code>NaN</code> is intended to represent an error in a numerical calculation. In typical scenarios you shouldn't expect <code>NaN</code> to fall back to a default value any more than you would expect an instance of <code>Error</code> to do that.</p>\n<p>If you are in a scenario where you are expecting an error in a numeric calculation (i.e. you're expecting to see <code>NaN</code>), and you would like to fall back to a default value if an error occurs, you can use the following:</p>\n<pre><code class=\"javascript language-javascript\">Number.isNaN(value) ? defaultValue : value\n</code></pre>","src":null,"test":""},{"name":"identity","manifest":{"fnSignature":"_.identity(value)","lodashLink":"https://lodash.com/docs/4.17.15#identity","summaryHtml":"<p>This method returns the first argument it receives.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">x =&gt; x\n</code></pre>\n<p>The <code>_.identity()</code> method was created before arrow function syntax was standard, which meant it used to be a lot more verbose to accomplish this task without Lodash.</p>","src":null,"test":""},{"name":"method","manifest":{"fnSignature":"_.method(path, ...args)","lodashLink":"https://lodash.com/docs/4.17.15#method","summaryHtml":"<p>Creates a function that invokes the method at <code>path</code> of a given object. Any additional arguments are provided to the invoked method.</p>"},"descriptionHtml":"<p>Instead of using <code>_.method()</code> to create a function, such as in this example:</p>\n<pre><code class=\"javascript language-javascript\">const callNestedFn = _.method(['subObj', 'fn']);\nconst obj = { subObj: { fn: () =&gt; 7 } };\n\ncallNestedFn(obj); // =&gt; 7\n</code></pre>\n<p>You can instead define your function with arrow function syntax, like this:</p>\n<pre><code class=\"javascript language-javascript\">const callNestedFn = obj =&gt; obj.subObj.fn();\nconst obj = { subObj: { fn: () =&gt; 7 } };\n\ncallNestedFn(obj); // =&gt; 7\n</code></pre>\n<p>If you're receiving property names dynamically and really do need a <code>_.method()</code>-like helper function, you can use the following:</p>\n<pre><code class=\"javascript language-javascript\">// This _.invoke() implementation is borrows from the _.invoke() doc entry.\nfunction invoke(object, path, ...args) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\"]+/).filter(x =&gt; x);\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return undefined;\n  }\n\n  if (tail.length === 0) {\n    return object[head](...args);\n  }\n\n  return invoke(object[head], tail, ...args);\n}\n\nfunction method(path, ...args) {\n  return object =&gt; invoke(object, path, ...args);\n}\n</code></pre>\n<p>Be aware that, like Lodash's <code>_.method()</code>, the above implementation doesn't do anything to guard against prototype look-ups, for example, <code>method('toString')({})</code> will work, and will return the string <code>'[object Object]'</code>. To guard against this, use <code>if (!(Object.hasOwn(head, object)))</code> instead of <code>if(!(head in object))</code>.</p>\n<p>One of the primary reasons Lodash's <code>_.method()</code> function was commonly used, was as a way to easily invoke a function nested in an object without having to worry about in-between fields being undefined. This is now possible today using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining\">optional chaining</a> (<code>?.</code>) whenever you suspect a property might be undefined.</p>\n<p>For example, these two are effectively the same:</p>\n<pre><code class=\"javascript language-javascript\">_.method('subObj.fn', 2, 4)(obj);\n\nobj?.subObj?.fn?.(2, 4);\n</code></pre>\n<p>Note that the support for string paths in the above <code>method()</code> implementation isn't very robust. It'll take invalid-looking input, such as <code>\"prop1.[prop2\"</code>, ignore the invalid parts, and attempt to work with it anyways. Lodash's <code>_.method()</code> isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.</p>","src":null,"test":""},{"name":"methodOf","manifest":{"fnSignature":"_.methodOf(object, ...args)","lodashLink":"https://lodash.com/docs/4.17.15#methodOf","summaryHtml":"<p>The opposite of <code>_.method</code>; this method creates a function that invokes the method at a given path of <code>object</code>. Any additional arguments are provided to the invoked method.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">// This _.invoke() implementation is borrows from the _.invoke() doc entry.\nfunction invoke(object, path, ...args) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\"]+/).filter(x =&gt; x);\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return undefined;\n  }\n\n  if (tail.length === 0) {\n    return object[head](...args);\n  }\n\n  return invoke(object[head], tail, ...args);\n}\n\nfunction methodOf(object, ...args) {\n  return path =&gt; invoke(object, path, ...args);\n}\n</code></pre>\n<p>Be aware that, like Lodash's <code>_.methodOf()</code>, the above implementation doesn't do anything to guard against prototype look-ups, for example, <code>methodOf({})('toString')</code> will work, and will return the string <code>'[object Object]'</code>. To guard against this, use <code>if (!(Object.hasOwn(head, object)))</code> instead of <code>if(!(head in object))</code>.</p>\n<p>Note that the support for string paths in the above <code>methodOf()</code> implementation isn't very robust. It'll take invalid-looking input, such as <code>\"prop1.[prop2\"</code>, ignore the invalid parts, and attempt to work with it anyways. Lodash's <code>_.methodOf()</code> isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.</p>","src":null,"test":""},{"name":"noop","manifest":{"fnSignature":"_.noop()","lodashLink":"https://lodash.com/docs/4.17.15#noop","summaryHtml":"<p>This method returns <code>undefined</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">() =&gt; {}\n</code></pre>\n<p>The <code>_.noop()</code> method was created before arrow function syntax was standard, which meant it used to be a bit more verbose to accomplish this task without Lodash.</p>","src":null,"test":""},{"name":"nthArg","manifest":{"fnSignature":"_.nthArg(n)","lodashLink":"https://lodash.com/docs/4.17.15#nthArg","summaryHtml":"<p>Creates a function that gets the argument at index <code>n</code>. If <code>n</code> is negative, the nth argument from the end is returned.</p>"},"descriptionHtml":"<p>In one-off situations, you can simply create a function to handle it:</p>\n<pre><code class=\"javascript language-javascript\">// Always returns the second argument\n(_, x) =&gt; x\n</code></pre>\n<pre><code class=\"javascript language-javascript\">// Always returns the fifth argument\n(...args) =&gt; args[4]\n</code></pre>\n<pre><code class=\"javascript language-javascript\">// Always returns the second-to-last argument\n(...args) =&gt; args.at(-2)\n</code></pre>\n<p>If you need a reusable function, you can use the following:</p>\n<pre><code class=\"javascript language-javascript\">function nthArg(n) {\n  return (...args) =&gt; args.at(n);\n}\n</code></pre>","src":null,"test":""},{"name":"range","manifest":{"fnSignature":"_.range(start?, end, step?)","lodashLink":"https://lodash.com/docs/4.17.15#range","summaryHtml":"<p>Creates an array of numbers (positive and/or negative) progressing from start up to, but not including, end.</p>"},"descriptionHtml":"<p>You can use <code>Array.from(...)</code> to generate arrays filled with a range of numbers. Some concrete examples:</p>\n<!-- eslint-disable @stylistic/space-infix-ops -->\n<pre><code class=\"javascript language-javascript\">// Same as _.range(5)\nArray.from({ length: 5 }, (_, i) =&gt; i) // =&gt; [0, 1, 2, 3, 4]\n\n// Same as _.range(2, 5)\nArray.from({ length: 3 }, (_, i) =&gt; 2 + i) // =&gt; [2, 3, 4]\n\n// Same as _.range(4, 10, 2)\nArray.from({ length: 3 }, (_, i) =&gt; 4 + i*2) // =&gt; [4, 6, 8]\n\n// Same as _.range(5, 3, -0.5)\nArray.from({ length: 4 }, (_, i) =&gt; 5 - i*0.5) // =&gt; [5, 4.5, 4, 3.5]\n</code></pre>\n<p>How it works: <code>Array.from()</code> expects an array-like (or an iterable) as the first argument and a mapping function as the second. <code>{ length: n }</code> is a valid array-like object that is of length <code>n</code> and has no elements in it. The mapping function receives, as the second argument, the current item number geing generated.</p>\n<p>Here's another way to accomplishing the same thing in a slightly different style:</p>\n<!-- eslint-disable @stylistic/space-infix-ops -->\n<pre><code class=\"javascript language-javascript\">// Same as _.range(4, 10, 2)\n// And the same as Array.from({ length: 3 }, (_, i) =&gt; 4 + i*2) // =&gt; [4, 6, 8]\nnew Array(3).fill().map((_, i) =&gt; 4 + i*2) // =&gt; [4, 6, 8]\n</code></pre>\n<p><code>new Array(n)</code> creates array holes, which are an emptiness state that is different from <code>undefined</code> and <code>null</code>, that have an inconsistent iteration behavior - some array methods treat holes like <code>undefined</code> and others will skip over them entirely. Because of this, it is generally advisable to avoid array holes and <code>new Array(n)</code>. The use of <code>.fill()</code> right after <code>new Array(n)</code> will cause the array holes to immediately be plugged with <code>undefined</code>, fixing the problem. If you want to be strict about avoiding array holes, then you may want to avoid this solution, preferring to instead use the <code>Array.from()</code> solution. Alternatively, you may see <code>new Array(n).fill()</code> as an acceptable exception to the \"avoid array holes\" guidelines and be ok with this solution.</p>\n<p>You can also use the following if you want a more complete helper function that does the math for you. Feel free to remove any pieces of this function that you don't currently need.</p>\n<pre><code class=\"javascript language-javascript\">function range(...args) {\n  // Adds support for passing in a single argument.\n  if (args.length === 1) {\n    const end = args[0];\n    return range(0, end);\n  }\n  const [start, end, step = 1] = args;\n\n  // A couple of checks to prevent accidental infinite loops.\n  // Number.isFinite() is making sure the values are numbers, and they aren't NaN or Infinity.\n  if (step === 0 || ![start, end, step].every(n =&gt; Number.isFinite(n))) {\n    throw new Error('Received an invalid argument.');\n  }\n\n  const result = [];\n  if (step &gt; 0) {\n    for (let i = start; i &lt; end; i += step) {\n      result.push(i);\n    }\n  } else {\n    for (let i = start; i &gt; end; i += step) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n</code></pre>\n<p>This implementation isn't exactly the same as Lodash's in that if you call <code>range()</code> with a single, negative argument, Lodash will produce a range that counts down to it. To keep things a little simpler, the above implementation won't automatically swap to a step of -1, and will instead return the empty array.</p>\n<p>There is <a href=\"https://github.com/tc39/proposal-iterator.range\">an upcoming \"iterator range\" proposal</a> that will introduce a native range function.</p>","src":null,"test":"function range(...args) {\n  // Adds support for passing in a single argument.\n  if (args.length === 1) {\n    const end = args[0];\n    return range(0, end);\n  }\n  const [start, end, step = 1] = args;\n\n  // A couple of checks to prevent accidental infinite loops.\n  // Number.isFinite() is making sure the values are numbers, and they aren't NaN or Infinity.\n  if (step === 0 || ![start, end, step].every(n => Number.isFinite(n))) {\n    throw new Error('Received an invalid argument.');\n  }\n\n  const result = [];\n  if (step > 0) {\n    for (let i = start; i < end; i += step) {\n      result.push(i);\n    }\n  } else {\n    for (let i = start; i > end; i += step) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\ndescribe('range()', () => {\n  it('treats a single argument as the stop argument', () => {\n    expect(range(5)).toEqual([0, 1, 2, 3, 4]);\n  });\n\n  it('accepts floats as a single argument', () => {\n    expect(range(4.5)).toEqual([0, 1, 2, 3, 4]);\n  });\n\n  it('returns an empty array when given a non-positive single argument', () => {\n    expect(range(0)).toEqual([]);\n    expect(range(-5)).toEqual([]);\n  });\n\n  it('can accept a start and stop argument', () => {\n    expect(range(2, 5)).toEqual([2, 3, 4]);\n  });\n\n  it('can accept a start, stop, and step argument', () => {\n    expect(range(4, 10, 2)).toEqual([4, 6, 8]);\n  });\n\n  it('can iterate backwards', () => {\n    expect(range(5, 2, -1)).toEqual([5, 4, 3]);\n  });\n\n  it('can iterate over floats', () => {\n    expect(range(3, 5, 0.5)).toEqual([3, 3.5, 4, 4.5]);\n  });\n\n  it('return an empty array if the step is pointed in the wrong direction', () => {\n    expect(range(2, 4, -1)).toEqual([]);\n    expect(range(4, 2)).toEqual([]);\n  });\n\n  it('return an empty array if the stop is already at the start', () => {\n    expect(range(4, 4)).toEqual([]);\n    expect(range(4, 4, -1)).toEqual([]);\n  });\n\n  it('throws when any of the arguments are not a finite number', () => {\n    expect(() => range(-Infinity)).toThrow('invalid argument');\n    expect(() => range(NaN)).toThrow('invalid argument');\n    expect(() => range('23')).toThrow('invalid argument');\n\n    expect(() => range(Infinity, 5, 2)).toThrow('invalid argument');\n    expect(() => range(2, NaN, 3)).toThrow('invalid argument');\n    expect(() => range(1, 2, '23')).toThrow('invalid argument');\n  });\n});\n"},{"name":"rangeRight","manifest":{"fnSignature":"_.rangeRight(start?, end, step?)","lodashLink":"https://lodash.com/docs/4.17.15#rangeRight","summaryHtml":"<p>This method is like <code>_.range</code> except that it populates values in descending order.</p>"},"descriptionHtml":"<p>Refer to <a href=\"#!/nolodash/range\">the _.range() documentation entry</a> for various techniques on producing a range of values. Then call <code>.toReversed()</code> on the result to reverse the range.</p>","src":null,"test":""},{"name":"stubArray","manifest":{"fnSignature":"_.stubArray()","lodashLink":"https://lodash.com/docs/4.17.15#stubArray","summaryHtml":"<p>This method returns a new empty array.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">() =&gt; []\n</code></pre>\n<p>The <code>_.stubArray()</code> method was created before arrow function syntax was standard, which meant it used to be a lot more verbose to accomplish this task without Lodash.</p>","src":null,"test":""},{"name":"stubFalse","manifest":{"fnSignature":"_.stubFalse()","lodashLink":"https://lodash.com/docs/4.17.15#stubFalse","summaryHtml":"<p>This method returns <code>false</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">() =&gt; false\n</code></pre>\n<p>The <code>_.stubFalse()</code> method was created before arrow function syntax was standard, which meant it used to be a lot more verbose to accomplish this task without Lodash.</p>","src":null,"test":""},{"name":"stubObject","manifest":{"fnSignature":"_.stubObject()","lodashLink":"https://lodash.com/docs/4.17.15#stubObject","summaryHtml":"<p>This method returns a new empty object.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">() =&gt; ({})\n</code></pre>\n<p>Remember that when arrow functions return an object without explicitly using the <code>return</code> keyword, you must wrap the object in parentheses to distinguish it from a block of code (<code>() =&gt; {}</code> is interpreted as an arrow function with an empty body, which is not the same thing as an arrow function that returns an object).</p>\n<p>The <code>_.stubObject()</code> method was created before arrow function syntax was standard, which meant it used to be a lot more verbose to accomplish this task without Lodash.</p>","src":null,"test":""},{"name":"stubString","manifest":{"fnSignature":"_.stubString()","lodashLink":"https://lodash.com/docs/4.17.15#stubString","summaryHtml":"<p>This method returns an empty string.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">() =&gt; ''\n</code></pre>\n<p>The <code>_.stubString()</code> method was created before arrow function syntax was standard, which meant it used to be a lot more verbose to accomplish this task without Lodash.</p>","src":null,"test":""},{"name":"stubTrue","manifest":{"fnSignature":"_.stubTrue()","lodashLink":"https://lodash.com/docs/4.17.15#stubTrue","summaryHtml":"<p>This method returns <code>true</code>.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">() =&gt; true\n</code></pre>\n<p>The <code>_.stubTrue()</code> method was created before arrow function syntax was standard, which meant it used to be a lot more verbose to accomplish this task without Lodash.</p>","src":null,"test":""},{"name":"times","manifest":{"fnSignature":"_.times(n, iteratee)","lodashLink":"https://lodash.com/docs/4.17.15#times","summaryHtml":"<p>Invokes the iteratee <code>n</code> times, returning an array of the results of each invocation.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">Array.from({ length: n }, (_, i) =&gt; iteratee(i))\n\n// Concrete example:\nArray.from({ length: 5 }, (_, i) =&gt; i * 10) // =&gt; [0, 10, 20, 30, 40]\n</code></pre>\n<p>How it works: <code>Array.from()</code> expects an array-like (or an iterable) as the first argument and a mapping function as the second. <code>{ length: n }</code> is a valid array-like object that is of length <code>n</code> and has no elements in it. The mapping function receives, as the second argument, the current item number geing generated.</p>\n<p>Here's another way to accomplishing the same thing in a slightly different style:</p>\n<pre><code class=\"javascript language-javascript\">new Array(n).fill().map((_, i) =&gt; iteratee(i)) // =&gt; [1, 2, 3, 4, 5]\n</code></pre>\n<p><code>new Array(n)</code> creates array holes, which are an emptiness state that is different from <code>undefined</code> and <code>null</code>, that have an inconsistent iteration behavior - some array methods treat holes like <code>undefined</code> and others will skip over them entirely. Because of this, it is generally advisable to avoid array holes and <code>new Array(n)</code>. The use of <code>.fill()</code> right after <code>new Array(n)</code> will cause the array holes to immediately be plugged with <code>undefined</code>, fixing the problem. If you want to be strict about avoiding array holes, then you may want to avoid this solution, preferring to instead use the <code>Array.from()</code> solution. Alternatively, you may see <code>new Array(n).fill()</code> as an acceptable exception to the \"avoid array holes\" guidelines and be ok with this solution.</p>","src":null,"test":""},{"name":"uniqueId","manifest":{"fnSignature":"_.uniqueId(prefix?)","lodashLink":"https://lodash.com/docs/4.17.15#uniqueId","summaryHtml":"<p>Generates a unique ID. If prefix is given, the ID is appended to it.</p>"},"descriptionHtml":"<pre><code class=\"javascript language-javascript\">let nextId = 1;\nfunction uniqueId(prefix = '') {\n  return prefix + String(nextId++);\n}\n</code></pre>","src":null,"test":""}]}]