[{"categoryHeading":"Array","entries":[{"name":"chunk","manifest":{"fnSignature":"_.chunk(array, size?)","lodashLink":"https://lodash.com/docs/4.17.15#chunk","summary":"Creates an array of elements split into groups the length of `size`. If `array` can't be split evenly, the final chunk will be the remaining elements."},"description":"```javascript\nfunction chunk(array, size = 1) {\n  const result = [];\n  for (let i = 0; i < array.length; i += size) {\n    result.push(array.slice(i, i + size));\n  }\n  return result;\n}\n```\n","src":null,"test":""},{"name":"compact","manifest":{"fnSignature":"_.compact(array)","lodashLink":"https://lodash.com/docs/4.17.15#compact","summary":"Creates an array with all falsey values removed. The values `false`, `null`, `0`, `\"\"`, `undefined`, and `NaN` are falsey."},"description":"All of these solutions are equivalent. Pick the one you find to be the most readable.\n\n```javascript\narray.filter(value => !!value);\n\narray.filter(value => value);\n\narray.filter(Boolean);\n```\n","src":null,"test":""},{"name":"concat","manifest":{"fnSignature":"_.concat(array, ...values)","lodashLink":"https://lodash.com/docs/4.17.15#concat","summary":"Creates a new array concatenating `array` with any additional arrays and/or values."},"description":"```javascript\nconst result = [...array1, ...array2, ...array3];\n```\n\nThis solution above only works on arrays and other iterables. If some of your values might not be arrays, you can use the native `.concat()` method instead.\n\n```javascript\nconst array1 = [1, 2, 3];\nconst value1 = 4;\nconst array2 = [5, 6, 7];\n\nconst result = array1.concat(value1, array2);\n\n// Expected output: [1, 2, 3, 4, 5, 6, 7]\n```\n","src":null,"test":""},{"name":"difference","manifest":{"fnSignature":"_.difference(array, values?)","lodashLink":"https://lodash.com/docs/4.17.15#difference","summary":"Creates an array of `array` values not included in the other given arrays using `SameValueZero` for equality comparisons. The order and references of result values are determined by the first array."},"description":"To subtract everything in array2 from array1, use the following:\n\n```javascript\narray1.filter(x => !array2.includes(x));\n```\n\nRemember that `.includes()` has an `O(n)` lookup time. If you're dealing with larger arrays, make sure to convert the target array into a set first (a set's `.has()` method has `O(1)` lookup time).\n\n```javascript\nconst set2 = new Set(array2);\nconst result = array1.filter(x => !set2.has(x));\n```\n\nBoth `array.includes()` and `set.has()` use [the SameValueZero comparison algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality) under-the-hood as well, just like Lodash's `_.difference()`.\n","src":null,"test":""},{"name":"differenceBy","manifest":{"fnSignature":"_.differenceBy(array, values?, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#differenceBy","summary":"This method is like `_.difference` except that it accepts `iteratee` which is invoked for each element of `array` and `values` to generate the criterion by which they're compared. The order and references of result values are determined by the first array."},"description":"```javascript\nfunction differenceBy(array, values, iteratee) {\n  const transformedValues = new Set(values.map(x => iteratee(x)));\n  return array.filter(x => !transformedValues.has(iteratee(x)));\n}\n```\n","src":null,"test":""},{"name":"differenceWith","manifest":{"fnSignature":"_.differenceWith(array, values?, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#differenceWith","summary":"This method is like `_.difference` except that it accepts `comparator` which is invoked to compare elements of `array` to `values`."},"description":"```javascript\nfunction differenceWith(array, values, comparator) {\n  return array.filter(x => !values.some(y => comparator(x, y)));\n}\n```\n","src":null,"test":""},{"name":"drop","manifest":{"fnSignature":"_.drop(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#drop","summary":"Creates a slice of `array` with `n` elements dropped from the beginning."},"description":"```javascript\narray.slice(n)\n```\n","src":null,"test":""},{"name":"dropRight","manifest":{"fnSignature":"_.dropRight(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#dropRight","summary":"Creates a slice of `array` with `n` elements dropped from the end."},"description":"```javascript\narray.slice(0, -n)\n```\n\nYou do have to watch out for the zero case. `_.dropRight(0)` will return the whole array, while, `array.slice(0, -0)` will return an empty array.\n","src":null,"test":""},{"name":"dropRightWhile","manifest":{"fnSignature":"_.dropRightWhile(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#dropRightWhile","summary":"Creates a slice of `array` excluding elements dropped from the end. Elements are dropped until `predicate` returns falsey."},"description":"```javascript\nfunction dropRightWhile(array, predicate) {\n  const index = array.findLastIndex((...args) => !predicate(...args))\n  if (index === -1) {\n    return [];\n  }\n\n  return array.slice(0, index + 1);\n}\n```","src":null,"test":""},{"name":"dropWhile","manifest":{"fnSignature":"_.dropWhile(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#dropWhile","summary":"Creates a slice of `array` excluding elements dropped from the beginning. Elements are dropped until `predicate` returns falsey."},"description":"```javascript\nfunction dropWhile(array, predicate) {\n  const index = array.findIndex((...args) => !predicate(...args))\n  if (index === -1) {\n    return [];\n  }\n\n  return array.slice(index);\n}\n```","src":null,"test":""},{"name":"fill","manifest":{"fnSignature":"_.fill(array, value, start?, end?)","lodashLink":"https://lodash.com/docs/4.17.15#fill","summary":"Fills elements of `array` with `value` from `start` up to, but not including, `end`."},"description":"```javascript\narray.fill(value, start, end);\n```\n\nThe `start` and `end` parameters are optional.\n","src":null,"test":""},{"name":"findIndex","manifest":{"fnSignature":"_.findIndex(array, predicate?, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#findIndex","summary":"This method is like `_.find` except that it returns the index of the first element `predicate` returns truthy for instead of the element itself."},"description":"```javascript\narray.findIndex(predicate);\n```\n\nIf you need to start from a particular index, a simple solution is to check which index you're at inside your predicate. In this example, we'll look for the first non-null element that exists at index 5 or greater.\n\n```javascript\narray.findIndex((value, i) => i >= 5 && value !== null);\n```\n\nIf you need to start from a particular index, and you're dealing with larger arrays, you may just need to build your own `findIndex` function from a simple for loop, in order to help with performance.\n","src":null,"test":""},{"name":"findLastIndex","manifest":{"fnSignature":"_.findLastIndex(array, predicate?, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#findLastIndex","summary":"This method is like `_.findIndex` except that it iterates over elements of `collection` from right to left."},"description":"```javascript\narray.findLastIndex(predicate);\n```\n\nIf you need to start from a particular index, a simple solution is to check which index you're at inside your predicate. In this example, we'll look for the first non-null element that exists at index 5 or earlier.\n\n```javascript\narray.findLastIndex((value, i) => i <= 5 && value !== null);\n```\n\nIf you need to start from a particular index, and you're dealing with larger arrays, you may just need to build your own `findLastIndex` function from a simple for loop, in order to help with performance.\n","src":null,"test":""},{"name":"flatten","manifest":{"fnSignature":"_.flatten(array)","lodashLink":"https://lodash.com/docs/4.17.15#flatten","summary":"Flattens `array` a single level deep."},"description":"```javascript\narray.flat();\n```\n","src":null,"test":""},{"name":"flattenDeep","manifest":{"fnSignature":"_.flattenDeep(array)","lodashLink":"https://lodash.com/docs/4.17.15#flattenDeep","summary":"Recursively flattens `array`."},"description":"```javascript\narray.flat(Infinity);\n```\n","src":null,"test":""},{"name":"flattenDepth","manifest":{"fnSignature":"_.flattenDepth(array, depth?)","lodashLink":"https://lodash.com/docs/4.17.15#flattenDeep","summary":"Recursively flatten `array` up to `depth` times."},"description":"```javascript\narray.flat(depth);\n```\n","src":null,"test":""},{"name":"fromPairs","manifest":{"fnSignature":"_.fromPairs(pairs)","lodashLink":"https://lodash.com/docs/4.17.15#fromPairs","summary":"The inverse of `_.toPairs`; this method returns an object composed from key-value `pairs`."},"description":"```javascript\nObject.fromEntries(pairs);\n```\n","src":null,"test":""},{"name":"head","manifest":{"fnSignature":"_.head(array)","lodashLink":"https://lodash.com/docs/4.17.15#head","summary":"Gets the first element of `array`."},"description":"```javascript\narray[0];\n```\n","src":null,"test":""},{"name":"indexOf","manifest":{"fnSignature":"_.indexOf(array, value, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#indexOf","summary":"Gets the index at which the first occurrence of `value` is found in `array` using `SameValueZero` for equality comparisons. If `fromIndex` is negative, it's used as the offset from the end of array."},"description":"```javascript\narray.findIndex(x => x === value);\n```\n\nIf you need to start from a particular index, a simple solution is to check which index you're at inside your predicate. In this example, we'll look for the index of the first `42` that exists at index 5 or greater.\n\n```javascript\narray.findIndex((value, i) => i >= 5 && value === 42);\n```\n\nIf you need to start from a particular index, and you're dealing with larger arrays, you may just need to build your own `findIndex` function using a simple for loop, in order to help with performance.\n\nIf you wish to perform comparisons using [the SameValueZero algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality), similar to how Lodash does it, you can use this helper function:\n\n```javascript\nfunction sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) && Number.isNaN(y));\n}\n```\n","src":null,"test":""},{"name":"initial","manifest":{"fnSignature":"_.initial(array)","lodashLink":"https://lodash.com/docs/4.17.15#initial","summary":"Gets all but the last element of `array`."},"description":"```javascript\narray.slice(0, -1)\n```\n","src":null,"test":""},{"name":"intersection","manifest":{"fnSignature":"_.intersection(...arrays)","lodashLink":"https://lodash.com/docs/4.17.15#intersection","summary":"Creates an array of unique values that are included in all given arrays using `SameValueZero` for equality comparisons."},"description":"To take the intersection of array1 and array2, use the following:\n\n```javascript\narray1.filter(x => array2.includes(x));\n```\n\nIf you also wish to remove duplicate elements from the final result, the same way `_.intersection()` does, you can use a set, like so:\n\n```javascript\nconst resultWithDuplicates = array1.filter(x => array2.includes(x));\nconst resultWithoutDuplicates = [...new Set(resultWithDuplicates)];\n```\n\nRemember that `.includes()` has an `O(n)` lookup time. If you're dealing with larger arrays, make sure to convert the second array into a set (a set's `.has()` method has `O(1)` lookup time).\n\n```javascript\nconst set2 = new Set(array2);\nconst resultWithDuplicates = array1.filter(x => set2.has(x));\n```\n\nBoth `array.includes()` and `set.has()` use [the SameValueZero comparison algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality) under-the-hood as well, just like Lodash's `_.intersection()`.\n\nThere is [an upcoming proposal](https://github.com/tc39/proposal-set-methods) that will introduce a native `.intersection()` method for sets.\n","src":null,"test":""},{"name":"intersectionBy","manifest":{"fnSignature":"_.intersectionBy(...arrays, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#intersectionBy","summary":"This method is like `_.intersection` except that it accepts `iteratee` which is invoked for each element of each `arrays` to generate the criterion by which they're compared."},"description":"```javascript\nfunction intersectionBy(array1, array2, iteratee = x => x) {\n  const result = [];\n  const resultTransformed = new Set();\n  const array2Transformed = new Set(array2.map(x => iteratee(x)));\n  for (const element of array1) {\n    const transformedElement = iteratee(element);\n    const isInIntersection = (\n      !resultTransformed.has(transformedElement)\n      && array2Transformed.has(transformedElement)\n    );\n\n    if (isInIntersection) {\n      result.push(element);\n      resultTransformed.add(transformedElement);\n    }\n  }\n\n  return result;\n}\n```\n\nIf you know that `array1` doesn't contain duplicate elements, or you don't care if duplicate elements from `array1` end up in the final result, then this implementation will achieve the same effect:\n\n```javascript\nfunction intersectionBy(array1, array2, iteratee = x => x) {\n  const array2Transformed = new Set(array2.map(x => iteratee(x)));\n  return array1.filter(x => array2Transformed.has(iteratee(x)));\n}\n```\n","src":null,"test":""},{"name":"intersectionWith","manifest":{"fnSignature":"_.intersectionWith(...arrays, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#intersectionWith","summary":"This method is like `_.intersection` except that it accepts `comparator` which is invoked to compare elements of `arrays`."},"description":"```javascript\nfunction intersectionWith(array1, array2, comparator) {\n  const result = [];\n  for (const element of array1) {\n    const isInIntersection = (\n      !result.some(x => comparator(x, element))\n      && array2.some(x => comparator(x, element))\n    );\n\n    if (isInIntersection) {\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n```\n\nIf you know that `array1` doesn't contain duplicate elements, or you don't care if duplicate elements from `array1` end up in the final result, then this implementation will achieve the same effect:\n\n```javascript\nfunction intersectionWith(array1, array2, comparator) {\n  return array1.filter(x => array2.some(y => comparator(x, y)));\n}\n```\n","src":null,"test":""},{"name":"join","manifest":{"fnSignature":"_.join(array, separator?)","lodashLink":"https://lodash.com/docs/4.17.15#join","summary":"Converts all elements in `array` into a string separated by `separator`."},"description":"```javascript\narray.join(separator);\n```\n","src":null,"test":""},{"name":"last","manifest":{"fnSignature":"_.last(array)","lodashLink":"https://lodash.com/docs/4.17.15#last","summary":"Gets the last element of `array`."},"description":"```javascript\narray.at(-1);\n```\n","src":null,"test":""},{"name":"lastIndexOf","manifest":{"fnSignature":"_.lastIndexOf(array, value, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#lastIndexOf","summary":"This method is like `_.indexOf` except that it iterates over elements of `array` from right to left."},"description":"```javascript\narray.findLastIndex(x => x === value);\n```\n\nIf you need to start from a particular index, a simple solution is to check which index you're at inside your predicate. In this example, we'll look for the index of the last `42` that exists at index 5 or lower.\n\n```javascript\narray.findLastIndex((value, i) => i <= 5 && value === 42);\n```\n\nIf you need to start from a particular index, and you're dealing with larger arrays, you may just need to build your own `findLastIndex` function using a simple for loop, in order to help with performance.\n\nIf you wish to perform comparisons using [the SameValueZero algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality), similar to how Lodash does it, you can use this helper function:\n\n```javascript\nfunction sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) && Number.isNaN(y));\n}\n```\n","src":null,"test":""},{"name":"nth","manifest":{"fnSignature":"_.nth(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#nth","summary":"Gets the element at index `n` of `array`. If `n` is negative, the nth element from the end is returned."},"description":"```javascript\narray[n];\n```\n\nOr, if you need support for negative indices:\n\n```javascript\narray.at(n);\n```\n","src":null,"test":""},{"name":"pull","manifest":{"fnSignature":"_.pull(array, ...values)","lodashLink":"https://lodash.com/docs/4.17.15#pull","summary":"Removes all given values from `array` using `SameValueZero` for equality comparisons. Note: Unlike `_.without`, this method mutates `array`."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following `filterInPlace()` helper can be used to achieve the desired result in `O(n)` time.\n\n```javascript\nfunction filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\n// Pull everything out from `array` that equals `targetValue`.\nconst result = filterInPlace(array, x => x === targetValue);\n```\n\nIf you wish to perform comparisons using [the SameValueZero algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality), similar to how Lodash does it, you can use this helper function:\n\n```javascript\nfunction sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) && Number.isNaN(y));\n}\n```\n\nSee the `_.pullAll()` entry if you have multiple items you wish to pull at once.\n","src":null,"test":""},{"name":"pullAll","manifest":{"fnSignature":"_.pullAll(array, values)","lodashLink":"https://lodash.com/docs/4.17.15#pullAll","summary":"This method is like `_.pull` except that it accepts an array of values to remove."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following `filterInPlace()` helper can be used to achieve the desired result in `O(n)` time.\n\n```javascript\nfunction filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\n// Pull everything in the `values` array from `array`.\nconst result = filterInPlace(array, x => values.include(x));\n```\n\nRemember that the `values.includes()` used at the end also has an `O(n)` lookup time. If you're dealing with a larger `values` array, make sure to convert it into a set first (a set's `.has()` method has `O(1)` lookup time).\n\nBoth `array.includes()` and `set.has()` use [the SameValueZero comparison algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality) under-the-hood as well, just like Lodash's `_.pull()`.\n","src":null,"test":""},{"name":"pullAllBy","manifest":{"fnSignature":"_.pullAllBy(array, values, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#pullAllBy","summary":"This method is like `_.pullAll` except that it accepts `iteratee` which is invoked for each element of `array` and `values` to generate the criterion by which they're compared."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following `filterInPlace()` helper can be used to achieve the desired result in `O(n)` time.\n\n```javascript\nfunction filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\nfunction pullAllBy(array, values, iteratee) {\n  const transformedValues = new Set(values.map(x => iteratee(x)));\n  filterInPlace(array, x => !transformedValues.has(iteratee(x)));\n}\n```\n","src":null,"test":""},{"name":"pullAllWith","manifest":{"fnSignature":"_.pullAllWith(array, values, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#pullAllWith","summary":"This method is like `_.pullAll` except that it accepts `comparator` which is invoked to compare elements of `array` to `values`."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following `filterInPlace()` helper can be used to achieve the desired result.\n\n```javascript\nfunction filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\nfunction pullAllWith(array, values, comparator) {\n  filterInPlace(array, x => !values.some(y => comparator(x, y)));\n}\n```\n","src":null,"test":""},{"name":"pullAt","manifest":{"fnSignature":"_.pullAt(array, indexes?)","lodashLink":"https://lodash.com/docs/4.17.15#pullAt","summary":"Removes elements from `array` corresponding to `indexes` and returns an array of removed elements."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following `filterInPlace()` helper can be used to achieve the desired result in `O(n)` time.\n\n```javascript\nfunction filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\nfunction pullAt(array, indexes_) {\n  const pulled = indexes_.map(i => array[i]);\n  const indexes = new Set(indexes_);\n  filterInPlace(array, (_, i) => !indexes.has(i));\n  return pulled;\n}\n```\n","src":null,"test":""},{"name":"remove","manifest":{"fnSignature":"_.remove(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#remove","summary":"Removes all elements from `array` that `predicate` returns truthy for and returns an array of the removed elements."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following implementation can be used to achieve the desired result in `O(n)` time.\n\n```javascript\nfunction remove(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n```\n","src":null,"test":""},{"name":"reverse","manifest":{"fnSignature":"_.reverse(array)","lodashLink":"https://lodash.com/docs/4.17.15#reverse","summary":"Reverses `array` so that the first element becomes the last, the second element becomes the second to last, and so on."},"description":"```javascript\narray.reverse();\n```\n","src":null,"test":""},{"name":"slice","manifest":{"fnSignature":"_.slice(array, start?, end?)","lodashLink":"https://lodash.com/docs/4.17.15#slice","summary":"Creates a slice of `array` from `start` up to, but not including, `end`."},"description":"```javascript\narray.slice(start, end);\n```\n\nOne benefit of Lodash's implementation of `.slice()`, is that it'll always return a dense array (as opposed to a [sparse one](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#sparse_arrays)). The same behavior can be achieved in plain JavaScript by simply spreading the array into another one.\n\n```javascript\nconst sparseArray = [2,,3,,4]; // [2, <empty>, 3, <empty>, 4]\nconst denseArray = [...sparseArray]; // [2, undefined, 3, undefined, 4]\nconsole.log(denseArray.slice(1, 3)); // [undefined, 3]\n```\n\nNote, however, that Lodash is providing this behavior, mostly because it makes their `.slice()` implementation more consistent with how newer JavaScript array methods treat sparse arrays - by pretending the holes are the same as `undefined` values. In practice, such a feature shouldn't make a difference in your codebase, as it's generally considered bad practice to create or pass around sparse arrays. If you're a library developer who may be receiving arbitrary user input, simply treat arguments that could potentially be sparse arrays the same way you would treat any other kind of bad input the end-user gives you. If you don't do any data validation, then don't worry about it - a sparse array would result in undefined behavior, the same way any other bad input would. If you do up-front data validation, you can choose to add the detection of sparse arrays as an additional up-front check.\n","src":null,"test":""},{"name":"sortedIndex","manifest":{"fnSignature":"_.sortedIndex(array, value)","lodashLink":"https://lodash.com/docs/4.17.15#sortedIndex","summary":"Uses a binary search to determine the lowest index at which `value` should be inserted into `array` in order to maintain its sort order."},"description":"```javascript\nfunction sortedIndex(array, value, _range) {\n  const [low, high] = _range ?? [0, array.length];\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = value <= array[midPoint]\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedIndex(array, value, newRange);\n}\n```\n","src":null,"test":""},{"name":"sortedIndexBy","manifest":{"fnSignature":"_.sortedIndexBy(array, value, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#sortedIndexBy","summary":"This method is like `_.sortedIndex` except that it accepts `iteratee` which is invoked for `value` and each element of `array` to compute their sort ranking."},"description":"```javascript\nfunction sortedIndexBy(array, value, iteratee, _recurseOpts) {\n  _recurseOpts ??= {\n    range: [0, array.length],\n    transformedValue: iteratee(value),\n  };\n\n  const transformedValue = _recurseOpts.transformedValue;\n  const [low, high] = _recurseOpts.range;\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = transformedValue <= iteratee(array[midPoint])\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedIndexBy(array, value, iteratee, { transformedValue, range: newRange });\n}\n```\n","src":null,"test":""},{"name":"sortedIndexOf","manifest":{"fnSignature":"_.sortedIndexOf(array, value)","lodashLink":"https://lodash.com/docs/4.17.15#sortedIndexOf","summary":"This method is like `_.indexOf` except that it performs a binary search on a sorted `array`."},"description":"We will use a plain JavaScript implementation of `_.sortedIndex()` to help define `sortedIndexOf()`.\n\n```javascript\nfunction sortedIndex(array, value, _range) {\n  const [low, high] = _range ?? [0, array.length];\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = value <= array[midPoint]\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedIndex(array, value, newRange);\n}\n\nfunction sortedIndexOf(array, value) {\n  const index = sortedIndex(array, value);\n  return array[index] === value ? index : -1;\n}\n```","src":null,"test":""},{"name":"sortedLastIndex","manifest":{"fnSignature":"_.sortedLastIndex(array, value)","lodashLink":"https://lodash.com/docs/4.17.15#sortedLastIndex","summary":"This method is like `_.sortedIndex` except that it returns the highest index at which `value` should be inserted into `array` in order to maintain its sort order."},"description":"```javascript\nfunction sortedLastIndex(array, value, _range) {\n  const [low, high] = _range ?? [0, array.length];\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = value < array[midPoint]\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedLastIndex(array, value, newRange);\n}\n```\n","src":null,"test":""},{"name":"sortedLastIndexBy","manifest":{"fnSignature":"_.sortedLastIndexBy(array, value, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#sortedLastIndexBy","summary":"This method is like `_.sortedLastIndex` except that it accepts `iteratee` which is invoked for value and each element of array to compute their sort ranking."},"description":"```javascript\nfunction sortedLastIndexBy(array, value, iteratee, _recurseOpts) {\n  _recurseOpts ??= {\n    range: [0, array.length],\n    transformedValue: iteratee(value),\n  };\n\n  const transformedValue = _recurseOpts.transformedValue;\n  const [low, high] = _recurseOpts.range;\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = transformedValue < iteratee(array[midPoint])\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedLastIndexBy(array, value, iteratee, { transformedValue, range: newRange });\n}\n```\n","src":null,"test":""},{"name":"sortedLastIndexOf","manifest":{"fnSignature":"_.sortedLastIndexOf(array, value)","lodashLink":"https://lodash.com/docs/4.17.15#sortedLastIndexOf","summary":"This method is like `_.lastIndexOf` except that it performs a binary search on a sorted `array`."},"description":"We will use a plain JavaScript implementation of `_.sortedLastIndex()` to help define `sortedLastIndexOf()`.\n\n```javascript\nfunction sortedLastIndex(array, value, _range) {\n  const [low, high] = _range ?? [0, array.length];\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = value < array[midPoint]\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedLastIndex(array, value, newRange);\n}\n\nfunction sortedLastIndexOf(array, value) {\n  const index = sortedLastIndex(array, value) - 1;\n  return index > -1 && array[index] === value ? index : -1;\n}\n```","src":null,"test":""},{"name":"sortedUniq","manifest":{"fnSignature":"_.sortedUniq(array)","lodashLink":"https://lodash.com/docs/4.17.15#sortedUniq","summary":"This method is like `_.uniq` except that it's designed and optimized for sorted arrays."},"description":"```javascript\nfunction sortedUniq(array) {\n  if (array.length === 0) {\n    return [];\n  }\n\n  const result = [array[0]];\n  for (const value of array) {\n    if (result[result.length - 1] !== value) {\n      result.push(value);\n    }\n  }\n\n  return result;\n}\n```\n\n[Some basic benchmarks](https://gist.github.com/theScottyJam/8424183e49f4555b60752b21f1076129) shows that the processing time per item improves as the number of repeated items increase. If you're not dealing with large arrays, or arrays with many repeated items, then using the simpler `[...new Set(array)]` solution should be sufficient.\n","src":null,"test":""},{"name":"sortedUniqBy","manifest":{"fnSignature":"_.sortedUniqBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#sortedUniqBy","summary":"This method is like `_.uniqBy` except that it's designed and optimized for sorted arrays."},"description":"```javascript\nfunction sortedUniqBy(array, iteratee) {\n  if (array.length === 0) {\n    return [];\n  }\n\n  let lastTransformedValue = iteratee(array[0]);\n  const result = [array[0]];\n  for (let i = 0; i < array.length; ++i) {\n    const transformedValue = iteratee(array[i]);\n    if (lastTransformedValue !== transformedValue) {\n      result.push(array[i]);\n      lastTransformedValue = transformedValue;\n    }\n  }\n\n  return result;\n}\n```\n","src":null,"test":""},{"name":"tail","manifest":{"fnSignature":"_.tail(array)","lodashLink":"https://lodash.com/docs/4.17.15#tail","summary":"Gets all but the first element of `array`."},"description":"```javascript\narray.slice(1);\n```\n","src":null,"test":""},{"name":"take","manifest":{"fnSignature":"_.take(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#take","summary":"Creates a slice of `array` with `n` elements taken from the beginning."},"description":"```javascript\narray.slice(0, n);\n```\n","src":null,"test":""},{"name":"takeRight","manifest":{"fnSignature":"_.takeRight(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#takeRight","summary":"Creates a slice of `array` with `n` elements taken from the end."},"description":"```javascript\narray.slice(-n);\n```\n\nYou do have to watch out for the zero case. `_.takeRight(0)` will return an empty array, while, `array.slice(-0)` will return the whole array.\n","src":null,"test":""},{"name":"takeRightWhile","manifest":{"fnSignature":"_.takeRightWhile(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#takeRightWhile","summary":"Creates a slice of `array` with elements taken from the end. Elements are taken until `predicate` returns falsey."},"description":"```javascript\nfunction takeRightWhile(array, predicate) {\n  const index = array.findLastIndex((...args) => !predicate(...args))\n  if (index === -1) {\n    return array;\n  }\n\n  return array.slice(index + 1);\n}\n```\n","src":null,"test":""},{"name":"takeWhile","manifest":{"fnSignature":"_.takeWhile(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#takeWhile","summary":"Creates a slice of `array` with elements taken from the beginning. Elements are taken until `predicate` returns falsey."},"description":"```javascript\nfunction takeWhile(array, predicate) {\n  const index = array.findIndex((...args) => !predicate(...args))\n  if (index === -1) {\n    return array;\n  }\n\n  return array.slice(0, index);\n}\n```\n","src":null,"test":""},{"name":"union","manifest":{"fnSignature":"_.union(...arrays)","lodashLink":"https://lodash.com/docs/4.17.15#union","summary":"Creates an array of unique values, in order, from all given arrays using `SameValueZero` for equality comparisons."},"description":"```javascript\n[...new Set([...array1, ...array2])];\n```\n\nSets internally use [the SameValueZero comparison algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality) under-the-hood, just like Lodash's `_.union()`.\n\nThere is [an upcoming proposal](https://github.com/tc39/proposal-set-methods) that will introduce a native `.union()` method for sets.\n","src":null,"test":""},{"name":"unionBy","manifest":{"fnSignature":"_.unionBy(...arrays, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#unionBy","summary":"This method is like `_.union` except that it accepts `iteratee` which is invoked for each element of each `arrays` to generate the criterion by which uniqueness is computed."},"description":"We will use a plain JavaScript implementation of `_.uniqBy()` to solve this problem.\n\n```javascript\nfunction uniqBy(array, iteratee) {\n  const transformedResults = new Set();\n  const result = [];\n  for (const element of array) {\n    const transformedElement = iteratee(element);\n    if (!transformedResults.has(transformedElement)) {\n      transformedResults.add(transformedElement);\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n\n// Merge the given arrays, then filter out duplicates.\n// This end-effect will be the union of these two arrays,\n// using `iteratee` to decide equivalence.\nuniqBy([...array1, ...array2], iteratee);\n```\n","src":null,"test":""},{"name":"unionWith","manifest":{"fnSignature":"_.unionWith(array, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#unionWith","summary":"This method is like `_.union` except that it accepts `comparator` which is invoked to compare elements of `arrays`."},"description":"We will use a plain JavaScript implementation of `_.uniqWith()` to solve this problem.\n\n```javascript\nfunction uniqWith(array, comparator) {\n  const result = [];\n  for (const element of array) {\n    if (result.every(x => !comparator(x, element))) {\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n\n// Merge the given arrays, then filter out duplicates.\n// This end-effect will be the union of these two arrays,\n// using `comparator` to decide equivalence.\nuniqWith([...array1, ...array2], comparator);\n```\n","src":null,"test":""},{"name":"uniq","manifest":{"fnSignature":"_.uniq(array)","lodashLink":"https://lodash.com/docs/4.17.15#uniq","summary":"Creates a duplicate-free version of an array, using `SameValueZero` for equality comparisons."},"description":"```javascript\n[...new Set(array)];\n```\n\nSets internally use [the SameValueZero comparison algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality) under-the-hood, just like Lodash's `_.uniq()`.\n","src":null,"test":""},{"name":"uniqBy","manifest":{"fnSignature":"_.uniqBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#uniqBy","summary":"This method is like `_.uniq` except that it accepts `iteratee` which is invoked for each element in array to generate the criterion by which uniqueness is computed."},"description":"```javascript\nfunction uniqBy(array, iteratee) {\n  const transformedResults = new Set();\n  const result = [];\n  for (const element of array) {\n    const transformedElement = iteratee(element);\n    if (!transformedResults.has(transformedElement)) {\n      transformedResults.add(transformedElement);\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n```\n","src":null,"test":""},{"name":"uniqWith","manifest":{"fnSignature":"_.uniqWith(array, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#uniqWith","summary":"This method is like `_.uniq` except that it accepts `comparator` which is invoked to compare elements of `array`."},"description":"```javascript\nfunction uniqWith(array, comparator) {\n  const result = [];\n  for (const element of array) {\n    if (result.every(x => !comparator(x, element))) {\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n```\n","src":null,"test":""},{"name":"unzip","manifest":{"fnSignature":"_.unzip(array)","lodashLink":"https://lodash.com/docs/4.17.15#unzip","summary":"This method is like `_.zip` except that it accepts an array of grouped elements and creates an array regrouping the elements to their pre-zip configuration."},"description":"`_.zip()` is actually the inverse of itself, meaning you can use it to unzip the result of `_.zip()`, like this:\n\n```javascript\nconst original = [[1, 2, 3], ['A', 'B', 'C']]\nconst zipped = _.zip(...original); // [[1, 'A'], [2, 'B'], [3, 'C']]\nconst unzipped = _.zip(...zipped); // [[1, 2, 3], ['A', 'B', 'C']]\n```\n\nThe only difference between `_.zip()` and `_.unzip()` is how it accepts parameters.\n\n```javascript\n// With _.zip(), arrays are passed in as separate parameters\n_.zip([1, 2], ['A', 'B']);     // [[1, 'A'], [2, 'B']]\n// With _.unzip(), arrays are placed inside a single larger array.\n_.unzip([[1, 2], ['A', 'B']]); // [[1, 'A'], [2, 'B']]\n```\n\nSo, to implement an unzip function, all you really need is an implementation for `zip()`.\n\n```javascript\nfunction zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(arrays.map(arr => arr[i]));\n  }\n\n  return result;\n}\n```\n\nIf you want a Lodash-style unzip function, here's how to implement it:\n\n```javascript\nfunction unzip(arrays) {\n  return zip(...arrays);\n}\n```\n","src":null,"test":""},{"name":"unzipWith","manifest":{"fnSignature":"_.unzipWith(array, iteratee)","lodashLink":"https://lodash.com/docs/4.17.15#unzipWith","summary":"This method is like `_.unzip` except that it accepts `iteratee` to specify how regrouped values should be combined."},"description":"The only difference between `_.zipWith()` and `_.unzipWith()` is how it accepts parameters.\n\n```javascript\n// With _.zipWith(), arrays are passed in as separate parameters\n_.zipWith([10, 20], [1, 2], (a, b) => a + b);     // [11, 22]\n// With _.unzipWith(), arrays are placed inside a single larger array.\n_.unzipWith([[10, 20], [1, 2]], (a, b) => a + b); // [11, 22]\n```\n\n!!!!\n\nSo, to implement an unzipWith function, all you really need is an implementation for `zipWith()`.\n\n```javascript\nfunction zipWith(...args) {\n  const arrays = args.slice(0, -1);\n  const iteratee = args.at(-1);\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(iteratee(...arrays.map(arr => arr[i])));\n  }\n\n  return result;\n}\n```\n\nIf you want a Lodash-style unzipWith function, here's how to implement it:\n\n```javascript\nfunction unzipWith(arrays, iteratee) {\n  return zip(arrays, iteratee);\n}\n```\n","src":null,"test":""},{"name":"without","manifest":{"fnSignature":"_.without(array, ...values)","lodashLink":"https://lodash.com/docs/4.17.15#without","summary":"Creates an array excluding all given values using `SameValueZero` for equality comparisons."},"description":"```javascript\narray.filter(x => x !== value);\n```\n\nIf you wish to filter out multiple values, look at the plain JavaScript version of `_.difference()`. Both `_.difference()` and `_.without()` achieve the same effect, but with slightly different function signatures.\n\nIf you wish to perform comparisons using [the SameValueZero algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality), similar to how Lodash does it, you can use this helper function:\n\n```javascript\nfunction sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) && Number.isNaN(y));\n}\n```\n","src":null,"test":""},{"name":"xor","manifest":{"fnSignature":"_.xor(...arrays)","lodashLink":"https://lodash.com/docs/4.17.15#xor","summary":"Creates an array of unique values that is the symmetric difference of the given arrays."},"description":"```javascript\nfunction xor(array1, array2) {\n  const set1 = new Set(array1);\n  const set2 = new Set(array2);\n  return [\n    ...array1.filter(x => !set2.has(x)),\n    ...array2.filter(x => !set1.has(x)),\n  ];\n}\n```\n","src":null,"test":""},{"name":"xorBy","manifest":{"fnSignature":"_.xorBy(...arrays, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#xorBy","summary":"This method is like `_.xor` except that it accepts `iteratee` which is invoked for each element of each `arrays` to generate the criterion by which by which they're compared."},"description":"```javascript\nfunction xorBy(array1, array2, iteratee) {\n  const set1 = new Set(array1.map(x => iteratee(x)));\n  const set2 = new Set(array2.map(x => iteratee(x)));\n  return [\n    ...array1.filter(x => !set2.has(iteratee(x))),\n    ...array2.filter(x => !set1.has(iteratee(x))),\n  ];\n}\n```\n","src":null,"test":""},{"name":"xorWith","manifest":{"fnSignature":"_.xorWith(...arrays, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#xorWith","summary":"This method is like `_.xor` except that it accepts `comparator` which is invoked to compare elements of arrays."},"description":"```javascript\nfunction xorWith(array1, array2, comparator) {\n  return [\n    ...array1.filter(x => !array2.some(y => comparator(x, y))),\n    ...array2.filter(x => !array1.some(y => comparator(x, y))),\n  ];\n}\n```\n","src":null,"test":""},{"name":"zip","manifest":{"fnSignature":"_.zip(...arrays)","lodashLink":"https://lodash.com/docs/4.17.15#zip","summary":"Creates an array of grouped elements, the first of which contains the first elements of the given arrays, the second of which contains the second elements of the given arrays, and so on."},"description":"```javascript\nfunction zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(arrays.map(arr => arr[i]));\n  }\n\n  return result;\n}\n```\n","src":null,"test":""},{"name":"zipObject","manifest":{"fnSignature":"_.zipObject(props?, values?)","lodashLink":"https://lodash.com/docs/4.17.15#zipObject","summary":"This method is like `_.fromPairs` except that it accepts two arrays, one of property identifiers and one of corresponding values."},"description":"We will use a plain JavaScript implementation of `_.zip()` to solve this problem.\n\n```javascript\nfunction zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(arrays.map(arr => arr[i]));\n  }\n\n  return result;\n}\n\n// First zips the keys and values,\n// then build an object from the zipped entries.\nObject.fromEntries(zip(props, values));\n```\n","src":null,"test":""},{"name":"zipObjectDeep","manifest":{"fnSignature":"_.zipObjectDeep(props?, values?)","lodashLink":"https://lodash.com/docs/4.17.15#zipObjectDeep","summary":"This method is like `_.zipObject` except that it supports property paths."},"description":"It's recommended to avoid this function. Building objects via dynamic string paths may (or may not) be indicative of a deeper issue with how the problem is being approached. But, if you really do need support for this sort of thing, it can be done, with the help of the plain JavaScript implementation of `_.set()` and `_.zip()`.\n\n```javascript\nfunction set(object, path, value) {\n  if (typeof path === 'string') {\n    const isQuoted = str => str[0] === '\"' && str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x => x)\n      .map(x => !isNaN(Number(x)) ? Number(x) : x)\n      .map(x => typeof x === 'string' && isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = value;\n    return object;\n  }\n\n  if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  set(object[head], tail, value);\n  return object;\n}\n\nfunction zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(arrays.map(arr => arr[i]));\n  }\n\n  return result;\n}\n\nfunction zipObjectDeep(props, values) {\n  const resultObj = {};\n  for (const [path, value] of zip(props, values)) {\n    set(resultObj, path, value);\n  }\n\n  return resultObj;\n}\n```\n\nNote that the support for string paths in the above `zipObjectDeep()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.zipObjectDeep()` isn't all that different in this regard.\n","src":null,"test":""},{"name":"zipWith","manifest":{"fnSignature":"_.zipWith(...arrays, iteratee)","lodashLink":"https://lodash.com/docs/4.17.15#zipWith","summary":"This method is like `_.zip` except that it accepts `iteratee` to specify how grouped values should be combined."},"description":"```javascript\nfunction zipWith(...args) {\n  const arrays = args.slice(0, -1);\n  const iteratee = args.at(-1);\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(iteratee(...arrays.map(arr => arr[i])));\n  }\n\n  return result;\n}\n```\n","src":null,"test":""}]},{"categoryHeading":"Date","entries":[{"name":"now","manifest":{"fnSignature":"_.now()","lodashLink":"https://lodash.com/docs/4.17.15#now","summary":"Gets the timestamp of the number of milliseconds that have elapsed since the Unix epoch."},"description":"```javascript\nDate.now();\n```\n","src":null,"test":""}]},{"categoryHeading":"Lang","entries":[{"name":"cloneDeep","manifest":{"fnSignature":"_.cloneDeep(value)","lodashLink":"https://lodash.com/docs/4.17.15#cloneDeep","summary":"This method is like `_.clone` except that it recursively clones value."},"description":"```javascript\nstructuredClone(value)\n```\n\n`_.cloneDeep()` is loosely based off of the structured clone algorithm, the same algorithm that is provided to you natively with the `structuredClone()` function. The structured clone algorithm can be useful for simpler scenarios, but it has severe limitations that you should be aware of:\n* many objects, such as `ArrayBuffer` instances, will have ownership of their data transferred to their clone, rendering the original unusable. A complete list of transferable objects can be found [on MDN's website](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Transferable_objects#supported_objects).\n* Some values, like functions, can not be cloned.\n* Some objects lose data when they get cloned. This includes the prototypes of most objects (making it impossible to properly clone instances of any userland class), getters and setters, some data stored on regular expression instances, etc.\n\nFor a complete reference to the algorithm's limitations, please refer to the [structured clone algorithm page](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm) on MDN.\n\nIf `structuredClone()` doesn't suit your needs (because, e.g., maybe you have userland instances that you wish to clone), you'll have to build up your own cloning algorithm by hand, according to your use-case. Here's a simple version to get you started - it shows examples of how you would deep-clone a handful of different types of data. It's up to you to add or remove functionality as needed. Note that this version does not support circular references - if you need to support that, you'll additionally need to keep around a set containing each value you've visited to make sure you're not going in a loop.\n\n```javascript\nconst isObject = value => ['object', 'function'].includes(typeof value) && value !== null;\n\nfunction cloneDeep(value) {\n  if (!isObject(value)) {\n    // It's a primitive, which is immutable, so we don't need to clone it.\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(cloneDeep);\n  } else if (value instanceof Map) {\n    return new Map(\n      [...value].map(([key, value]) => [cloneDeep(key), cloneDeep(value)])\n    );\n  } else if (value instanceof Set) {\n    return new Set(\n      [...value].map(x => cloneDeep(x))\n    );\n  } else if (Object.getPrototypeOf(value) === Object.prototype) {\n    return Object.fromEntries(\n      Object.entries(value).map(([key, value]) => [key, cloneDeep(value)])\n    );\n  } else if (Object.getPrototypeOf(value) === null) {\n    const newObject = Object.fromEntries(\n      Object.entries(value).map(([key, value]) => [key, cloneDeep(value)])\n    );\n    Object.setPrototypeOf(newObject, null);\n    return newObject;\n  } else {\n    throw new Error(`Can not clone an instance of ${value.constructor?.name}`);\n  }\n}\n```\n","src":null,"test":""},{"name":"isArguments","manifest":{"fnSignature":"_.isArguments(value)","lodashLink":"https://lodash.com/docs/4.17.15#isArguments","summary":"Checks if `value` is likely an `arguments` object."},"description":"```javascript\nfunction isArguments(value) {\n  return Object.prototype.toString.call(value) === '[object Arguments]' && !(Symbol.toStringTag in value);\n}\n```\n\nThe above solution can technically give wrong answers if you provide an arguments object that has been mutated to contain `Symbol.toStringTag`.\n\n```javascript\nfunction() {\n  arguments[Symbol.toStringTag] = 'badValue';\n  isArguments(arguments); // false\n}\n```\n\nEven Lodash's implementation can be spoofed, but under different conditions. If you run the following, you'll see that it will incorrectly claim that the provided object is an arguments object `true`.\n\n```javascript\n_.isArguments({ get [Symbol.toStringTag]() { return 'Arguments' } }); // true\n```\n\nIf you're exclusively using Node, you're welcome to instead use `require('util').types.isArgumentsObject(value)` for your `isArguments` check.\n","src":null,"test":""},{"name":"isArray","manifest":{"fnSignature":"_.isArray(value)","lodashLink":"https://lodash.com/docs/4.17.15#isArray","summary":"Checks if `value` is classified as an `Array` object."},"description":"Lodash's `_.isArray()` is simply an alias for `Array.isArray(value)`.\n\nNote that `Array.isArray()` will return `true` both for array subclasses and if you directly pass in `Array.prototype`. In many cases this sort of thing isn't something you need to worry about, but if you want to prevent subclasses and/or `Array.prototype` from getting through there's various solutions you can use depending on how robust you need the solution to be.\n\n1. `Object.getPrototypeOf(value) === Array.prototype` is the simplest way to exclude `Array.prototype` and inherited instances, but has issues with cross-realm arrays (see footnote 1) and `Object.create(Array.prototype)` (see footnote 2).\n2. `Array.isArray(value) && Object.getPrototypeOf(value) === Array.prototype` is a little more robust and solved the `Object.create(Array.prototype)` issue (footnote 2), but still has issues with cross-realm arrays (footnote 1).\n3. The helper function below would be the strongest solution, and doesn't have any of the issues that the simpler solutions have.\n\n    ```javascript\n    // Cross realm compatible is-non-inherited-array check.\n    function isNonInheritedArray(value) {\n      const protoOf = Object.getPrototypeOf;\n      // An array's prototype chain should normally be\n      // value -> Array.prototype -> Object.prototype -> null\n      // If there's an extra link in there, it means inheritance has happened.\n      return (\n        Array.isArray(value) &&\n        protoOf(protoOf(value)) !== null && // This check fails if you pass in Array.prototype.\n        protoOf(protoOf(protoOf(value))) === null\n      );\n    }\n    ```\n\n4. If you just want to exclude `Array.prototype` and still allow subclasses, then you can use solution 3, but omit the last `protoOf(protoOf(protoOf(value))) === null` check.\n\nFootnotes:\n1. A \"cross-realm array\" is, for example, an array from an iframe. Since the Array class from within the iframe is separate from the Array class outside of the iframe, you can't simply do an equality check on their prototypes.\n2. The problem with `Object.create(Array.prototype)` is that this does not create a real array, it's just an object who's prototype happens to be `Array.prototype`.\n","src":null,"test":""},{"name":"isArrayBuffer","manifest":{"fnSignature":"_.isArrayBuffer(value)","lodashLink":"https://lodash.com/docs/4.17.15#isArrayBuffer","summary":"Checks if `value` is classified as an `ArrayBuffer` object."},"description":"To check if your value is an instance of `ArrayBuffer`:\n\n```javascript\nvalue instanceof ArrayBuffer;\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nIt's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:\n\n```javascript\nObject.getPrototypeOf(value) === ArrayBuffer.prototype;\n```\n\nBoth of the above type-detection mechanisms have a couple of flaws:\n1. they don't work with cross-realm values. For example, if you receive an instance of an `ArrayBuffer` from across an iframe boundary, that instance's prototype would link to the iframe's `ArrayBuffer` class, not your `ArrayBuffer` class, and both of the above checks would fail to recognize it as an ArrayBuffer.\n2. They will state that `Object.create(ArrayBuffer.prototype)` is an `ArrayBuffer`, but it's not. It's just a regular object who's prototype has been set to `ArrayBuffer.prototype`.\n\nBoth of these issues can be solved with a helper function like this:\n\n```javascript\n// An isArrayBuffer() check that supports cross-realm ArrayBuffers.\nfunction isArrayBuffer(value) {\n  try {\n    // If you call an ArrayBuffer method, like .slice(),\n    // with a \"this\" value that's anything\n    // other than an ArrayBuffer, a TypeError is thrown.\n    ArrayBuffer.prototype.slice.call(value, 0, 0);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nIf you additionally need to ensure that you are not receiving an ArrayBuffer instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace `return true;` with the following:\n\n```javascript\n// A ArrayBuffer's prototype's chain should be\n// value -> ArrayBuffer.prototype -> Object.prototype -> null\n// If it's not, then we're dealing with an ArrayBuffer subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n```\n\nLodash's `_.isArrayBuffer()` also supports cross-realm ArrayBuffer checks, but it uses a less robust algorithm that can be easily fooled. For example, if you run Lodash in the browser, the following will return the wrong answer.\n\n```javascript\n_.isArrayBuffer({ get [Symbol.toStringTag]() { return 'ArrayBuffer' } }); // true\n```\n\nIn Node, Lodash will instead use `require('util').types.isArrayBuffer(value)` for it's implementation, which you are also welcome to use if you know your code will only run in Node.\n\nSome very early JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:\n* [istypes](https://github.com/jasnell/proposal-istypes)\n* [Pattern matching's built-in matchers](https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1)\n","src":null,"test":""},{"name":"isArrayLike","manifest":{"fnSignature":"_.isArrayLike(value)","lodashLink":"https://lodash.com/docs/4.17.15#isArrayLike","summary":"Checks if `value` is array-like. A value is considered array-like if it's not a function and has a value.length that's an integer greater than or equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`."},"description":"An equivalent to Lodash's \"is-array-like\" algorithm is as follows:\n\n```javascript\nfunction isArrayLike(value) {\n  return (\n    typeof value !== 'function' &&\n    Number.isInteger(value?.length) &&\n    value.length >= 0\n  );\n}\n```\n\nThe JavaScript specification uses a much looser definition for \"array-like\" - basically, as long as you can get a \"length\" property from the value and coerce it into an integer somehow, then it's an array-like value. This means that even `{}` is \"array-like\", because it's able to get the (non-existent) length property (`undefined`), then coerce that into an integer (`0`). This definition technically makes almost any value except undefined, null, and a couple of other minor edge cases \"array-like\". A good way to check if something is considered array-like or not per the spec, is to run the following snippet and see if it throws an error, if it does not, your value is an array-like value.\n\n```javascript\nArray.prototype.slice.call(<your value>);\n```\n\nIn day-to-day conversation the term \"array-like\" goes beyond the technical definition of array-like as outlined by the spec. An array-like value is additionally a value that was intentionally designed to have array-like characteristics, which is why Lodash's implementation still makes sense - Lodash's does a good job at rejecting values that were never intended to be used like an array. The point is that Lodash's implementation isn't the only correct way to implement this check - depending on your use-case you might find that a different `isArrayLike()` implementation would be more appropriate.\n\nAn even better lesson from all of this is that if you're tempted to design a function that behaves differently depending on if an input value is array-like or not, it might be worthwhile to reconsider the API design so you don't have to make your public API depend on either a non-standard or overly loose definition of \"array-like\".\n","src":null,"test":"function isArrayLike(value) {\n  return (\n    typeof value !== 'function' &&\n    Number.isInteger(value?.length) &&\n    value.length >= 0\n  );\n}\n\ndescribe('isArrayLike()', () => {\n  it('considers an array to be array-like', () => {\n    expect(isArrayLike([2, 3])).toBe(true);\n  });\n\n  it('considers a string to be array-like', () => {\n    expect(isArrayLike('23')).toBe(true);\n  });\n\n  it('considers an arguments object to be array-like', () => {\n    (function () {\n      expect(isArrayLike(arguments)).toBe(true);\n    })();\n  });\n\n  it('does not consider a function to be array-like', () => {\n    expect(isArrayLike(function () {})).toBe(false);\n  });\n\n  it('considers a value missing a length property to not be array-like', () => {\n    expect(isArrayLike({})).toBe(false);\n  });\n\n  it('considers a value with a positive integer length to be array-like', () => {\n    expect(isArrayLike({ length: 2 })).toBe(true);\n  });\n\n  it('considers a value with the length 0 to be array-like', () => {\n    expect(isArrayLike({ length: 0 })).toBe(true);\n  });\n\n  it('considers a value with a string length to not be array-like', () => {\n    expect(isArrayLike({ length: '2' })).toBe(false);\n  });\n\n  it('considers a value with a length of Infinity to not be array-like', () => {\n    expect(isArrayLike({ length: Infinity })).toBe(false);\n  });\n\n  it('considers a value with a length of NaN to not be array-like', () => {\n    expect(isArrayLike({ length: NaN })).toBe(false);\n  });\n\n  it('considers a value with a float length to not be array-like', () => {\n    expect(isArrayLike({ length: 2.3 })).toBe(false);\n  });\n\n  it('considers a value with a really large length to not be array-like (as those are represented as floats)', () => {\n    expect(isArrayLike({ length: 2e999 })).toBe(false);\n  });\n});\n"},{"name":"isArrayLikeObject","manifest":{"fnSignature":"_.isArrayLikeObject(value)","lodashLink":"https://lodash.com/docs/4.17.15#isArrayLikeObject","summary":"This method is like `_.isArrayLike` except that it also checks if `value` is an object."},"description":"An equivalent to Lodash's \"is-array-like-object\" algorithm is as follows:\n\n```javascript\nfunction isArrayLikeObject(value) {\n  return isArrayLike(value) && isObject(value);\n}\n\n// -- helpers --\n\nfunction isArrayLike(value) {\n  return (\n    typeof value !== 'function' &&\n    Number.isInteger(value?.length) &&\n    value.length >= 0\n  );\n}\n\nfunction isObject(value) {\n  return value === Object(value);\n}\n```\n\n(Note that the only difference between `_.isArrayLikeObject()` and `_.isArrayLike()` is that `_.isArrayLikeObject()` does not return `true` for string primitives).\n\nThe JavaScript specification uses a much looser definition for \"array-like object\" - basically, as long as the value is an object and you can get a \"length\" property from the value and coerce it into an integer somehow, then it's an array-like value. This means that even `{}` is \"array-like\", because it's able to get the (non-existent) length property (`undefined`), then coerce that into an integer (`0`). This definition technically makes almost any non-primitive value \"array-like\" (an exception could be, for example, an object with a \"length\" getter that throws an error).\n\nIn day-to-day conversation the term \"array-like object\" goes beyond the technical definition of array-like object as outlined by the spec. An array-like object is additionally an object that was intentionally designed to have array-like characteristics, which is why Lodash's implementation still makes sense - Lodash's does a good job at rejecting values that were never intended to be used like an array. The point is that Lodash's implementation isn't the only correct way to implement this check - depending on your use-case you might find that a different `isArrayLikeObject()` implementation would be more appropriate.\n\nAn even better lesson from all of this is that if you're tempted to design a function that behaves differently depending on if an input value is an array-like object or not, it might be worthwhile to reconsider the API design so you don't have to make your public API depend on either a non-standard or overly loose definition of \"array-like object\".\n","src":null,"test":"function isArrayLikeObject(value) {\n  return isArrayLike(value) && isObject(value);\n}\n\nfunction isArrayLike(value) {\n  return (\n    typeof value !== 'function' &&\n    Number.isInteger(value?.length) &&\n    value.length >= 0\n  );\n}\n\nfunction isObject(value) {\n  return value === Object(value);\n}\n\ndescribe('isArrayLikeObject()', () => {\n  it('considers an array to be an array-like object', () => {\n    expect(isArrayLikeObject([2, 3])).toBe(true);\n  });\n\n  it('does not considers a string to be an array-like object', () => {\n    expect(isArrayLikeObject('23')).toBe(false);\n  });\n\n  it('considers an arguments object to be an array-like object', () => {\n    (function () {\n      expect(isArrayLikeObject(arguments)).toBe(true);\n    })();\n  });\n\n  it('does not consider a function to be an array-like object', () => {\n    expect(isArrayLikeObject(function () {})).toBe(false);\n  });\n\n  it('considers a value missing a length property to not be an array-like object', () => {\n    expect(isArrayLikeObject({})).toBe(false);\n  });\n\n  it('considers a value with a positive integer length to be an array-like object', () => {\n    expect(isArrayLikeObject({ length: 2 })).toBe(true);\n  });\n\n  it('considers a value with the length 0 to be an array-like object', () => {\n    expect(isArrayLikeObject({ length: 0 })).toBe(true);\n  });\n\n  it('considers a value with a string length to not be an array-like object', () => {\n    expect(isArrayLikeObject({ length: '2' })).toBe(false);\n  });\n\n  it('considers a value with a length of Infinity to not be an array-like object', () => {\n    expect(isArrayLikeObject({ length: Infinity })).toBe(false);\n  });\n\n  it('considers a value with a length of NaN to not be an array-like object', () => {\n    expect(isArrayLikeObject({ length: NaN })).toBe(false);\n  });\n\n  it('considers a value with a float length to not be an array-like object', () => {\n    expect(isArrayLikeObject({ length: 2.3 })).toBe(false);\n  });\n\n  it('considers a value with a really large length to not be an array-like object (as those are represented as floats)', () => {\n    expect(isArrayLikeObject({ length: 2e999 })).toBe(false);\n  });\n});\n"},{"name":"isBoolean","manifest":{"fnSignature":"_.isBoolean(value)","lodashLink":"https://lodash.com/docs/4.17.15#isBoolean","summary":"Checks if `value` is classified as a boolean primitive or object."},"description":"To check if a value is a boolean primitive:\n\n```javascript\ntypeof value === 'boolean';\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nLodash will also check if the value is a boolean object. In practice, such objects should never be found in your codebase, and if someone ever tries to hand such an object to you you really ought to treat it the same way you would treat any other bad input (throw an error, or if you aren't explicitly trying to check for bad inputs just let your library fall over, the same way it would with any other bad input).\n\nTo check if something is specifically a boolean object (and not a primitive), use the following:\n\n```javascript\nvalue instanceof Boolean;\n```\n\nThis, however, doesn't work cross realm (i.e. a boolean object created from inside an iframe would fail this check). It also would incorrectly state that `Object.create(Boolean.prototype)` is a boolean object, when in reality, it's just a normal object who's prototype is set to `Boolean.prototype`. If you need to worry about these kinds of issues, use the following solution instead:\n\n```javascript\n// An isBoolean() check that supports cross-realm Boolean instances.\n// This will check if `value` is a boolean primitive or object.\n// Returns `true` for values that inherit from `Boolean` as well.\nfunction isBoolean(value) {\n  try {\n    // If you call this method with a \"this\" value that's anything\n    // other than a boolean primitive or object, a TypeError is thrown.\n    Boolean.prototype.toString.call(value);\n    // Makes sure Boolean.prototype was not passed in.\n    const protoOf = Object.getPrototypeOf;\n    return protoOf(protoOf(value)) !== null;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nLodash's `_.isBoolean()` also supports cross-realm `Boolean` object checks, but it uses a less robust algorithm that can be easily fooled. For example, the following will return the wrong answer.\n\n```javascript\n_.isBoolean({ get [Symbol.toStringTag]() { return 'Boolean' } }); // true\n```\n\nIf you're exclusively using Node, you can use `require('util').types.isBooleanObject(value)` to specifically check if the value is a boolean object (not a primitive). This solution will also return `true` for both subclasses and `Boolean.prototype`.","src":null,"test":""},{"name":"isBuffer","manifest":{"fnSignature":"_.isBuffer(value)","lodashLink":"https://lodash.com/docs/4.17.15#isBuffer","summary":"Checks if `value` is a buffer."},"description":"The `Buffer` class is part of Node, and isn't found in the core JavaScript language. You can check if something is an instance of Buffer using Node's `isBuffer()` method as follows:\n\n```javascript\nBuffer.isBuffer(value);\n```\n\nThis will return `true` for `Buffer` subclasses. If you want to ensure your buffer instance is not a subclass, you can do the following:\n\n```javascript\nfunction isNonInheritedBuffer(value) {\n  // A Buffer's prototype's chain should be\n  // value -> Buffer.prototype -> Uint8Array.prototype -> TypedArray.prototype -> Object.prototype -> null\n  // If it's not, then we're dealing with a Buffer subclass.\n  const protoOf = Object.getPrototypeOf;\n  return (\n    Buffer.isBuffer(value) &&\n    protoOf(protoOf(protoOf(protoOf(protoOf(value))))) === null\n  )\n}\n```\n\nBoth of these solutions will work with cross-realm `Buffer` instances.","src":null,"test":""},{"name":"isDate","manifest":{"fnSignature":"_.isDate(value)","lodashLink":"https://lodash.com/docs/4.17.15#isDate","summary":"Checks if `value` is classified as a `Date` object."},"description":"To check if your value is an instance of `Date`:\n\n```javascript\nvalue instanceof Date;\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nIt's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:\n\n```javascript\nObject.getPrototypeOf(value) === Date.prototype;\n```\n\nBoth of the above type-detection mechanisms have a couple of flaws:\n1. they don't work with cross-realm values. For example, if you receive an instance of a `Date` from across an iframe boundary, that instance's prototype would link to the iframe's `Date` class, not your `Date` class, and both of the above checks would fail to recognize it as a `Date`.\n2. They will state that `Object.create(Date.prototype)` is a `Date`, but it's not. It's just a regular object who's prototype has been set to `Date.prototype`.\n\nBoth of these issues can be solved with a helper function like this:\n\n```javascript\n// An isDate() check that supports cross-realm Dates.\nfunction isDate(value) {\n  try {\n    // If you call a Date method, like .valueOf(),\n    // with a \"this\" value that's anything\n    // other than a Date, a TypeError is thrown.\n    Date.prototype.valueOf.call(value);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nIf you additionally need to ensure your are not receiving a `Date` instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace `return true;` with the following:\n\n```javascript\n// A Date's prototype's chain should be\n// value -> Date.prototype -> Object.prototype -> null\n// If it's not, then we're dealing with a Map subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n```\n\nLodash's `_.isDate()` also supports cross-realm `Date` checks, but it uses a less robust algorithm that can be easily fooled. For example, if you run Lodash in the browser, the following will return the wrong answer.\n\n```javascript\n_.isDate({ get [Symbol.toStringTag]() { return 'Date' } }); // true\n```\n\nIn Node, Lodash will instead use `require('util').types.isDate(value)` for it's implementation, which you are also welcome to use if you know your code will only run in Node. This solution will also return `true` for subclasses.\n\nSome very early JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:\n* [istypes](https://github.com/jasnell/proposal-istypes)\n* [Pattern matching's built-in matchers](https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1)\n","src":null,"test":""},{"name":"isElement","manifest":{"fnSignature":"_.isElement(value)","lodashLink":"https://lodash.com/docs/4.17.15#isElement","summary":"Checks if value is likely a `DOM` element."},"description":"To check if your value is an HTML Element:\n\n```javascript\nvalue instanceof Element;\n```\n\nFor the vast majority of scenarios the above should be good enough, but it does technically have a couple of flaws:\n1. it doesn't work with cross-realm values. For example, if you receive an instance of an `Element` from across an iframe boundary, that instance's prototype would link to the iframe's `Element` class, not your `Element` class, and the above check would fail to recognize it as an `Element`.\n2. They will state that `Object.create(Element.prototype)` is an element, but it's not. It's just a regular object who's prototype has been set to `Element.prototype`.\n\nBoth of these issues can be solved with a helper function like this:\n\n```javascript\n// An isElement() check that supports cross-realm Elements.\nfunction isElement(value) {\n  try {\n    // If you call a Element method, like .getAttribute(),\n    // with a \"this\" value that's anything\n    // other than an Element, a TypeError is thrown.\n    Element.prototype.getAttribute.call(value, '')\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nLodash's `_.isElement()` also supports cross-realm `Element` checks, but it uses a far less robust algorithm that can be easily fooled. To spoof it, you just need to provide a [non-plain object](https://lodash.com/docs/4.17.15#isPlainObject) which has a `nodeType` property set to `1`.\n\n```javascript\nclass NotAnElement {\n  nodeType = 1;\n}\n\n_.isElement(new NotAnElement()); // true\n```\n","src":null,"test":""},{"name":"isEmpty","manifest":{"fnSignature":"_.isEmpty(value)","lodashLink":"https://lodash.com/docs/4.17.15#isEmpty","summary":"Checks if `value` is an empty object, collection, map, or set."},"description":"To check if something is empty, you can simply use the API provided by the specific object type you have.\n\nFor array and strings, use the `.length` property.\n\n```javascript\nmyArray.length === 0;\nmyString.length === 0;\n```\n\nFor maps and sets, use the `.size` property.\n\n```javascript\nnew Map().size === 0;\nnew Set().size === 0;\n```\n\nYou can check if an object has zero non-inherited string keys by checking the length of `Object.keys()`.\n\n```javascript\nObject.keys({}).length === 0;\n```\n\nLodash treats undefined and null as empty, while treating all other non-string primitives as non-empty. This distinction is technically nonsense. Only containers can be empty. If your piece of data can't hold anything, then it _can't_ be empty or non-empty, instead it's simply an invalid input. It's true that a `null` or `undefined` can be used to represent the absence of a value, but these pieces of data aren't in-and-of-themselves _empty_. In any case, if you want to check if something is `undefined` or `null`, you can just use `value === undefined` or `value === null`.\n\nIf you want to check if an [array-like value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#array-like_objects) (e.g. the argument object, typed arrays, etc) is empty, check the `.length` property, the same way you would with a normal array.\n\n```javascript\nmyArrayLikeValue.length === 0;\n```\n\nDespite what Lodash's documentation seems to imply, `_.isEmpty()` does not work with _any_ array-like value. Take, for example, `{ length: 0 }`, which is an array-like object (it passes Lodash's `_.isArrayLike()` check), however, when passed into `_.isEmpty()`, Lodash will incorrectly state that this array-like value is not empty. The reason for this odd behavior is simply because this function has been overloaded with too many behaviors - while it's true that `{ length: 0 }` is an empty array-like object, it's also true that this is not an empty object, and Lodash has decided to let the \"is this an empty object\" behavior take precedence over the \"is this an empty array-like value\" behavior for this specific scenario. If you want to know the details of how it decides which behavior to follow, feel free to [read its source code](https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L11479).\n","src":null,"test":""},{"name":"isEqual","manifest":{"fnSignature":"_.isEqual(value, other)","lodashLink":"https://lodash.com/docs/4.17.15#isEqual","summary":"Performs a deep comparison between two values to determine if they are equivalent."},"description":"To deeply compare values you'll have to build up your own deep comparison algorithm by hand according to your use-case. General-purpose deep-comparison algorithms like Lodash's `_.isEqual()` can be nice to have for simple use-cases, but it's important to understand that all such algorithms have limitations and you may be forced to revert to building your own deep-comparison algorithm if you are using a data type that the algorithm does not explicitly support (e.g. no general-purpose algorithm can deeply compare private data defined in your classes), or if you need very specific behavior (e.g. should `+0` equal `-0` or not? Will you only compare an object's string keys, or will you include symbol keys too? etc).\n\nHere's a simple version to get you started - it shows examples of how you would compare a handful of different types of data. It's up to you to add, remove, or tweak functionality as needed. Note that this version does not support circular references - if you need to support that, you'll additionally need to keep around a set containing each value you've visited to make sure you're not going in a loop.\n\n```javascript\nconst isPrimitive = value => value !== Object(value);\n\nconst isPlainObject = value => (\n  value != null &&\n  [null, Object.prototype].includes(Object.getPrototypeOf(value))\n);\n\nfunction isEqual(value1, value2) {\n  // Each type corresponds to a particular comparison algorithm\n  const getType = value => {\n    if (isPrimitive(value)) return 'primitive';\n    if (Array.isArray(value)) return 'array';\n    if (value instanceof Map) return 'map';\n    if (isPlainObject(value)) return 'plainObject';\n    throw new Error(`deeply comparing an instance of type ${value1.constructor?.name} is not supported.`);\n  };\n\n  const type = getType(value1);\n  if (type !== getType(value2)) {\n    return false;\n  }\n\n  if (type === 'primitive') {\n    return (\n      value1 === value2 ||\n      (Number.isNaN(value1) && Number.isNaN(value2))\n    );\n  } else if (type === 'array') {\n    return (\n      value1.length === value2.length &&\n      value1.every((iterValue, i) => isEqual(iterValue, value2[i]))\n    );\n  } else if (type === 'map') {\n    // In this particular implementation, map keys are not\n    // being deeply compared, only map values.\n    return (\n      value1.size === value2.size &&\n      [...value1].every(([iterKey, iterValue]) => {\n        return value2.has(iterKey) && isEqual(iterValue, value2.get(iterKey));\n      })\n    );\n  } else if (type === 'plainObject') {\n    const value1AsMap = new Map(Object.entries(value1));\n    const value2AsMap = new Map(Object.entries(value2));\n    return (\n      value1AsMap.size === value2AsMap.size &&\n      [...value1AsMap].every(([iterKey, iterValue]) => {\n        return value2AsMap.has(iterKey) && isEqual(iterValue, value2AsMap.get(iterKey));\n      })\n    );\n  } else {\n    throw new Error(`Unreachable`);\n  }\n}\n```\n\nIf you're dealing with JSON-serializable data (i.e. data that does not contain values like `Date` instances or `undefined`), and you're not working in performance-sensitive code, you could also use the simpler solution of `JSON.stringify()`ing the two values and comparing the strings. You'll need to supply a `replacer` function to sort object keys before converting the object to JSON.\n\n```javascript\nfunction sortObjKeysReplacer(key, maybeObj) {\n  if (typeof maybeObj !== 'object' || maybeObj === null) return maybeObj;\n\n  return Object.fromEntries(\n    Object.entries(maybeObj)\n      .sort((a, b) => a[0] > b[0] ? 1 : -1)\n  );\n}\n\nfunction isEqual(value1, value2) {\n  const jsonValue1 = JSON.stringify(value1, sortObjKeysReplacer);\n  const jsonValue2 = JSON.stringify(value2, sortObjKeysReplacer);\n  return jsonValue1 === jsonValue2;\n}\n```\n","src":null,"test":""},{"name":"isEqualWith","manifest":{"fnSignature":"_.isEqualWith(value, other, [customizer])","lodashLink":"https://lodash.com/docs/4.17.15#isEqualWith","summary":"This method is like `_.isEqual` except that it accepts `customizer` which is invoked to compare values. If `customizer` returns `undefined`, comparisons are handled by the method instead."},"description":"Like with `_.isEqual()`, deep comparison algorithms need to be hand-built according to your use-cases. Lodash's `_.isEqualWith()` can be convenient to help with some use cases, but it won't cover everything (e.g. it can't peer into private data).\n\nHere's a simple version to get you started - it shows examples of how you would compare a handful of different types of data. It's up to you to add, remove, or tweak functionality as needed. Note that this version does not support circular references - if you need to support that, you'll additionally need to keep around a set containing each value you've visited to make sure you're not going in a loop.\n\n```javascript\nconst isPrimitive = value => value !== Object(value);\n\nconst isPlainObject = value => (\n  value != null &&\n  [null, Object.prototype].includes(Object.getPrototypeOf(value))\n);\n\nfunction isEqualWith(value1, value2, customizer, _parentNodeInfo = undefined) {\n  // Each type corresponds to a particular comparison algorithm\n  const getType = value => {\n    if (isPrimitive(value)) return 'primitive';\n    if (Array.isArray(value)) return 'array';\n    if (isPlainObject(value)) return 'plainObject';\n    throw new Error(`deeply comparing an instance of type ${value1.constructor?.name} is not supported.`);\n  };\n\n  // Checks with the customizer() function to see if it\n  // wants to override the default comparison behavior\n  {\n    let customizerResult;\n    if (_parentNodeInfo === undefined) {\n      customizerResult = customizer(value1, value2);\n    } else {\n      const { key, value1Parent, value2Parent } = _parentNodeInfo;\n      customizerResult = customizer(value1, value2, key, value1Parent, value2Parent);\n    }\n\n    if (customizerResult !== undefined) {\n      return customizerResult;\n    }\n  }\n\n  const type = getType(value1);\n  if (type !== getType(value2)) {\n    return false;\n  }\n\n  if (type === 'primitive') {\n    return (\n      value1 === value2 ||\n      (Number.isNaN(value1) && Number.isNaN(value2))\n    );\n  } else if (type === 'array') {\n    return (\n      value1.length === value2.length &&\n      value1.every(\n        (iterValue, i) => isEqualWith(\n          iterValue,\n          value2[i],\n          customizer,\n          { value1Parent: value1, value2Parent: value2, key: i }\n        )\n      )\n    );\n  } else if (type === 'plainObject') {\n    const value1AsMap = new Map(Object.entries(value1));\n    const value2AsMap = new Map(Object.entries(value2));\n    return (\n      value1AsMap.size === value2AsMap.size &&\n      [...value1AsMap].every(([iterKey, iterValue]) => {\n        return (\n          value2AsMap.has(iterKey) &&\n          isEqualWith(\n            iterValue,\n            value2AsMap.get(iterKey),\n            customizer,\n            { value1Parent: value1, value2Parent: value2, key: iterKey }\n          )\n        );\n      })\n    );\n  } else {\n    throw new Error('Unreachable');\n  }\n}\n```\n\nIn Lodash, the customizer function would be called with a sixth \"stack\" argument. Some probing shows that it's an instance of an internal \"Stack\" class that provides some methods which, presumably, can be used to gather information about the objects you're comparing. Due to the fact that this seems to be a rather complex feature that's entirely undocumented, it'll be assumed that the vast majority of users do not use this parameter, and so it's functionality won't be recreated here either.\n\nSpecial data types, like Maps and Sets, are not supported in the above example. This is partly because Lodash chooses to support them in a slightly odd way that you may not wish to mirror. For example:\n* The fourth or fifth argument to your customizer function is supposed to be the parent node, but if that parent node was a `Map` or `Set` instance, you'll instead receive arrays containing the node's contents (e.g. a map of usernames to ids would be turned into `[['Sally', 1], ['Zack', 2]]` before being provided to you).\n* When comparing two sets, like `new Set([1, 2, 3, 4])` and `new Set([5, 6, 7, 8])`, its going to call your `customizer` function _16_ different times (assuming the `customizer` function returns `false` or `undefined` each time). As your sets grow in length, the amount of times it has to call your customizer grows exponentially. Maps have a similar issue. This behavior is required to implement the general-purpose algorithm Lodash was going for, but maybe for your use-case you don't need your algorithm to be so general-purpose - maybe you can cut some corners to help with performance.\n","src":null,"test":""},{"name":"isError","manifest":{"fnSignature":"_.isError(value)","lodashLink":"https://lodash.com/docs/4.17.15#isError","summary":"Checks if value is an `Error`, `EvalError`, `RangeError`, `ReferenceError`, `SyntaxError`, `TypeError`, or `URIError` object."},"description":"Lodash's documentation makes it sound like they're checking if the value is specifically an instance of a set of built-in errors, but in reality, they're considering any [non-plain object](https://lodash.com/docs/4.17.15#isPlainObject) that has `message` and `name` properties that are strings to be errors. So, the following would return `true` despite not being an error.\n\n```javascript\nclass NotAnError {\n  name = 'NotAnError';\n  message = 'this is not an error';\n}\n\n_.isError(new NotAnError()); // true\n```\n\nIf you actually want to check if a value is an error or one of its subclasses (like `TypeError`, or a user-defined subclass), you can simply do this:\n\n```javascript\nvalue instanceof Error;\n```\n\nAnd if you want to check if a value is a specific error type (like `Error`, `TypeError`, or a user defined error), and you want to exclude subclasses, you can compare prototypes like this:\n\n```javascript\n// Replace `TypeError` with the Error class of your choice.\nObject.getPrototypeOf(value) === TypeError.prototype;\n```\n\nFor the vast majority of scenarios the above should be good enough, but those solutions do technically have a couple of flaws:\n1. they don't work with cross-realm values. For example, if you receive an instance of an `Error` from across an iframe boundary, that instance's prototype would link to the iframe's `Error` class, not your `Error` class, and both of the above checks would fail to recognize it as a `Error`.\n2. They will state that `Object.create(Error.prototype)` is an `Error`, but it's not. It's just a regular object who's prototype has been set to `Error.prototype`.\n\nBoth of these issues can be solved with a helper function like this:\n\n```javascript\n// An isError() check that supports cross-realm Errors.\nfunction isError(value) {\n  // DOMException and its subclasses will set a `Symbol.toStringTag` property\n  // on their instances to the string 'DOMException'.\n  const errorAsString = Object.prototype.toString.call(value);\n  return ['[object Error]', '[object DOMException]'].includes(errorAsString);\n}\n```\n\nThis helper function can unfortunately be spoofed by providing any object with a `Symbol.toStringTag` property set to one of the expected string tags, like this:\n\n```javascript\nisError({ [Symbol.toStringTag]: 'DOMException' }); // true\n```\n\nThere's not really anything that can be done to avoid this. You could try layering on additional checks, but there will always be a way to cause your `isError()` function to return a wrong answer.\n\nIf you're exclusively using Node, you can use `require('util').types.isNativeError(value)` to specifically check if the value is an instance of `Error` or one of its subclasses.\n\nSome very early JavaScript proposals may provide support for more robust ways to do cross-realm type checking:\n* [istypes](https://github.com/jasnell/proposal-istypes)\n* [Pattern matching's built-in matchers](https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1)\n","src":null,"test":""},{"name":"isFinite","manifest":{"fnSignature":"_.isFinite(value)","lodashLink":"https://lodash.com/docs/4.17.15#isFinite","summary":"Checks if `value` is a finite primitive number."},"description":"```javascript\nNumber.isFinite(value);\n```\n","src":null,"test":""},{"name":"isFunction","manifest":{"fnSignature":"_.isFunction(value)","lodashLink":"https://lodash.com/docs/4.17.15#isFunction","summary":"Checks if `value` is classified as a `Function` object."},"description":"```javascript\ntypeof value === 'function';\n```\n\nNote that `typeof Function.prototype` is also `'function'`. While it may be overkill, you can use a helper function like the following to exclude `Function.prototype`.\n\n```javascript\nfunction isFunction(value) {\n  const protoOf = Object.getPrototypeOf;\n  return (\n    typeof value === 'function' &&\n    protoOf(protoOf(value)) !== null // Make sure Function.prototype was not passed in\n  )\n}\n```\n","src":null,"test":""},{"name":"isInteger","manifest":{"fnSignature":"_.isInteger(value)","lodashLink":"https://lodash.com/docs/4.17.15#isInteger","summary":"Checks if `value` is an integer."},"description":"```javascript\nNumber.isInteger(value);\n```\n","src":null,"test":""},{"name":"isLength","manifest":{"fnSignature":"_.isLength(value)","lodashLink":"https://lodash.com/docs/4.17.15#isLength","summary":"Checks if `value` is a valid array-like length."},"description":"```javascript\nNumber.isInteger(value) && value >= 0;\n```\n","src":null,"test":"function isLength(value) {\n  return Number.isInteger(value) && value >= 0;\n}\n\ndescribe('isLength()', () => {\n  it('returns true on positive integers', () => {\n    expect(isLength(2)).toBe(true);\n  });\n\n  it('returns true on the number 0', () => {\n    expect(isLength(0)).toBe(true);\n  });\n\n  it('returns false on strings', () => {\n    expect(isLength('2')).toBe(false);\n  });\n\n  it('returns false with Infinity', () => {\n    expect(isLength(Infinity)).toBe(false);\n  });\n\n  it('returns false with NaN', () => {\n    expect(isLength(NaN)).toBe(false);\n  });\n\n  it('returns false with floats', () => {\n    expect(isLength(2.3)).toBe(false);\n  });\n\n  it('returns false with large numbers (as those are represented as floats)', () => {\n    expect(isLength(2e999)).toBe(false);\n  });\n});\n"},{"name":"isMap","manifest":{"fnSignature":"_.isMap(value)","lodashLink":"https://lodash.com/docs/4.17.15#isMap","summary":"Checks if `value` is classified as a `Map` object."},"description":"To check if your value is an instance of `Map`:\n\n```javascript\nvalue instanceof Map;\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nIt's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:\n\n```javascript\nObject.getPrototypeOf(value) === Map.prototype;\n```\n\nBoth of the above type-detection mechanisms have a couple of flaws:\n1. they don't work with cross-realm values. For example, if you receive an instance of a `Map` from across an iframe boundary, that instance's prototype would link to the iframe's `Map` class, not your `Map` class, and both of the above checks would fail to recognize it as a `Map`.\n2. They will state that `Object.create(Map.prototype)` is a `Map`, but it's not. It's just a regular object who's prototype has been set to `Map.prototype`.\n\nBoth of these issues can be solved with a helper function like this:\n\n```javascript\n// An isMap() check that supports cross-realm Maps.\nfunction isMap(value) {\n  try {\n    // If you call a Map method, like .get(),\n    // with a \"this\" value that's anything\n    // other than a Map, a TypeError is thrown.\n    Map.prototype.get.call(value, undefined);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nIf you additionally need to ensure your are not receiving a `Map` instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace `return true;` with the following:\n\n```javascript\n// A Map's prototype's chain should be\n// value -> Map.prototype -> Object.prototype -> null\n// If it's not, then we're dealing with a Map subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n```\n\nLodash's `_.isMap()` also supports cross-realm `Map` checks, but it uses a less robust algorithm that can be easily fooled. For example, if you run Lodash in the browser, the following will return the wrong answer.\n\n```javascript\n_.isMap({ get [Symbol.toStringTag]() { return 'Map' } }); // true\n```\n\nIn Node, Lodash will instead use `require('util').types.isMap(value)` for it's implementation, which you are also welcome to use if you know your code will only run in Node. This solution will also return `true` for subclasses.\n\nSome very early JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:\n* [istypes](https://github.com/jasnell/proposal-istypes)\n* [Pattern matching's built-in matchers](https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1)\n","src":null,"test":""},{"name":"isNaN","manifest":{"fnSignature":"_.isNaN(value)","lodashLink":"https://lodash.com/docs/4.17.15#isMap","summary":"Checks if `value` is NaN. **Note:** This method is based on `Number.isNaN` and is not the same as global `isNaN` which returns `true` for `undefined` and other non-number values."},"description":"```javascript\nNumber.isNaN(value);\n```\n\nNote that `Number.isNaN()` differs from the global `isNaN()` function in that the global `isNaN()` can only be used with numeric values. Non-numeric values will be coerced into numbers, potentially yielding wrong answers.\n\n```javascript\nisNaN(undefined); // true\nNumber.isNaN(undefined); // false\n```\n","src":null,"test":""},{"name":"isNative","manifest":{"fnSignature":"_.isNative(value)","lodashLink":"https://lodash.com/docs/4.17.15#isNative","summary":"Checks if `value` is a pristine native function."},"description":"```javascript\nfunction isNative(value) {\n  if (typeof value !== 'function') {\n    return false;\n  }\n\n  const nativeFnPattern = /^function.*?\\(\\) \\{ \\[native code\\] \\}$/;\n  const valueAsString = Function.prototype.toString.call(value);\n  return nativeFnPattern.test(valueAsString);\n}\n```\n\nSome good things to know about both this implementation and Lodash's `_.isNative()`:\n* The return value of `yourNonNativeFunction.bind()` is considered a native function.\n* Not all of Node's built-in functions will be considered native, for example, in Node 18, `Function.prototype.toString.call(setTimeout)` will return the source code for the function instead of the regular `function setTimeout() { [native code] }`. This is likely due to the fact that many of Node's standard library functions are implemented in JavaScript itself.\n\nOn [Lodash's website](https://lodash.com/docs/4.17.15#isNative) you'll also see a warning about how their `_.isNative()` functions are unable to tell the difference between a core.js function and a native one, so if it detects that you are using core.js, their `_.isNative()` will always throw. The above `isNative()` is also unable to tell the difference between a core.js polyfilled function and a native one.\n\nEvery code snippet provided in Snap.js is operating under the assumption that the standard library is pristine and untouched, and the above `isNative()` operates under the same assumption. As long as no one is monkey-patching the standard library, the `isNative()` function will work with any modern JavaScript engine just fine and can't be spoofed. The reason Core.js is capable of getting around these checks is because it monkey-patches `Function.prototype.toString` and replaces it with its own implementation. If you're worried about running in an environment where monkey-patching might be happening, the correct way to handle this (for any of the snap.js functions, and any code you write in general) is to locally cache the built-in functions you need when your code first loads. Then, as long as your library is imported before any monkey-patching happens, your code won't be affected by the monkey-patching at all. If your library loads after monkey patching has happened, then all bets are off - you just have to trust that your host was responsible with how they've been messing with the globals.\n\nHere's an example of how you can make the `isNative()` function in a more robust manner, so that if this module loads before core-js (or any other library that messes with the globals), it'll still work just fine. (Writing robust code as shown above adds a big toll on the readability and maintainability of your codebase - only use techniques like this when it's actually necessary).\n\n```javascript\nconst callBind = fn => fn.call.bind(fn);\n\nconst functionToString = callBind(Function.prototype.toString);\nconst regExpTest = callBind(RegExp.prototype.test);\n\nfunction isNative(value) {\n  if (typeof value !== 'function') {\n    return false;\n  }\n\n  const nativeFnPattern = /^function.*?\\(\\) \\{ \\[native code\\] \\}$/;\n  const valueAsString = functionToString(value);\n  return regExpTest(nativeFnPattern, valueAsString);\n}\n```\n\nLodash actually follows this robust code pattern throughout its library, it has just chosen to additionally check for the presence of core.js and throw an error if it found that core.js was loaded, just in case core.js loaded before lodash.\n","src":null,"test":""},{"name":"isNil","manifest":{"fnSignature":"_.isNil(value)","lodashLink":"https://lodash.com/docs/4.17.15#isNil","summary":"Checks if `value` is `null` or `undefined`."},"description":"```javascript\nvalue == null;\n```\n\nIn general, you should never use loose equality (`==`) in JavaScript, however, many people like to make the comparison against `null` an exception to this rule because it's a convenient way to check for either `null` or `undefined` - a fairly common operation.\n\nAlternatively, if you wish to tailor to an audience who may be unfamiliar with the `== null` trick, the following would be the most explicit and easy-to-read way to go.\n\n```javascript\nvalue === null || value === undefined;\n```\n\nThere's also some who like using the nullish coalescing operator (`??`) to get similar behavior.\n\n```javascript\n(value ?? null) === null;\n```\n","src":null,"test":""},{"name":"isNumber","manifest":{"fnSignature":"_.isNumber(value)","lodashLink":"https://lodash.com/docs/4.17.15#isNumber","summary":"Checks if `value` is classified as a `Number` primitive or object. **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified as numbers, use the `_.isFinite` method."},"description":"To check if a value is a number primitive:\n\n```javascript\ntypeof value === 'number';\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nLodash will also check if the value is a number object. In practice, such objects should never be found in your codebase, and if someone ever tries to hand such an object to you you really ought to treat it the same way you would treat any other bad input (throw an error, or if you aren't explicitly trying to check for bad inputs just let your library fall over, the same way it would with any other bad input).\n\nTo check if something is specifically a number object (and not a primitive), use the following:\n\n```javascript\nvalue instanceof Number;\n```\n\nThis, however, doesn't work cross realm (i.e. a number object created from inside an iframe would fail this check). It also would incorrectly state that `Object.create(Number.prototype)` is a number object, when in reality, it's just a normal object who's prototype is set to `Number.prototype`. If you need to worry about these kinds of issues, use the following solution instead:\n\n```javascript\n// An isNumber() check that supports cross-realm Number instances.\n// This will check if `value` is a number primitive or object.\n// Returns `true` for values that inherit from `Number` as well.\nfunction isNumber(value) {\n  try {\n    // If you call this method with a \"this\" value that's anything\n    // other than a Number primitive or object, a TypeError is thrown.\n    Number.prototype.valueOf.call(value);\n    // Makes sure Number.prototype was not passed in.\n    const protoOf = Object.getPrototypeOf;\n    return protoOf(protoOf(value)) !== null;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nLodash's `_.isNumber()` also supports cross-realm Number object checks, but it uses a less robust algorithm that can be easily fooled. For example, the following will return the wrong answer.\n\n```javascript\n_.isNumber({ get [Symbol.toStringTag]() { return 'Number' } }); // true\n```\n\nIf you're exclusively using Node, you can use `require('util').types.isNumberObject(value)` to specifically check if the value is a number object (not a primitive). This solution will also return `true` for both subclasses and `Number.prototype`.\n","src":null,"test":""},{"name":"isObject","manifest":{"fnSignature":"_.isObject(value)","lodashLink":"https://lodash.com/docs/4.17.15#isObject","summary":"Checks if `value` is the language type of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)"},"description":"All of these solutions are equivalent. Pick the one you find to be the most readable.\n\n```javascript\nconst isObject = value => value === Object(value);\n\nconst isObject = value => ['object', 'function'].includes(typeof value) && value !== null;\n\nconst isObject = value => typeof value === 'function' || (typeof value === 'object' && value !== null);\n```","src":null,"test":""},{"name":"isObjectLike","manifest":{"fnSignature":"_.isObjectLike(value)","lodashLink":"https://lodash.com/docs/4.17.15#isObjectLike","summary":"Checks if `value` is object-like. A value is object-like if it's not `null` and has a `typeof` result of \"object\"."},"description":"```javascript\nconst isObjectLike = value => typeof value === 'object' && value !== null;\n```\n\n`_.isObjectLike()` is really the same thing as `_.isObject()` except that it excludes functions. You could be more explicit about this by naming the function something like `isObjectButNotFunction()`, or by spelling this out in code at the usage site as follows:\n\n```javascript\nconst isObject = value => value === Object(value);\n\nif (isObject(value) && typeof value !== 'function') { ... }\n```\n","src":null,"test":""},{"name":"isPlainObject","manifest":{"fnSignature":"_.isPlainObject(value)","lodashLink":"https://lodash.com/docs/4.17.15#isPlainObject","summary":"Checks if `value` is a plain object, that is, an object created by the `Object` constructor or one with a `[[Prototype]]` of `null`."},"description":"To check if your value is a \"plain object\" like `{ x: 2 }`\n\n```javascript\nvalue != null && [null, Object.prototype].includes(Object.getPrototypeOf(value));\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nThe above type-detection mechanisms has the flaw that it does not work with cross-realm values. For example, if you receive an object from across an iframe boundary, that object's prototype would link to the iframe's `Object`, not your `Object`, and the above checks would fail to recognize it as a plain object. A cross-realm compatible solution could look something like this (depending how spoof-proof you want it to be):\n\n```javascript\nfunction isPlainObject(value) {\n  if (value == null) {\n    return false;\n  }\n\n  const protoOf = Object.getPrototypeOf;\n  if (protoOf(value) === null) {\n    return true;\n  }\n\n  const objectConstructorAsString = 'function Object() { [native code] }';\n  return (\n    protoOf(protoOf(value)) === null &&\n    typeof protoOf(value).constructor === 'function' &&\n    Function.prototype.toString.call(protoOf(value).constructor) === objectConstructorAsString\n  );\n}\n```\n\nUnfortunately you can't have an is-plain-object check that's both cross-realm-compatible and spoof-proof. The algorithm presented above can be spoofed as follows:\n\n```javascript\nclass SpecialClass {\n  static {\n    Object.setPrototypeOf(SpecialClass.prototype, null)\n    // This doesn't literally change the class's constructor,\n    // it just changes an informational property to be a lie.\n    SpecialClass.prototype.constructor = Object;\n  }\n}\n\nisPlainObject(new SpecialClass()); // true\n```\n\nEven Lodash's algorithm can be spoofed.\n\n```javascript\nclass SpecialClass {\n  static {\n    SpecialClass.prototype.constructor = Object;\n  }\n}\n\n_.isPlainObject(new SpecialClass()); // true\n```\n\nSome very early JavaScript proposals may provide support for cross-realm type checking:\n* [istypes](https://github.com/jasnell/proposal-istypes)\n* [Pattern matching's built-in matchers](https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1)\n","src":null,"test":""},{"name":"isRegExp","manifest":{"fnSignature":"_.isRegExp(value)","lodashLink":"https://lodash.com/docs/4.17.15#isRegExp","summary":"Checks if `value` is classified as a `RegExp` object."},"description":"To check if your value is a regular expression instance:\n\n```javascript\nvalue instanceof RegExp;\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nIt's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:\n\n```javascript\nObject.getPrototypeOf(value) === RegExp.prototype;\n```\n\nBoth of the above type-detection mechanisms have a couple of flaws:\n1. they don't work with cross-realm values. For example, if you receive an instance of `RegExp` from across an iframe boundary, that instance's prototype would link to the iframe's `RegExp` class, not your `RegExp` class, and both of the above checks would fail to recognize it as an RegExp instance.\n2. They will state that `Object.create(RegExp.prototype)` is a regular expression instance, but it's not. It's just a regular object who's prototype has been set to `RegExp.prototype`.\n\nBoth of these issues can be solved with a helper functions such as this:\n\n```javascript\nclass StringifyError extends Error {}\n\n// An isRegExp() check that supports cross-realm RegExp instances.\n// This solution is loosely inspired by https://github.com/inspect-js/is-regex's implementation.\nfunction isRegExp(value) {\n  // An argument that throws when stringified will be used\n  // to prevent exec() from completing and updating value.lastIndex.\n  const badArgument = {\n    toString() { throw new StringifyError(); }\n  }\n\n  try {\n    // Calling the `.exec()` method,\n    // with a \"this\" value that's anything\n    // other than a RegExpr will throw a TypeError.\n    RegExp.prototype.exec.call(value, badArgument);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    } else if (error instanceof StringifyError) {\n      return true;\n    } else {\n      throw error;\n    }\n  }\n}\n```\n\nIf you additionally need to ensure your are not receiving a `RegExp` instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace `return true;` with the following:\n\n```javascript\n// A RegExp's prototype's chain should be\n// value -> RegExp.prototype -> Object.prototype -> null\n// If it's not, then we're dealing with a RegExp subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n```\n\nLodash's `_.isRegExp()` also supports cross-realm `RegExp` checks, but it uses a less robust algorithm that can be easily fooled. For example, if you run Lodash in the browser, the following will return the wrong answer.\n\n```javascript\n_.isRegExp({ get [Symbol.toStringTag]() { return 'RegExp' } }); // true\n```\n\nIn Node, Lodash will instead use `require('util').types.isRegExp(value)` for it's implementation, which you are also welcome to use if you know your code will only run in Node. This solution will also return `true` for subclasses.\n\nSome very early JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:\n* [istypes](https://github.com/jasnell/proposal-istypes)\n* [Pattern matching's built-in matchers](https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1)\n","src":null,"test":""},{"name":"isSafeInteger","manifest":{"fnSignature":"_.isSafeInteger(value)","lodashLink":"https://lodash.com/docs/4.17.15#isSafeInteger","summary":"Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754 double precision number which isn't the result of a rounded unsafe integer."},"description":"```javascript\nNumber.isSafeInteger(value);\n```\n","src":null,"test":""},{"name":"isSet","manifest":{"fnSignature":"_.isSet(value)","lodashLink":"https://lodash.com/docs/4.17.15#isSet","summary":"Checks if `value` is classified as a `Set` object."},"description":"To check if your value is an instance of `Set`:\n\n```javascript\nvalue instanceof Set;\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nIt's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:\n\n```javascript\nObject.getPrototypeOf(value) === Set.prototype;\n```\n\nBoth of the above type-detection mechanisms have a couple of flaws:\n1. they don't work with cross-realm values. For example, if you receive an instance of a `Set` from across an iframe boundary, that instance's prototype would link to the iframe's `Set` class, not your `Set` class, and both of the above checks would fail to recognize it as a `Set`.\n2. They will state that `Object.create(Set.prototype)` is a `Set`, but it's not. It's just a regular object who's prototype has been set to `Set.prototype`.\n\nBoth of these issues can be solved with a helper function like this:\n\n```javascript\n// An isSet() check that supports cross-realm Sets.\nfunction isSet(value) {\n  try {\n    // If you call a Set method, like .size(),\n    // with a \"this\" value that's anything\n    // other than a Set, a TypeError is thrown.\n    Set.prototype.has.call(value, undefined);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nIf you additionally need to ensure your are not receiving a `Set` instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace `return true;` with the following:\n\n```javascript\n// A Set's prototype's chain should be\n// value -> Set.prototype -> Object.prototype -> null\n// If it's not, then we're dealing with a Set subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n```\n\nLodash's `_.isSet()` also supports cross-realm `Set` checks, but it uses a less robust algorithm that can be easily fooled. For example, if you run Lodash in the browser, the following will return the wrong answer.\n\n```javascript\n_.isSet({ get [Symbol.toStringTag]() { return 'Set' } }); // true\n```\n\nIn Node, Lodash will instead use `require('util').types.isSet(value)` for it's implementation, which you are also welcome to use if you know your code will only run in Node. This solution will also return `true` for subclasses.\n\nSome very early JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:\n* [istypes](https://github.com/jasnell/proposal-istypes)\n* [Pattern matching's built-in matchers](https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1)\n","src":null,"test":""},{"name":"isString","manifest":{"fnSignature":"_.isString(value)","lodashLink":"https://lodash.com/docs/4.17.15#isString","summary":"Checks if `value` is classified as a `string` primitive or object."},"description":"To check if a value is a string primitive:\n\n```javascript\ntypeof value === 'string';\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nLodash will also check if the value is a string object. In practice, such objects should never be found in your codebase, and if someone ever tries to hand such an object to you you really ought to treat it the same way you would treat any other bad input (throw an error, or if you aren't explicitly trying to check for bad inputs just let your library fall over, the same way it would with any other bad input).\n\nTo check if something is specifically a string object (and not a primitive), use the following:\n\n```javascript\nvalue instanceof Boolean;\n```\n\nThis, however, doesn't work cross realm (i.e. a string object created from inside an iframe would fail this check). It also would incorrectly state that `Object.create(String.prototype)` is a string object, when in reality, it's just a normal object who's prototype is set to `String.prototype`. If you need to worry about these kinds of issues, use the following solution instead:\n\n```javascript\n// An isString() check that supports cross-realm String instances.\n// This will check if `value` is a string primitive or object.\n// Returns `true` for values that inherit from `String` as well.\nfunction isString(value) {\n  try {\n    // If you call this method with a \"this\" value that's anything\n    // other than a boolean primitive or object, a TypeError is thrown.\n    String.prototype.toString.call(value);\n    // Makes sure String.prototype was not passed in.\n    const protoOf = Object.getPrototypeOf;\n    return protoOf(protoOf(value)) !== null;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nLodash's `_.isString()` also supports cross-realm `String` object checks, but it uses a less robust algorithm that can be easily fooled. For example, the following will return the wrong answer.\n\n```javascript\n_.isString({ get [Symbol.toStringTag]() { return 'String' } }); // true\n```\n\nIf you're exclusively using Node, you can use `require('util').types.isStringObject(value)` to specifically check if the value is a string object (not a primitive). This solution will also return `true` for both subclasses and `Boolean.prototype`.","src":null,"test":""},{"name":"isSymbol","manifest":{"fnSignature":"_.isSymbol(value)","lodashLink":"https://lodash.com/docs/4.17.15#isSymbol","summary":"Checks if `value` is classified as a `symbol` primitive or object."},"description":"To check if a value is a symbol primitive:\n\n```javascript\ntypeof value === 'symbol';\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nLodash will also check if the value is a symbol object. In practice, such objects should never be found in your codebase, and if someone ever tries to hand such an object to you you really ought to treat it the same way you would treat any other bad input (throw an error, or if you aren't explicitly trying to check for bad inputs just let your library fall over, the same way it would with any other bad input).\n\nTo check if something is specifically a symbol object (and not a primitive), use the following:\n\n```javascript\nvalue instanceof Symbol;\n```\n\nThis, however, doesn't work cross realm (i.e. a symbol object created from inside an iframe would fail this check). It also would incorrectly state that `Object.create(Symbol.prototype)` is a symbol object, when in reality, it's just a normal object who's prototype is set to `Symbol.prototype`. If you need to worry about these kinds of issues, use the following solution instead:\n\n```javascript\n// An isSymbol() check that supports cross-realm Symbol instances.\n// This will check if `value` is a symbol primitive or object.\nfunction isSymbol(value) {\n  try {\n    // If you call this method with a \"this\" value that's anything\n    // other than a boolean primitive or object, a TypeError is thrown.\n    Symbol.prototype.valueOf.call(value);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nLodash's `_.isSymbol()` also supports cross-realm `Symbol` object checks, but it uses a less robust algorithm that can be easily fooled. For example, the following will return the wrong answer.\n\n```javascript\n_.isSymbol({ get [Symbol.toStringTag]() { return 'Symbol' } }); // true\n```\n\nIf you're exclusively using Node, you can use `require('util').types.isSymbolObject(value)` to specifically check if the value is a string object (not a primitive).","src":null,"test":""},{"name":"isTypedArray","manifest":{"fnSignature":"_.isTypedArray(value)","lodashLink":"https://lodash.com/docs/4.17.15#isTypedArray","summary":"Checks if `value` is classified as a typed array."},"description":"All concrete type array classes (like `Int8Array` and `Uint32Array`) inherit from the same abstract superclass `TypedArray`. This superclass isn't directly available on the global object, but it's not too hard to get your hands on it. You can use the `TypedArray` superclass to check if a value is a typed array as follows:\n\n```javascript\nfunction isTypedArray(value) {\n  // Get the super class of all typed arrays.\n  const TypedArray = Object.getPrototypeOf(Int8Array);\n\n  return value instanceof TypedArray;\n}\n\nisTypedArray(new Int8Array()); // true\nisTypedArray(new Uint32Array()); // true\n```\n\nFor the vast majority of scenarios the above should be good enough, but it does technically have a couple of flaws:\n1. they don't work with cross-realm values. For example, if you receive an instance of an `Int8Array` from across an iframe boundary, that instance's prototype would link to the iframe's `TypedArray` class, not your `TypedArray` class, and both of the above checks would fail to recognize it as a typed array.\n2. They will state that `Object.create(TypedArray.prototype)` is a `TypedArray`, but it's not. It's just a regular object who's prototype has been set to `TypedArray.prototype`.\n\nBoth of these issues can be solved with a helper function like this:\n\n```javascript\n// An isTypedArray() check that supports cross-realm typed arrays.\nfunction isTypedArray(value) {\n  const TypedArray = Object.getPrototypeOf(Int8Array);\n  try {\n    // If you call a TypedArray method, like .at(),\n    // with a \"this\" value that's anything\n    // other than a typed array, a TypeError is thrown.\n    TypedArray.prototype.at.call(value, 0);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nIt's generally considered a bad practice to subclass built-ins, but if you suspect that one of the concrete typed array classes might getting subclassed and handed to you, and you wish to exclude subclasses from your check, you'd also need to walk up the prototype chain. You can modify the above example and replace `return true;` with the following:\n\n```javascript\n// A typed array prototype's chain should be\n// value -> concrete class prototype (like Int8Array.prototype) -> TypedArray.prototype -> Object.prototype -> null\n// If it's not, then we're dealing with a subclass of a concrete typed array.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(protoOf(value)))) === null;\n```\n\nLodash's `_.isTypedArray()` also supports cross-realm typed array checks, but it uses a less robust algorithm that can be easily fooled. For example, if you run Lodash in the browser, the following will return the wrong answer.\n\n```javascript\n_.isTypedArray({ length: 0, get [Symbol.toStringTag]() { return 'Uint8Array' } }); // true\n```\n\nIn Node, Lodash will instead use `require('util').types.isTypedArray(value)` for it's implementation, which you are also welcome to use if you know your code will only run in Node. This solution will also return `true` for subclasses.\n\nSome very early JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:\n* [istypes](https://github.com/jasnell/proposal-istypes)\n* [Pattern matching's built-in matchers](https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1)\n","src":null,"test":""},{"name":"isUndefined","manifest":{"fnSignature":"_.isUndefined(value)","lodashLink":"https://lodash.com/docs/4.17.15#isUndefined","summary":"Checks if `value` is `undefined`."},"description":"```javascript\nvalue === undefined;\n```","src":null,"test":""},{"name":"isWeakMap","manifest":{"fnSignature":"_.isWeakMap(value)","lodashLink":"https://lodash.com/docs/4.17.15#isWeakMap","summary":"Checks if `value` is classified as a `WeakMap` object."},"description":"To check if your value is an instance of `WeakMap`:\n\n```javascript\nvalue instanceof WeakMap;\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nIt's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:\n\n```javascript\nObject.getPrototypeOf(value) === WeakMap.prototype;\n```\n\nBoth of the above type-detection mechanisms have a couple of flaws:\n1. they don't work with cross-realm values. For example, if you receive an instance of a `WeakMap` from across an iframe boundary, that instance's prototype would link to the iframe's `WeakMap` class, not your `WeakMap` class, and both of the above checks would fail to recognize it as a `WeakMap`.\n2. They will state that `Object.create(WeakMap.prototype)` is a `WeakMap`, but it's not. It's just a regular object who's prototype has been set to `WeakMap.prototype`.\n\nBoth of these issues can be solved with a helper function like this:\n\n```javascript\n// An isWeakMap() check that supports cross-realm WeakMaps.\nfunction isWeakMap(value) {\n  try {\n    // If you call a WeakMap method, like .get(),\n    // with a \"this\" value that's anything\n    // other than a WeakMap, a TypeError is thrown.\n    WeakMap.prototype.get.call(value, undefined);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nIf you additionally need to ensure your are not receiving a `WeakMap` instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace `return true;` with the following:\n\n```javascript\n// A WeakMap's prototype's chain should be\n// value -> WeakMap.prototype -> Object.prototype -> null\n// If it's not, then we're dealing with a WeakMap subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n```\n\nLodash's `_.isWeakMap()` also supports cross-realm `WeakMap` checks, but it uses a less robust algorithm that can be easily fooled. For example, the following will return the wrong answer.\n\n```javascript\n_.isWeakMap({ get [Symbol.toStringTag]() { return 'WeakMap' } }); // true\n```\n\nIf you're exclusively using Node, you can use `require('util').types.isWeakMap(value)` to specifically check if the value is a WeakMap. This solution will also return `true` for subclasses.\n\nSome very early JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:\n* [istypes](https://github.com/jasnell/proposal-istypes)\n* [Pattern matching's built-in matchers](https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1)\n","src":null,"test":""},{"name":"isWeakSet","manifest":{"fnSignature":"_.isWeakSet(value)","lodashLink":"https://lodash.com/docs/4.17.15#isWeakSet","summary":"Checks if `value` is classified as a `WeakSet` object."},"description":"To check if your value is an instance of `WeakSet`:\n\n```javascript\nvalue instanceof WeakSet;\n```\n\nThe above should be good enough for the vast majority of use-cases.\n\nIt's generally considered a bad practice to subclass built-ins, but if you suspect that a subclass might be handed to you and you wish to exclude subclasses from your check, you can compare prototypes like this:\n\n```javascript\nObject.getPrototypeOf(value) === WeakSet.prototype;\n```\n\nBoth of the above type-detection mechanisms have a couple of flaws:\n1. they don't work with cross-realm values. For example, if you receive an instance of a `WeakSet` from across an iframe boundary, that instance's prototype would link to the iframe's `WeakSet` class, not your `WeakSet` class, and both of the above checks would fail to recognize it as a `WeakSet`.\n2. They will state that `Object.create(WeakSet.prototype)` is a `WeakSet`, but it's not. It's just a regular object who's prototype has been set to `WeakSet.prototype`.\n\nBoth of these issues can be solved with a helper function like this:\n\n```javascript\n// An isWeakSet() check that supports cross-realm WeakSets.\nfunction isWeakSet(value) {\n  try {\n    // If you call a WeakSet method, like .has(),\n    // with a \"this\" value that's anything\n    // other than a WeakSet, a TypeError is thrown.\n    WeakSet.prototype.has.call(value, undefined);\n    return true;\n  } catch (error) {\n    if (error instanceof TypeError) {\n      return false;\n    }\n    throw error;\n  }\n}\n```\n\nIf you additionally need to ensure your are not receiving a `WeakSet` instance from an inherited class, you'd also need to walk up the prototype chain. You can modify the above example and replace `return true;` with the following:\n\n```javascript\n// A WeakSet's prototype's chain should be\n// value -> WeakSet.prototype -> Object.prototype -> null\n// If it's not, then we're dealing with a WeakSet subclass.\nconst protoOf = Object.getPrototypeOf;\nreturn protoOf(protoOf(protoOf(value))) === null;\n```\n\nLodash's `_.isWeakSet()` also supports cross-realm `WeakSet` checks, but it uses a less robust algorithm that can be easily fooled. For example, the following will return the wrong answer.\n\n```javascript\n_.isWeakSet({ get [Symbol.toStringTag]() { return 'WeakSet' } }); // true\n```\n\nIf you're exclusively using Node, you can use `require('util').types.isWeakSet(value)` to specifically check if the value is a WeakSet. This solution will also return `true` for subclasses.\n\nSome very early JavaScript proposals may provide support for more ergonomic ways to do cross-realm type checking:\n* [istypes](https://github.com/jasnell/proposal-istypes)\n* [Pattern matching's built-in matchers](https://github.com/tc39/proposal-pattern-matching#built-in-custom-matchers-1)\n","src":null,"test":""}]},{"categoryHeading":"Math","entries":[{"name":"add","manifest":{"fnSignature":"_.add(augend, addend)","lodashLink":"https://lodash.com/docs/4.17.15#add","summary":"Adds two numbers."},"description":"```javascript\naugend + addend;\n```\n\nOne reason `_.add()` exists, is because it's a ready-made function, that can easily be passed into other functions, like this:\n\n```javascript\n> _.reduce([2, 3, 4], _.add);\n9\n```\n\nWhen Lodash was first born, the only alternative at the time would be to create an entire function, using the `function` keyword.\n\n```javascript\n_.reduce([2, 3, 4], function (a, b) {\n  return a + b;\n});\n```\n\nSince then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.\n\n```javascript\n_.reduce([2, 3, 4], (a, b) => a + b);\n```\n","src":null,"test":""},{"name":"ceil","manifest":{"fnSignature":"_.ceil(number, precision?)","lodashLink":"https://lodash.com/docs/4.17.15#ceil","summary":"Computes `number` rounded up to `precision`."},"description":"If you don't need to use the optional precision argument, then you can simply use the following:\n\n```javascript\nMath.ceil(number);\n```\n\nOtherwise:\n\n```javascript\nfunction ceil(number, precision=0) {\n  const factor = 10**precision;\n  return Math.ceil(number * factor) / factor;\n}\n```","src":null,"test":""},{"name":"divide","manifest":{"fnSignature":"_.divide(dividend, divisor)","lodashLink":"https://lodash.com/docs/4.17.15#divide","summary":"Divide two numbers."},"description":"```javascript\naugend / addend;\n```\n\nOne reason `_.divide()` exists, is because it's a ready-made function, that can easily be passed into other functions, like this:\n\n```javascript\n> _.reduce([100, 2, 5], _.divide);\n10\n```\n\nWhen Lodash was first born, the only alternative at the time would be to create an entire function, using the `function` keyword.\n\n```javascript\n_.reduce([100, 2, 5], function (a, b) {\n  return a / b;\n});\n```\n\nSince then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.\n\n```javascript\n_.reduce([100, 2, 5], (a, b) => a / b);\n```\n","src":null,"test":""},{"name":"floor","manifest":{"fnSignature":"_.floor(number, precision?)","lodashLink":"https://lodash.com/docs/4.17.15#floor","summary":"Computes `number` rounded down to `precision`."},"description":"If you don't need to use the optional precision argument, then you can simply use the following:\n\n```javascript\nMath.floor(number);\n```\n\nOtherwise:\n\n```javascript\nfunction floor(number, precision=0) {\n  const factor = 10**precision;\n  return Math.floor(number * factor) / factor;\n}\n```","src":null,"test":""},{"name":"max","manifest":{"fnSignature":"_.max(array)","lodashLink":"https://lodash.com/docs/4.17.15#max","summary":"Computes the maximum value of array. If array is empty or falsey, undefined is returned."},"description":"```javascript\nMath.max(...array);\n```\n\nThere's a couple of very minor differences in behavior between Lodash's `_.max()`, and JavaScript's native `Math.max()` (apart from the fact that you have to spread your array into JavaScript's version).\n\n1. In Lodash's version, if you provide a falsey value, `undefined` will be returned. In JavaScript, if you try to spread a falsey value into `Math.max()`, you'll get a runtime error, because falsey values aren't iterable. In practice, this difference shouldn't matter much - you should know the types of values you're trying to use, and if you suspect that it might be falsey, just check for that before calling `Math.max()`, instead of checking if the result is undefined after calling `_.max()`.\n\n2. In Lodash's version, if you provide an empty array, `undefined` is returned. In JavaScript, if you spread an empty array, or you provide no arguments, `-Infinity` is returned. JavaScript's `-Infinity`, while, at first, may sound odd, can actually be a useful return value. It allows you to cleanly write many algorithms capable of operating on empty arrays, without having to explicitly check if the array is empty. Not everyone likes to write algorithms this way, but `Math.max()` gives you the option when it's wanted.","src":null,"test":""},{"name":"maxBy","manifest":{"fnSignature":"_.maxBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#maxBy","summary":"This method is like `_.max` except that it accepts `iteratee` which is invoked for each element in `array` to generate the criterion by which the value is ranked."},"description":"```javascript\nfunction maxBy(array, iteratee) {\n  if (array.length === 0) {\n    return undefined;\n  }\n\n  return array\n    .map(value => ({ value, score: iteratee(value) }))\n    .reduce((best, cur) => cur.score > best.score ? cur : best)\n    .value;\n}\n```\n","src":null,"test":""},{"name":"mean","manifest":{"fnSignature":"_.mean(array)","lodashLink":"https://lodash.com/docs/4.17.15#mean","summary":"Computes the mean of the values in array."},"description":"```javascript\nfunction mean(array) {\n  return array.reduce((a, b) => a + b) / array.length;\n}\n```\n","src":null,"test":""},{"name":"meanBy","manifest":{"fnSignature":"_.meanBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#meanBy","summary":"This method is like `_.mean` except that it accepts `iteratee` which is invoked for each element in `array` to generate the value to be averaged."},"description":"We will use a plain JavaScript implementation of `_.mean()` to solve this problem.\n\n```javascript\nfunction mean(array) {\n  return array.reduce((a, b) => a + b) / array.length;\n}\n\n// Uses `iteratee` on each element of the array, to convert them to\n// new values, before taking the mean.\nmean(array.map(iteratee));\n```\n","src":null,"test":""},{"name":"min","manifest":{"fnSignature":"_.min(array)","lodashLink":"https://lodash.com/docs/4.17.15#min","summary":"Computes the minimum value of `array`. If `array` is empty or falsey, `undefined` is returned."},"description":"```javascript\nMath.min(...array);\n```\n\nThere's a couple of very minor differences in behavior between Lodash's `_.min()`, and JavaScript's native `Math.min()` (apart from the fact that you have to spread your array into JavaScript's version).\n\n1. In Lodash's version, if you provide a falsey value, `undefined` will be returned. In JavaScript, if you try to spread a falsey value into `Math.min()`, you'll get a runtime error, because falsey values aren't iterable. In practice, this difference shouldn't matter much - you should know the types of values you're trying to use, and if you suspect that it might be falsey, just check for that before calling `Math.min()`, instead of checking if the result is undefined after calling `_.min()`.\n\n2. In Lodash's version, if you provide an empty array, `undefined` is returned. In JavaScript, if you spread an empty array, or you provide no arguments, `Infinity` is returned. JavaScript's `Infinity`, while, at first, may sound odd, can actually be a useful return value. It allows you to cleanly write many algorithms capable of operating on empty arrays, without having to explicitly check if the array is empty. Not everyone likes to write algorithms this way, but `Math.min()` gives you the option when it's wanted.","src":null,"test":""},{"name":"minBy","manifest":{"fnSignature":"_.minBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#minBy","summary":"This method is like `_.min` except that it accepts `iteratee` which is invoked for each element in `array` to generate the criterion by which the value is ranked."},"description":"```javascript\nfunction minBy(array, iteratee) {\n  if (array.length === 0) {\n    return undefined;\n  }\n\n  return array\n    .map(value => ({ value, score: iteratee(value) }))\n    .reduce((best, cur) => cur.score < best.score ? cur : best)\n    .value;\n}\n```\n","src":null,"test":""},{"name":"multiply","manifest":{"fnSignature":"_.multiply(multiplier, multiplicand)","lodashLink":"https://lodash.com/docs/4.17.15#multiply","summary":"Multiply two numbers."},"description":"```javascript\nmultiplier * multiplicand;\n```\n\nOne reason `_.multiply()` exists, is because it's a ready-made function, that can easily be passed into other functions, like this:\n\n```javascript\n> _.reduce([2, 3, 4], _.multiply);\n24\n```\n\nWhen Lodash was first born, the only alternative at the time would be to create an entire function, using the `function` keyword.\n\n```javascript\n_.reduce([2, 3, 4], function (a, b) {\n  return a * b;\n});\n```\n\nSince then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.\n\n```javascript\n_.reduce([2, 3, 4], (a, b) => a * b);\n```\n","src":null,"test":""},{"name":"round","manifest":{"fnSignature":"_.round(number, precision?)","lodashLink":"https://lodash.com/docs/4.17.15#round","summary":"Computes `number` rounded to `precision`."},"description":"If you don't need to use the optional precision argument, then you can simply use the following:\n\n```javascript\nMath.round(number);\n```\n\nOtherwise:\n\n```javascript\nfunction round(number, precision=0) {\n  const factor = 10**precision;\n  return Math.round(number * factor) / factor;\n}\n```\n","src":null,"test":""},{"name":"subtract","manifest":{"fnSignature":"_.subtract(minuend, subtrahend)","lodashLink":"https://lodash.com/docs/4.17.15#subtract","summary":"Subtract two numbers."},"description":"```javascript\nminuend - subtrahend;\n```\n\nOne reason `_.subtract()` exists, is because it's a ready-made function, that can easily be passed into other functions, like this:\n\n```javascript\n> _.reduce([10, 3, 4], _.subtract);\n3\n```\n\nWhen Lodash was first born, the only alternative at the time would be to create an entire function, using the `function` keyword.\n\n```javascript\n_.reduce([10, 3, 4], function (a, b) {\n  return a - b;\n});\n```\n\nSince then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.\n\n```javascript\n_.reduce([10, 3, 4], (a, b) => a - b);\n```\n","src":null,"test":""},{"name":"sum","manifest":{"fnSignature":"_.sum(array)","lodashLink":"https://lodash.com/docs/4.17.15#sum","summary":"Computes the sum of the values in `array`."},"description":"If you want an empty array to throw an error:\n\n```javascript\narray.reduce((a, b) => a + b);\n```\n\nIf you want an empty array to cause `0` to be returned:\n\n```javascript\narray.reduce((a, b) => a + b, 0);\n```\n","src":null,"test":""},{"name":"sumBy","manifest":{"fnSignature":"_.sumBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#sumBy","summary":"This method is like `_.sum` except that it accepts `iteratee` which is invoked for each element in `array` to generate the value to be summed."},"description":"Simply map over your array with `iteratee`, before trying to sum it:\n\n```javascript\narray\n  .map(iteratee)\n  .reduce((a, b) => a + b);\n```\n","src":null,"test":""}]},{"categoryHeading":"Number","entries":[{"name":"clamp","manifest":{"fnSignature":"_.clamp(number, lower?, upper)","lodashLink":"https://lodash.com/docs/4.17.15#clamp","summary":"Clamps number within the inclusive `lower` and `upper` bounds."},"description":"```javascript\nMath.max(Math.min(number, upper), lower);\n```\n","src":null,"test":""},{"name":"inRange","manifest":{"fnSignature":"_.inRange(number, start?, end)","lodashLink":"https://lodash.com/docs/4.17.15#clamp","summary":"Checks if `n` is between `start` and up to, but not including, `end`. If `start` is greater than `end` the params are swapped to support negative ranges."},"description":"To simply check if a number is between two others, use the following:\n\n```javascript\nstart <= number && number < end;\n```\n\nIf you're uncertain which of the two numbers are lower, use the following:\n\n```javascript\nfunction inRange(number, start, end) {\n  const bounds = start < end\n    ? [start, end]\n    : [end, start];\n\n  return bounds[0] <= number && number < bounds[1];\n}\n```\n","src":null,"test":""},{"name":"random","manifest":{"fnSignature":"_.random(lower?, upper?, floating?)","lodashLink":"https://lodash.com/docs/4.17.15#random","summary":"Produces a random number between the inclusive `lower` and `upper` bounds. If `floating` is true, or either `lower` or `upper` are floats, a floating-point number is returned instead of an integer."},"description":"## For random floats\n\nIf you want a random float between 0 and `upper`:\n\n```javascript\nMath.random() * upper;\n```\n\nIf you want a random float between `lower` and `upper`:\n\n```javascript\nlower + Math.random() * (upper - lower);\n```\n\n## For random integers\n\nAll of these examples will treat `upper` as exclusive, not inclusive. If you want it to be inclusive like it is in Lodash (i.e. you want it to be possible for the upper bound to be returned), add one to `upper`.\n\nIf you want a random integer between 0 and `upper`:\n\n```javascript\nMath.floor(Math.random() * upper);\n```\n\nIf you want a random integer between lower and upper:\n\n```javascript\nlower + Math.floor(Math.random() * (upper - lower));\n```\n","src":null,"test":""}]},{"categoryHeading":"Object","entries":[{"name":"assign","manifest":{"fnSignature":"_.assign(object, ...sources)","lodashLink":"https://lodash.com/docs/4.17.15#assign","summary":"Assigns own enumerable string keyed properties of source objects to the destination object."},"description":"```javascript\nObject.assign(object, sourceObj1, sourceObj2);\n```\n\nOr, if all you want to do is merge objects together, and you don't wish to mutate anything, you can use the spread syntax.\n\n```javascript\n{ ...sourceObj1, ...sourceObj2 };\n```","src":null,"test":""},{"name":"assignIn","manifest":{"fnSignature":"_.assignIn(object, ...sources)","lodashLink":"https://lodash.com/docs/4.17.15#assignIn","summary":"This method is like `_.assign` except that it iterates over own and inherited source properties."},"description":"```javascript\nfunction assignIn(object, ...sources) {\n  for (const source of sources) {\n    for (const key in source) {\n      object[key] = source[key];\n    }\n  }\n\n  return object;\n}\n```\n\nIt's very likely that you don't actually need this function. The only way this function is different from `_.assign()` (or `Object.assign()`), is that it'll also copy over non-enumerable inherited fields. But...\n1. Class syntax will automatically make all methods on the prototype chain non-enumerable, which means the `assignIn()` function won't copy them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n2. Why are you even trying to copy both the data and the inherited methods off of an object? If you want one object to share the same methods as another object, consider using normal inheritance.\n\nPerhaps there's some niche use-cases for this sort of function that arise from fairly abnormal and tricky uses of the JavaScript prototype, but, for day-to-day development, it's best to stay away from this function. If you just want to copy data over from one object to another, please look at `_.assign()` instead.\n","src":null,"test":""},{"name":"assignInWith","manifest":{"fnSignature":"_.assignInWith(object, ...sources, customizer)","lodashLink":"https://lodash.com/docs/4.17.15#assignInWith","summary":"This method is like `_.assignIn` except that it accepts `customizer` which is invoked to produce the assigned values. If `customizer` returns `undefined`, assignment is handled by the method instead."},"description":"```javascript\nfunction assignInWith(object, sources, customizer) {\n  for (const source of sources) {\n    for (const key in source) {\n      const customizerResult = customizer(object[key], value, key, object, source);\n      object[key] = customizerResult !== undefined ? customizerResult : source[key];\n    }\n  }\n\n  return object;\n}\n```\n\nIt's very likely that you don't actually need this function. The only way this function is different from `_.assignWith()`, is that it'll also copy over non-enumerable inherited fields. But class syntax will automatically make all methods on the prototype chain non-enumerable, which means the `assignInWith()` function won't copy them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n\nPerhaps there's some niche use-cases for this sort of function that arise from fairly abnormal and tricky uses of the JavaScript prototype, but, for day-to-day development, it's best to stay away from this function. If you just want to copy data over from one object to another with a customizer function (and don't need to worry about inherited fields), please look at the JavaScript equivalent to `_.assignWith()` instead.\n","src":null,"test":""},{"name":"assignWith","manifest":{"fnSignature":"_.assignWith(object, ...sources, customizer?)","lodashLink":"https://lodash.com/docs/4.17.15#assignWith","summary":"This method is like `_.assign` except that it accepts `customizer` which is invoked to produce the assigned values. If `customizer` returns `undefined`, assignment is handled by the method instead."},"description":"A complete implementation would look like this:\n\n```javascript\nfunction assignWith(object, sources, customizer) {\n  for (const source of sources) {\n    for (const [key, value] of Object.entries(source)) {\n      const customizerResult = customizer(object[key], value, key, object, source);\n      object[key] = customizerResult !== undefined ? customizerResult : source[key];\n    }\n  }\n\n  return object;\n}\n```\n\nHowever, it's possible that all you really need to do is map over your source objects before merging them, like this:\n\n```javascript\n// Merge your sources together, then map over each entry, updating them as you map over them.\nconst updatedEntries = Object.entries({ ...source1, ...source2, ...source3 })\n  .map(([key, value]) => [key, ...operate on `value` however you want...]);\n\n// Construct a new object from the mapped entries\nconst updatedSource = Object.fromEntries(updatedEntries);\n\n// If needed, assign the updated entries to `object`, mutating it so it contains this new data.\nObject.assign(object, updatedSource);\n```\n","src":null,"test":""},{"name":"at","manifest":{"fnSignature":"_.at(object, paths?)","lodashLink":"https://lodash.com/docs/4.17.15#at","summary":"Creates an array of values corresponding to `paths` of `object`."},"description":"We will use a plain JavaScript implementation of `_.get()` to solve this problem.\n\n```javascript\nfunction get(object, path, defaultValue = undefined) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  if (path.length === 0) {\n    return object;\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return defaultValue;\n  }\n\n  return get(object[head], tail, defaultValue);\n}\n\n// Maps over the paths array, fetching each field value from `object` corresponding to that path.\npaths.map(path => get(object, path));\n```\n\nOne of the primary reasons Lodash's `_.get()` function was commonly used, was as a way to easily access a nested property without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined, and the [nullish coalescing operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing) to provide a default value.\n\nFor example, these two are the same:\n\n```javascript\n_.get(obj, 'a.b', null);\n\nobj?.a?.b ?? null;\n```\n\nNote that the support for string paths in the above `get()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.get()` and `_.at()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"create","manifest":{"fnSignature":"_.create(prototype, properties?)","lodashLink":"https://lodash.com/docs/4.17.15#create","summary":"Creates an object that inherits from the `prototype` object. If a `properties` object is given, its own enumerable string keyed properties are assigned to the created object."},"description":"If you just need to create an object that inherits from another object:\n\n```javascript\nObject.create(prototype)\n```\n\nIf you also need to assign some fields to the newly created object, either of these options work:\n\n```javascript\nObject.assign(Object.create(prototype), properties);\n\nObject.create(prototype, Object.getOwnPropertyDescriptors(properties));\n```\n","src":null,"test":""},{"name":"defaults","manifest":{"fnSignature":"_.defaults(object, ...sources)","lodashLink":"https://lodash.com/docs/4.17.15#defaults","summary":"Assigns own and inherited enumerable string keyed properties of source objects to the destination object for all destination properties that resolve to `undefined`. Source objects are applied from left to right. Once a property is set, additional values of the same property are ignored."},"description":"There's a handful of different patterns that can be used when you need to apply default values to your object. Each of these methods will handle `null`, `undefined`, and absent properties differently.\n\n1. Destructuring with defaults\n\nDefaults will be applied if the properties on `object` are absent or set to `undefined`.\n\n```javascript\nfunction addDefaultValues(object) {\n  const {\n    prop1 = 'default 1',\n    prop2 = 'default 2',\n    prop3 = 'default 3',\n  } = object;\n\n  return { prop1, prop2, prop3 };\n}\n```\n\n2. Using the nullish coalescing operator (`??`)\n\nDefaults will be applied if the properties on `object` are absent, set to `undefined`, or set to `null`.\n\n```javascript\nconst result = {\n  prop1: object.prop1 ?? 'default 1',\n  prop2: object.prop2 ?? 'default 2',\n  prop3: object.prop3 ?? 'default 3',\n};\n```\n\n3. Spreading a defaults object with your target object\n\nDefaults will only be applied if the properties on `object` are absent.\n\n```javascript\nconst defaults = {\n  prop1: 'default 1',\n  prop2: 'default 2',\n  prop3: 'default 3',\n};\n\n// Note that if you happen to have multiple objects with defaults, you can easily\n// spread them all together here.\nconst result = { ...defaults, ...object };\n```\n\nIf you already have an object containing default values, option 3 fits the nicest, but it can't be used as-is if you need the defaults to be applied against `undefined` and/or `null` fields. This can be handled by removing `undefined`/`null` from `object` before applying default values, as follows:\n\n```javascript\n// The behavior of this function can easily be tweaked if, for example,\n// you also wish to remove `null` fields from an object.\nfunction removeUndefinedProps(object) {\n  const filteredEntries = Object.entries(object)\n    .filter(([key, value]) => value !== undefined);\n\n  return Object.fromEntries(filteredEntries);\n}\n\nconst result = { ...defaults, ...removeUndefinedProps(object) };\n```\n\nNote that the Lodash implementation would pick both own and inherited properties from the default objects, while this third pattern of spreading objects does not. In practice, this shouldn't matter much because 1. Generally, your default objects won't have inherited fields, and 2. Even if they did, if those inherited fields are set up \"properly\" (i.e. the same way the class syntax automatically does for you), they should also be non-enumerable, and Lodash's `_.defaults()` does not pick non-enumerable fields from the defaults object.\n","src":null,"test":""},{"name":"defaultsDeep","manifest":{"fnSignature":"_.defaultsDeep(object, ...sources)","lodashLink":"https://lodash.com/docs/4.17.15#defaultsDeep","summary":"This method is like `_.defaults` except that it recursively assigns default properties."},"description":"There's a handful of different patterns that can be used when you need to apply default values deeply to your object. Each of these methods will handle `null`, `undefined`, and absent properties differently.\n\n1. Destructuring with defaults\n\nDefaults will be applied if the properties on `object` are absent or set to `undefined`.\n\n```javascript\nfunction addDefaultValues(object) {\n  const {\n    prop1 = 'default 1',\n    subObj = {\n      prop2 = 'default 2',\n      prop3 = 'default 3',\n    } = {},\n  } = object;\n\n  return { prop1, subObj: { prop2, prop3 } };\n}\n```\n\n2. Using the nullish coalescing operator (`??`)\n\nDefaults will be applied if the properties on `object` are absent, set to `undefined`, or set to `null`.\n\n```javascript\nconst result = {\n  prop1: object.prop1 ?? 'default 1',\n  subObj: {\n    prop2: object.subObj?.prop2 ?? 'default 2',\n    prop3: object.subObj?.prop3 ?? 'default 3',\n  },\n};\n```\n\n3. Spreading a defaults object with your target object\n\nDefaults will only be applied if the properties on `object` are absent.\n\n```javascript\nconst defaults = {\n  prop1: 'default 1',\n};\n\nconst subObjDefault = {\n  prop2: 'default 2',\n  prop3: 'default 3',\n};\n\nconst result = {\n  ...defaults,\n  ...object,\n  subObj: {\n    ...subObjDefaults,\n    ...object.subObj ?? {},\n  },\n};\n```\n\nIf you already have an object containing default values, option 3 fits the nicest, but it can't be used as-is if you need the defaults to be applied against `undefined` and/or `null` fields. This can be handled by removing `undefined`/`null` from `object` before applying default values, as follows:\n\n```javascript\n// The behavior of this function can easily be tweaked if, for example,\n// you also wish to remove `null` fields from an object.\nfunction removeUndefinedProps(object) {\n  const filteredEntries = Object.entries(object)\n    .filter(([key, value]) => value !== undefined);\n\n  return Object.fromEntries(filteredEntries);\n}\n\nconst result = {\n  ...defaults,\n  ...removeUndefinedProps(object),\n  subObj: {\n    ...subObjDefaults,\n    ...removeUndefinedProps(object.subObj ?? {}),\n  },\n};\n```\n\nFinally, if you don't feel any of these patterns will fit your use-case very well, you can use the following helper function, which mimics `_.defaultsDeep()`.\n\n```javascript\nconst isObject = value => ['object', 'function'].includes(typeof value) && value !== null;\n\n// NOTE: This mutates `object`.\nfunction defaultsDeep(object, ...sources) {\n  for (const source of sources) {\n    for (const [key, value] of Object.entries(source)) {\n      if (object[key] === undefined) {\n        object[key] = value;\n      } else if (isObject(value) && isObject(source[key])) {\n        defaultsDeep(object[key], value);\n      }\n    }\n  }\n\n  return object;\n}\n```\n\nNote that the Lodash implementation would pick both own and inherited properties from the default objects, while this third pattern of spreading objects does not. In practice, this shouldn't matter much because 1. Generally, your default objects won't have inherited fields, and 2. Even if they did, if those inherited fields are set up \"properly\" (i.e. the same way the class syntax automatically does for you), they should also be non-enumerable, and Lodash's `_.defaultsDeep()` does not pick non-enumerable fields from the defaults object.\n","src":null,"test":""},{"name":"findKey","manifest":{"fnSignature":"_.findKey(object, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#findKey","summary":"This method is like `_.find` except that it returns the key of the first element predicate returns truthy for instead of the element itself."},"description":"```javascript\nObject.entries(object)\n  .find(([key, value]) => predicate(value))?.[0];\n```\n","src":null,"test":""},{"name":"findLastKey","manifest":{"fnSignature":"_.findLastKey(object, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#findLastKey","summary":"This method is like `_.findKey` except that it iterates over elements of a collection in the opposite order."},"description":"```javascript\nObject.entries(object)\n  .findLast(([key, value]) => predicate(value))?.[0];\n```\n\nPlease don't actually use this solution.\n\nObjects are supposed to be treated as unordered collections. Yes, it's technically true that the JavaScript committee has standardized a stable ordering for object properties, but they only did this so your JavaScript programs will run exactly the same, no matter which engine they run on. They don't provide any tools to modify the ordering of an object (like, \"move this property, so that it's second in iteration order, instead of last\"), and the lack of these types of tools exist for a reason - they don't want you to write code that relies on the order, nor does anyone trying to read and understand your code. Conceptually, objects are supposed to be unordered, please treat them that way. Because of this, there's no reason to iterate over an object from the end to the beginning, you should be able to just use `_.findKey()` instead of `_.findLastKey()`.","src":null,"test":""},{"name":"forIn","manifest":{"fnSignature":"_.forIn(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#forIn","summary":"Iterates over own and inherited enumerable string keyed properties of an object and invokes iteratee for each property. Iteratee functions may exit iteration early by explicitly returning `false`."},"description":"```javascript\nfor (const key in object) {\n  const value = object[key];\n  ...\n}\n```\n\nIt's very likely that you don't actually want this behavior. The only way this solution different from the solutions for `_.forOwn()`, is that it'll also iterate over non-enumerable inherited properties. But...\n1. Class syntax will automatically make all methods on the prototype chain non-enumerable, which means the for-in loop won't iterate over them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n2. It's long been considered a good practice whenever using a for-in loop, to also check if the property you're iterating over is non-inherited, by nesting an `if (Object.prototype.hasOwnProperty.call(object, key)) { ... }` check into your loop. This was done, among other reasons, to guard against the case where someone may have improperly mutated `Object.prototype`, and added an enumerable property to it. This `for-in` + `is-own` check isn't seen as much in the wild anymore, because the language has since come out with a better way to iterate over non-inherited keys, which is discussed in the `_.forOwn()` entry.\n\nFor day-to-day development, it's best to stay away from the raw for-in loop. If you just want to iterate over object keys, and don't want to worry about inherited fields, look at `_.forOwn()` instead.\n","src":null,"test":""},{"name":"forInRight","manifest":{"fnSignature":"_.forInRight(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#forInRight","summary":"This method is like `_.forIn` except that it iterates over properties of `object` in the opposite order."},"description":"```javascript\nconst keys = [];\nfor (const key in object) {\n  keys.push(key);\n}\nkeys.reverse();\n\nfor (const key of keys) {\n  const value = object[key];\n  ...\n}\n```\n\nPlease don't actually use this solution.\n\nObjects are supposed to be treated as unordered collections. Yes, it's technically true that the JavaScript committee has standardized a stable ordering for object properties, but they only did this so your JavaScript programs will run exactly the same, no matter which engine they run on. They don't provide any tools to modify the ordering of an object (like, \"move this property, so that it's second in iteration order, instead of last\"), and the lack of these types of tools exist for a reason - they don't _want_ you to write code that relies on the order, nor does anyone trying to read and understand your code. Conceptually, objects are supposed to be unordered, please treat them that way. Because of this, there's no reason to iterate over an object from the end to the beginning, you should be able to just use `_.forIn()` instead of `_.forInRight()`.\n\nExcept, both `_.forIn()` and `_.forInRight()` have another problem.\n\nIt's very likely that you don't actually want to iterate over the enumerable, inherited properties, because:\n1. Class syntax will automatically make all methods on the prototype chain non-enumerable, which means the for-in loop won't iterate over them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n2. It's long been considered a good practice whenever using a for-in loop, to also check if the property you're iterating over is non-inherited, by nesting an `if (Object.prototype.hasOwnProperty.call(object, key)) { ... }` check into your loop. This was done, among other reasons, to guard against the case where someone may have improperly mutated `Object.prototype`, and added an enumerable property to it. This `for-in` + `is-own` check isn't seen as much in the wild anymore, because the language has since come out with a better way to iterate over non-inherited keys, which is discussed in the `_.forOwn()` entry.\n\nIf you just want to iterate over object keys, and don't want to worry about inherited properties or the ordering of keys, look at `_.forOwn()` instead.\n","src":null,"test":""},{"name":"forOwn","manifest":{"fnSignature":"_.forOwn(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#forOwn","summary":"Iterates over own enumerable string keyed properties of an object and invokes `iteratee` for each property. Iteratee functions may exit iteration early by explicitly returning `false`."},"description":"If you wish to iterate over both keys and values:\n\n```javascript\nfor (const [key, value] of Object.entries(object)) {\n  ...\n}\n```\n\nIf, instead, you just want values, you can use `Object.values(object)`.\n\n```javascript\nfor (const value of Object.values(object)) {\n  ...\n}\n```\n\nAnd if you just want keys, you can use `Object.keys(object)`.\n\n```javascript\nfor (const key of Object.keys(object)) {\n  ...\n}\n```\n\nYou'll find the `.forEach()` method to be very popular in the JavaScript community as well.\n\n```javascript\nObject.entries(object).forEach(([key, value]) => {\n\n});\n```\n\nUsing `.forEach()` will certainly feel closer to Lodash's `_.forOwn()`, but it does have a number of drawbacks:\n* You can't use `break` in a `.forEach()`. (You can mimic `continue` via an early return).\n* `.forEach()` doesn't provide proper support for `await`. If you need to run tasks in parallel, use `await Promise.all(items.map(...))`, and if you want to run tasks in a series, you can just use a for-of loop.\n* `.forEach()` doesn't work with generators. You can't `yield` from inside a `.forEach()`.\n* `.forEach()` only works with arrays, and any other collection that happens to implement the `.forEach()` function. `for-of` works with all iterators, including strings, the legacy `arguments` object, your own iterators made via generator functions, etc.\n* `for-of` is newer than `.forEach()` and was intended to be the better version of `.forEach()`. It's a shame it's still struggling to gain traction.\n","src":null,"test":""},{"name":"forOwnRight","manifest":{"fnSignature":"_.forOwnRight(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#forOwnRight","summary":"This method is like `_.forOwn` except that it iterates over properties of `object` in the opposite order."},"description":"```javascript\nfor (const [key, value] of Object.entries(object).reverse()) {\n  ...\n}\n```\n\nPlease don't actually use this solution.\n\nObjects are supposed to be treated as unordered collections. Yes, it's technically true that the JavaScript committee has standardized a stable ordering for object properties, but they only did this so your JavaScript programs will run exactly the same, no matter which engine they run on. They don't provide any tools to modify the ordering of an object (like, \"move this property, so that it's second in iteration order, instead of last\"), and the lack of these types of tools exist for a reason - they don't _want_ you to write code that relies on the order, nor does anyone trying to read and understand your code. Conceptually, objects are supposed to be unordered, please treat them that way. Because of this, there's no reason to iterate over an object from the end to the beginning, you should be able to just use `_.forOwn()` instead of `_.forOwnRight()`.\n","src":null,"test":""},{"name":"functions","manifest":{"fnSignature":"_.functions(object)","lodashLink":"https://lodash.com/docs/4.17.15#functions","summary":"Creates an array of function property names from own enumerable properties of `object`."},"description":"```javascript\nfunction functions(object) {\n  const result = [];\n  for (const [key, value] of Object.entries(object)) {\n    if (typeof value === 'function') {\n      result.push(key);\n    }\n  }\n\n  return result;\n}\n```\n","src":null,"test":""},{"name":"functionsIn","manifest":{"fnSignature":"_.functionsIn(object)","lodashLink":"https://lodash.com/docs/4.17.15#functionsIn","summary":"Creates an array of function property names from own and inherited enumerable properties of object."},"description":"```javascript\nfunction functionsIn(object) {\n  const result = [];\n  for (const key in object) {\n    if (typeof object[key] === 'function') {\n      result.push(key);\n    }\n  }\n\n  return result;\n}\n```\n\nIt's very likely that you don't actually need this function. The only way this function is different from `_.functions()`, is that it'll also search for non-enumerable inherited fields. But class syntax will automatically make all methods on the prototype chain non-enumerable, which means the `functionsIn()` function won't look for them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable, i.e. if the methods were attached to the prototype \"properly\", the `functionsIn()` implementation wouldn't be able to find anything on there anyways, since they'd all be marked as non-enumerable.\n\nPerhaps there's some niche use-cases for this sort of function, that arise from using the prototype in abnormal or legacy ways, but, for day-to-day development, it's best to stay away from this function. If you just want to search for non-inherited function names, use `_.functions()` instead. If you need to get all non-enumerable, inherited method names, first double check how you're designing your program to see if, perhaps, there's a better way to approach the problem, and if not, you can use `Object.getOwnPropertyNames()` to get non-inherited, non-enumerable properties in combination with manually walking up the prototype chain to achieve your desired effect.\n","src":null,"test":""},{"name":"get","manifest":{"fnSignature":"_.get(object, path, defaultValue?)","lodashLink":"https://lodash.com/docs/4.17.15#get","summary":"Gets the value at `path` of `object`. If the resolved value is `undefined`, the `defaultValue` is returned in its place."},"description":"```javascript\nfunction get(object, path, defaultValue = undefined) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  if (path.length === 0) {\n    return object;\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return defaultValue;\n  }\n\n  return get(object[head], tail, defaultValue);\n}\n```\n\nOne of the primary reasons Lodash's `_.get()` function was commonly used, was as a way to easily access a nested property without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined, and the [nullish coalescing operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing) to provide a default value.\n\nFor example, these two are effectively the same:\n\n```javascript\n_.get(obj, 'a.b', null);\n\nobj?.a?.b ?? null;\n```\n\nNote that the support for string paths in the above `get()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.get()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"has","manifest":{"fnSignature":"_.has(object, path)","lodashLink":"https://lodash.com/docs/4.17.15#has","summary":"Checks if path is a direct property of object."},"description":"If you have a simple key, then `Object.hasOwn()` can be used to check if it's a non-inherited property.\n\n```javascript\nObject.hasOwn({}, 'toString'); // false\nObject.hasOwn({ toString() { return '{}' } }, 'toString'); // true\n```\n\nIf you have an array of path keys you wish to travel down, or perhaps, a string containing nested property access (like `x.y.z`), use this:\n\n```javascript\nfunction has(object, path) {\n  // Optional nested-property string support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  const [head, ...tail] = path;\n  if (!Object.hasOwn(object, head)) {\n    return false;\n  }\n\n  if (tail.length === 0) {\n    return true;\n  }\n\n  return has(object[head], tail);\n}\n```\n\nNote that the support for nested string paths in the above `has()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.has()` isn't all that different in this regard. If you really need support for nested string paths, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability. Just provide the path you desire as an array instead.\n\nIf you don't have dynamic strings being provided to you, and you don't need to do the \"is-not-inherited\" checks, then you can simply use the `in` operator with \"optional chaining\" (`?.`) to check for the existence of a nested property.\n\n```javascript\n'z' in object?.x?.y;\n```\n","src":null,"test":""},{"name":"hasIn","manifest":{"fnSignature":"_.hasIn(object, path)","lodashLink":"https://lodash.com/docs/4.17.15#hasIn","summary":"Checks if `path` is a direct or inherited property of `object`."},"description":"If you have a simple key, then the `in` operator can be used to check if the property is found in the object.\n\n```javascript\n'x' in { x: 2 }; // true\n'toString' in { x: 2 }; // true - `in` checks for inherited properties as well\n```\n\nIf you have an array of path keys you wish to travel down, or perhaps, a string containing nested property access (like `x.y.z`), use this:\n\n```javascript\nfunction hasIn(object, path) {\n  // Optional nested-property string support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return false;\n  }\n\n  if (tail.length === 0) {\n    return true;\n  }\n\n  return hasIn(object[head], tail);\n}\n```\n\nOne of the primary reasons Lodash's `_.hasIn()` function was commonly used, was as a way to easily check if a nested property existed, without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined.\n\nFor example, these two are the same:\n\n```javascript\n_.hasIn(obj, 'a.b.c');\n\n'c' in obj?.a?.b;\n```\n\nNote that the support for nested string paths in the above `hasIn()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.hasIn()` isn't all that different in this regard. If you really need support for nested string paths, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability. Just provide the path you desire as an array instead.\n","src":null,"test":""},{"name":"invert","manifest":{"fnSignature":"_.invert(object)","lodashLink":"https://lodash.com/docs/4.17.15#invert","summary":"Creates an object composed of the inverted keys and values of object. If object contains duplicate values, subsequent values overwrite property assignments of previous values."},"description":"```javascript\nfunction invert(obj) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    newObj[value] = key;\n  }\n  return newObj;\n}\n```\n","src":null,"test":""},{"name":"invertBy","manifest":{"fnSignature":"_.invertBy(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#invertBy","summary":"This method is like `_.invert` except that the inverted object is generated from the results of running each element of `object` thru `iteratee`. The corresponding inverted value of each inverted key is an array of keys responsible for generating the inverted value."},"description":"```javascript\nfunction invertBy(obj, iteratee=x=>x) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const newValue = iteratee(value);\n    newObj[newValue] ??= [];\n    newObj[newValue].push(key);\n  }\n  return newObj;\n}\n```\n","src":null,"test":""},{"name":"invoke","manifest":{"fnSignature":"_.invoke(object, path, ...args)","lodashLink":"https://lodash.com/docs/4.17.15#invoke","summary":"Invokes the method at `path` of `object`."},"description":"```javascript\nfunction invoke(object, path, ...args) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return undefined;\n  }\n\n  if (tail.length === 0) {\n    return object[head](...args);\n  }\n\n  return invoke(object[head], tail, ...args);\n}\n```\n\nOne of the primary reasons Lodash's `_.invoke()` function was commonly used, was as a way to easily invoke a function nested in an object, without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined.\n\nFor example, these two are effectively the same:\n\n```javascript\n_.invoke(obj, 'subObj.fn', 2, 4);\n\nobj?.subObj?.fn?.(2, 4);\n```\n\nNote that the support for string paths in the above `invoke()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.invoke()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"keys","manifest":{"fnSignature":"_.keys(object)","lodashLink":"https://lodash.com/docs/4.17.15#keys","summary":"Creates an array of the own enumerable property names of `object`."},"description":"```javascript\nObject.keys(object);\n```\n","src":null,"test":""},{"name":"keysIn","manifest":{"fnSignature":"_.keysIn(object)","lodashLink":"https://lodash.com/docs/4.17.15#keysIn","summary":"Creates an array of the own and inherited enumerable property names of `object`."},"description":"```javascript\nfunction keysIn(object) {\n  const keys = [];\n  for (let key in object) {\n    keys.push(key);\n  }\n\n  return keys;\n}\n```\n\nIt's very likely that you don't actually need this function. The only way this function is different from `_.keys()` (or `Object.keys()`), is that it'll also grab over non-enumerable inherited keys. But class syntax will automatically make all methods on the prototype chain non-enumerable, which means the `keysIn()` function won't consider those inherited methods anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n\nPerhaps there's some niche use-cases for this sort of function, that arise from using the prototype in abnormal or legacy ways, but, for day-to-day development, it's best to stay away from this function. If you just want to get the non-inherited keys from an object, use `Object.keys(object)` instead.\n","src":null,"test":""},{"name":"mapKeys","manifest":{"fnSignature":"_.mapKeys(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#mapKeys","summary":"The opposite of `_.mapValues`; this method creates an object with the same values as `object` and keys generated by running each own enumerable string keyed property of `object` thru `iteratee`."},"description":"```javascript\nfunction mapKeys(obj, iteratee) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const newKey = iteratee(value, key, obj);\n    newObj[newKey] = value;\n  }\n\n  return newObj;\n}\n```\n","src":null,"test":""},{"name":"mapValues","manifest":{"fnSignature":"_.mapValues(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#mapValues","summary":"Creates an object with the same keys as `object` and values generated by running each own enumerable string keyed property of `object` thru `iteratee`."},"description":"```javascript\nfunction mapValues(obj, iteratee) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    newObj[key] = iteratee(value, key, obj);\n  }\n\n  return newObj;\n}\n```\n","src":null,"test":""},{"name":"merge","manifest":{"fnSignature":"_.merge(object, ...sources)","lodashLink":"https://lodash.com/docs/4.17.15#merge","summary":"This method is like `_.assign` except that it recursively merges own and inherited enumerable string keyed properties of source objects into the destination object. Source properties that resolve to `undefined` are skipped if a destination value exists. Source objects are applied from left to right. Subsequent sources overwrite property assignments of previous sources."},"description":"If you know the shape of the objects you're wishing to merge, you can just use the spread syntax, like this:\n\n```javascript\nconst result = {\n  ...object1,\n  ...object2,\n  subObject: {\n    ...object1.subObject,\n    ...object2.subObject,\n  },\n};\n```\n\nOtherwise, the following `merge()` function can be used to roughly mirror Lodash's `_.merge()`.\n\n```javascript\nconst isObject = value => ['object', 'function'].includes(typeof value) && value !== null;\n\n// A \"plain\" object is an object who's a direct instance of Object\n// (or, who has a null prototype).\nconst isPlainObject = value => {\n  if (!isObject(value)) return false;\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n};\n\n// NOTE: This mutates `object`.\n// It also may mutate anything that gets attached to `object` during the merge.\nfunction merge(object, ...sources) {\n  for (const source of sources) {\n    for (const [key, value] of Object.entries(source)) {\n      if (value === undefined) {\n        continue;\n      }\n\n      // These checks are a week attempt at mimicking the various edge-case behaviors\n      // that Lodash's `_.merge()` exhibits. Feel free to simplify and\n      // remove checks that you don't need.\n      if (!isPlainObject(value) && !Array.isArray(value)) {\n        object[key] = value;\n      } else if (Array.isArray(value) && !Array.isArray(object[key])) {\n        object[key] = value;\n      } else if (!isObject(object[key])) {\n        object[key] = value;\n      } else {\n        merge(object[key], value)\n      }\n    }\n  }\n\n  return object;\n}\n```\n\nThe Lodash implementation would pick both own and inherited properties from the default objects, while this implementation does not. In practice, this shouldn't matter much because 1. Generally, your default objects won't have inherited fields, and 2. Even if they did, if those inherited fields are set up \"properly\" (i.e. the same way the class syntax automatically does for you), they should also be non-enumerable, and Lodash's `_.merge()` does not pick non-enumerable fields from the defaults object.\n\nThe implementation above also does not support circular references. There's a handful of different ways you could support circular references depending on your needs:\n* Don't bother checking for them at all (what the above implementation does)\n* Check for them on the source objects and throw an error if you encounter one (another good option)\n* When traversing a `source` object, stop before using a source node that you've seen before (what `lodash` was probably trying to do).\n* When traversing a `source` object, if you encounter a node in `source` that you have seen before, merge its immediate properties but do not recurse into it anymore (what `lodash` does).\n* When traversing a `source` object, stop if you find yourself trying to merge a source node to the same target node a second time. (This is arguably the most correct algorithm)\n\nIn practice, it's not common to need support for circular references, so you will probably be fine just leaving out support or throwing an error if you detect a circular reference.\n\nIf all you want to do is deeply merge some plain objects, and you don't need to worry about odd scenarios, like \"what happens when I merge an array with a number\", or, \"how does a Map instance get merged with a plain object\", then an implementation like this should be sufficient.\n\n```javascript\nconst isObject = value => ['object', 'function'].includes(typeof value) && value !== null;\n\n// NOTE: This mutates `object`.\n// It also may mutate anything that gets attached to `object` during the merge.\nfunction merge(object, ...sources) {\n  if (!isObject(object)) {\n    throw new Error(`Expected ${object} to be an object.`)\n  }\n\n  for (const source of sources) {\n    for (const [key, value] of Object.entries(source)) {\n      if (value === undefined) {\n        continue;\n      }\n\n      if (object[key] === undefined) {\n        object[key] = value;\n      } else {\n        merge(object[key], value)\n      }\n    }\n  }\n\n  return object;\n}\n```\n","src":null,"test":""},{"name":"mergeWith","manifest":{"fnSignature":"_.mergeWith(object, ...sources, customizer)","lodashLink":"https://lodash.com/docs/4.17.15#mergeWith","summary":"This method is like `_.merge` except that it accepts `customizer` which is invoked to produce the merged values of the destination and source properties. If `customizer` returns `undefined`, merging is handled by the method instead."},"description":"```javascript\nconst isObject = value => ['object', 'function'].includes(typeof value) && value !== null;\n\n// A \"plain\" object is an object who's a direct instance of Object\n// (or, who has a null prototype).\nconst isPlainObject = value => {\n  if (!isObject(value)) return false;\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n};\n\n// NOTE: This mutates `object`.\n// It also may mutate anything that gets attached to `object` during the merge.\nfunction mergeWith(object, sources, customizer) {\n  for (const source of sources) {\n    for (const [key, value] of Object.entries(source)) {\n      const mergedValue = customizer(object[key], value, key, object, source);\n      if (mergedValue !== undefined) {\n        object[key] = mergedValue;\n        continue;\n      }\n      // Otherwise, fall back to default behavior\n\n      if (value === undefined) {\n        continue;\n      }\n\n      // These checks are a week attempt at mimicking the various edge-case behaviors\n      // that Lodash's `_.merge()` exhibits. Feel free to simplify and\n      // remove checks that you don't need.\n      if (!isPlainObject(value) && !Array.isArray(value)) {\n        object[key] = value;\n      } else if (Array.isArray(value) && !Array.isArray(object[key])) {\n        object[key] = value;\n      } else if (!isObject(object[key])) {\n        object[key] = value;\n      } else {\n        mergeWith(object[key], value, customizer)\n      }\n    }\n  }\n\n  return object;\n}\n```\n\nLodash implementation will pick both own and inherited properties from the default objects, while this implementation does not. In practice, this shouldn't matter much because 1. Generally, your default objects won't have inherited fields, and 2. Even if they did, if those inherited fields are set up \"properly\" (i.e. the same way the class syntax automatically does for you), they should also be non-enumerable, and Lodash's `_.merge()` does not pick non-enumerable fields from the defaults object.\n\nIn Lodash, the customizer function would be called with a sixth \"stack\" argument. Some probing shows that it's an instance of an internal \"Stack\" class that provides some methods which, presumably, can be used to gather information about the objects you're merging. Due to the fact that this seems to be a rather complex feature that's entirely undocumented, it'll be assumed that the vast majority of users do not use this parameter, and so it's functionality won't be recreated here either.\n\nThe implementation above also does not support circular references. There's a handful of different ways you could support circular references depending on your needs:\n* Don't bother checking for them at all (what the above implementation does)\n* Check for them on the source objects and throw an error if you encounter one (another good option)\n* When traversing a `source` object, stop before using a source node that you've seen before (what `lodash` was probably trying to do).\n* When traversing a `source` object, if you encounter a node in `source` that you have seen before, merge its immediate properties but do not recurse into it anymore (what `lodash` does).\n* When traversing a `source` object, stop if you find yourself trying to merge a source node to the same target node a second time. (This is arguably the most correct algorithm)\n\nIn practice, it's not common to need support for circular references, so you will probably be fine just leaving out support or throwing an error if you detect a circular reference.","src":null,"test":""},{"name":"omit","manifest":{"fnSignature":"_.omit(object, ...paths)","lodashLink":"https://lodash.com/docs/4.17.15#omit","summary":"This method is like `_.merge` except that it accepts `customizer` which is invoked to produce the merged values of the destination and source properties. If `customizer` returns `undefined`, merging is handled by the method instead."},"description":"If the properties you wish to omit are known in advance, you can use destructuring to omit them (possibly putting this in a helper function, to avoid polluting your scope with unnecessary variables).\n\n```javascript\n// `partialObject` will contain everything that's in `object`,\n// except, `propA` and `propB` will be omitted.\nconst { propA, propB, ...partialObject } = object;\n```\n\nIf you need to also omit nested properties, a similar pattern can still be followed.\n\n```javascript\n// omit properties from `object`\nconst { propA, propB, nestedObj, ...partialObject } = object;\n\n// omit properties from `object.nestedObj`\nconst { nestedPropA, ...partialNestedObject } = nestedObj;\n\n// Combine the two partial objects, to build the final result.\nconst result = { ...partialObject, partialNestedObject };\n```\n\nIf you don't know the keys you need to remove in advance, the following helper function can be utilized.\n\n```javascript\nfunction omit(object, keys_) {\n  const keys = new Set(keys_);\n  const newObject = {};\n  for (const [key, value] of Object.entries(object)) {\n    if (!keys.has(key)) {\n      newObject[key] = value;\n    }\n  }\n\n  return newObject;\n}\n```\n\nThere is an early [Object.omit() proposal](https://github.com/tc39/proposal-object-pick-or-omit), which, if implemented, would provide functionality similar to the above helper function.\n\nIf you need a version of the omit function that can omit nested properties, you can use this:\n\n```javascript\nconst isObject = value => ['object', 'function'].includes(typeof value) && value !== null;\n\nfunction omit(object, keys) {\n  const newObject = Array.isArray(object) ? [ ...object ] : { ...object };\n\n  for (const key of keys) {\n    let keyPath;\n    if (typeof key === 'string') {\n      // Optional string-path support.\n      // You can remove this key.split() stuff, and simply use `keyPath = [key];`\n      // if you don't need it.\n      keyPath = key.split(/[.\\[\\]\\\"]+/).filter(x => x);\n    } else if (Array.isArray(key)) {\n      keyPath = key;\n    } else {\n      throw new Error(`Received a key ${key}, which is of an invalid type.`);\n    }\n\n    const [head, ...tail] = keyPath;\n    if (tail.length === 0) {\n      delete newObject[key];\n    } else if (isObject(newObject[head]) || Array.isArray(newObject[head])) {\n      newObject[head] = omit(newObject[head], [tail]);\n    }\n  }\n\n  return newObject;\n}\n```\n\nIf you're only passing in a handful of keys at a time, the above implementation should work just fine, but if you think your keys array may become fairly large, you may need to do some work to optimize the above implementation a bit.\n\nNote that the support for string paths (e.g. keys like `key.nestedKey`) in the above `omit()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.omit()` isn't all that different in this regard. If you really need support for string-path inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability.\n\nNote that none of these implementations will actually copy non-enumerable properties from the prototype chain like Lodash's `_.omit()`. It's very likely that you don't actually want this kind of behavior anyways. Generally, all properties found on the prototype chain should be marked as enumerable (this is the default for class syntax) - this is standard practice, and there's really no reason to create a prototype with non-enumerable properties, with the possible exception of dealing with classes that were created before the class syntax came out, where the authors didn't want to put in the work of manually marking each method on the prototype as non-enumerable (it wasn't a common thing to do back in the day, even if it would have technically been more proper).\n","src":null,"test":""},{"name":"omitBy","manifest":{"fnSignature":"_.omitBy(object, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#omitBy","summary":"The opposite of `_.pickBy`; this method creates an object composed of the own and inherited enumerable string keyed properties of `object` that `predicate` doesn't return truthy for."},"description":"```javascript\nfunction omitBy(object, predicate) {\n  const newObject = {};\n  for (const [key, value] of Object.entries(object)) {\n    if (!predicate(value, key)) {\n      newObject[key] = value;\n    }\n  }\n\n  return newObject;\n}\n```\n\n`_.omitBy(object, x => <condition>)` is exactly the same as `_.pickBy(object, x => !<condition>)`. This means, you only really need one of these helper functions, not both.\n\nThere is also an early [Object.omit() proposal](https://github.com/tc39/proposal-object-pick-or-omit), which, if implemented, would provide functionality similar to the above helper function.\n\nNote that this implementation will not actually copy non-enumerable properties from the prototype chain like Lodash's `_.omitBy()`. It's very likely that you don't actually want this kind of behavior anyways. Generally, all properties found on the prototype chain should be marked as enumerable (this is the default for class syntax) - this is standard practice, and there's really no reason to create a prototype with non-enumerable properties, with the possible exception of dealing with classes that were created before the class syntax came out, where the authors didn't want to put in the work of manually marking each method on the prototype as non-enumerable (it wasn't a common thing to do back in the day, even if it would have technically been more proper).\n","src":null,"test":""},{"name":"pick","manifest":{"fnSignature":"_.pick(object, ...paths)","lodashLink":"https://lodash.com/docs/4.17.15#pick","summary":"Creates an object composed of the picked `object` properties."},"description":"If the properties you wish to pick are known in advance, you can use destructuring to pick them (possibly putting this in a helper function, to avoid polluting your scope with unnecessary variables).\n\n```javascript\nconst { propA, propB } = object;\nconst newObject = { propA, propB };\n```\n\nIf you need to also omit nested properties, a similar pattern can still be followed.\n\n```javascript\n// omit properties from `object`\nconst { propA, propB, nestedObj, ...partialObject } = object;\n\n// omit properties from `object.nestedObj`\nconst { nestedPropA, ...partialNestedObject } = nestedObj;\n\n// Combine the two partial objects, to build the final result.\nconst result = { ...partialObject, partialNestedObject };\n```\n\nIf you don't know the keys you need to pick in advance, the following helper function can be utilized.\n\n```javascript\nfunction pick(object, keys) {\n  const newObject = {};\n  for (const key of keys) {\n    if (key in object) {\n      if (key in object) {\n        newObject[key] = object[key];\n      }\n    }\n  }\n\n  return newObject;\n}\n```\n\nThere is an early [Object.pick() proposal](https://github.com/tc39/proposal-object-pick-or-omit), which, if implemented, would provide functionality similar to the above helper function.\n\nIf you need a version of the pick function that can pick nested properties, you can use this:\n\n```javascript\nconst isObject = value => ['object', 'function'].includes(typeof value) && value !== null;\n\nfunction pick(object, keys) {\n  if (object == null) {\n    return {};\n  }\n  const newObject = {};\n\n  for (const key of keys) {\n    let keyPath;\n    if (typeof key === 'string') {\n      // Optional string-path support.\n      // You can remove this key.split() stuff, and simply use `keyPath = [key];`\n      // if you don't need it.\n      keyPath = key.split(/[.\\[\\]\\\"]+/).filter(x => x);\n    } else if (Array.isArray(key)) {\n      keyPath = key;\n    } else {\n      throw new Error(`Received a key ${key}, which is of an invalid type.`);\n    }\n\n    const [head, ...tail] = keyPath;\n    if (!(head in object)) {\n      continue;\n    } else if (tail.length === 0) {\n      newObject[key] = object[key];\n    } else if (isObject(object[head]) || Array.isArray(object[head])) {\n      newObject[head] = {\n        ...newObject[head] ?? {},\n        ...pick(object[head], [tail])\n      };\n    }\n  }\n\n  return newObject;\n}\n```\n\nIf you're only passing in a handful of keys at a time, the above implementation should work just fine, but if you think your keys array may become fairly large, you may need to do some work to optimize the above implementation a bit.\n\nNote that the support for string paths (e.g. keys like `key.nestedKey`) in the above `pick()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.pick()` isn't all that different in this regard. If you really need support for string-path inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability.\n\nIn all of these implementations, you'll be able to pick own properties and inherited properties. This can lead to issues if you accept arbitrary untrusted user input in your keys array. For example, even though the object passed into `pick({}, [untrustedUserInput])` is empty, you can still pick inherited methods off of it, e.g. if untrustedUserInput is set to `'toString'`, you'd pick the `'toString'` method off of the empty object.","src":null,"test":""},{"name":"pickBy","manifest":{"fnSignature":"_.pickBy(object, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#pickBy","summary":"Creates an object composed of the object properties `predicate` returns truthy for. "},"description":"```javascript\nfunction pickBy(object, predicate) {\n  const newObject = {};\n  for (const [key, value] of Object.entries(object)) {\n    if (predicate(value, key)) {\n      newObject[key] = value;\n    }\n  }\n\n  return newObject;\n}\n```\n\nThere is also an early [Object.pick() proposal](https://github.com/tc39/proposal-object-pick-or-omit), which, if implemented, would provide functionality similar to the above helper function.\n\nNote that this implementation will not actually copy non-enumerable properties from the prototype chain like Lodash's `_.pickBy()`. It's very likely that you don't actually want this kind of behavior anyways. Generally, all properties found on the prototype chain should be marked as enumerable (this is the default for class syntax) - this is standard practice, and there's really no reason to create a prototype with non-enumerable properties, with the possible exception of dealing with classes that were created before the class syntax came out, where the authors didn't want to put in the work of manually marking each method on the prototype as non-enumerable (it wasn't a common thing to do back in the day, even if it would have technically been more proper).\n","src":null,"test":""},{"name":"result","manifest":{"fnSignature":"_.result(object, path, defaultValue?)","lodashLink":"https://lodash.com/docs/4.17.15#result","summary":"This method is like `_.get` except that if the resolved value is a function it's invoked with the `this` binding of its parent object and its result is returned."},"description":"```javascript\nfunction result(object, path, defaultValue = undefined) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return defaultValue;\n  }\n\n  if (tail.length === 0) {\n    return object[head]();\n  }\n\n  return result(object[head], tail, defaultValue);\n}\n```\n\nOne of the primary reasons Lodash's `_.result()` function was commonly used, was as a way to easily invoke a function nested in an object, without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined, and the [nullish coalescing operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing) to provide a default value.\n\nFor example, these two are effectively the same:\n\n```javascript\n_.result(obj, 'subObj.fn', 'fallback');\n\nobj?.subObj?.fn?.() ?? 'fallback';\n```\n\nNote that the support for string paths in the above `result()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.result()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"set","manifest":{"fnSignature":"_.set(object, path, value)","lodashLink":"https://lodash.com/docs/4.17.15#set","summary":"Sets the value at `path` of `object`. If a portion of `path` doesn't exist, it's created. Arrays are created for missing index properties while objects are created for all other missing properties."},"description":"```javascript\nfunction set(object, path, value) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str => str[0] === '\"' && str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x => x)\n      .map(x => !isNaN(Number(x)) ? Number(x) : x)\n      .map(x => typeof x === 'string' && isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = value;\n    return object;\n  }\n\n  if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  set(object[head], tail, value);\n  return object;\n}\n```\n\nOne of the primary reasons Lodash's `_.set()` function was commonly used, was as a way to easily update a nested property without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined.\n\nFor example, these two accomplish the same objective:\n\n```javascript\n_.set(obj, 'a.b.c', true);\n\nif (obj?.a?.b) {\n  obj.a.b.c = true;\n}\n```\n\nNote that the support for string paths in the above `set()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.set()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"setWith","manifest":{"fnSignature":"_.setWith(object, path, value, customizer?)","lodashLink":"https://lodash.com/docs/4.17.15#setWith","summary":"This method is like `_.set` except that it accepts `customizer` which is invoked to produce the objects of `path`. If `customizer` returns `undefined` path creation is handled by the method instead."},"description":"```javascript\nfunction setWith(object, path, value, customizer) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str => str[0] === '\"' && str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x => x)\n      .map(x => !isNaN(Number(x)) ? Number(x) : x)\n      .map(x => typeof x === 'string' && isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = value;\n    return object;\n  }\n\n  let pathSegment = customizer(object[head], head, object);\n\n  if (pathSegment !== undefined) {\n    object[head] = pathSegment;\n  } else if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  setWith(object[head], tail, value, customizer);\n  return object;\n}\n```\n\nNote that the support for string paths in the above `setWith()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.setWith()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability, since you can always provide an array of keys to form a path, instead of a dot-separated string.\n","src":null,"test":""},{"name":"toPairs","manifest":{"fnSignature":"_.toPairs(object)","lodashLink":"https://lodash.com/docs/4.17.15#toPairs","summary":"Creates an array of own enumerable string keyed-value pairs for `object` which can be consumed by `_.fromPairs`. If object is a map or set, its entries are returned."},"description":"If you have a normal object, use `Object.entries(object);`.\n\nIf you have a map, use `[...map]`.\n\nAnd, while it's not all that useful, you can get the contents of a set, formatted in pairs the same way Lodash's `_.toPairs()` does it, as follows:\n\n```javascript\n[...set].map(value => [value, value]);\n```\n","src":null,"test":""},{"name":"toPairsIn","manifest":{"fnSignature":"_.toPairsIn(object)","lodashLink":"https://lodash.com/docs/4.17.15#toPairsIn","summary":"Creates an array of own and inherited enumerable string keyed-value pairs for `object` which can be consumed by `_.fromPairs`. If `object` is a map or set, its entries are returned."},"description":"If you have a normal object, the following:\n\n```javascript\nfunction toPairsIn(object) {\n  const pairs = [];\n  for (let key in object) {\n    pairs.push([key, object[key]]);\n  }\n\n  return pairs;\n}\n```\n\nIf you have a map, use `[...map]`.\n\nAnd, while it's not all that useful, you can get the contents of a set, formatted in pairs the same way Lodash's `_.toPairs()` does it, as follows:\n\n```javascript\n[...set].map(value => [value, value]);\n```\n\nIt's very likely that you don't actually need the above `toPairsIn()` function. The only way this function is different from `_.toPairs()` (or `Object.entries()`), is that it'll also operate on non-enumerable inherited fields. But class syntax will automatically make all methods on the prototype chain non-enumerable, which means the `toPairsIn()` function won't operate on them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n\nPerhaps there's some niche use-cases for this sort of function that arise from fairly abnormal and tricky uses of the JavaScript prototype, but, for day-to-day development, it's best to stay away from this function. If you just want to get a list of non-inherited pairs (entries), please look at `_.toPairs()` instead.\n","src":null,"test":""},{"name":"transform","manifest":{"fnSignature":"_.transform(object)","lodashLink":"https://lodash.com/docs/4.17.15#transform","summary":"An alternative to `_.reduce`; this method transforms `object` to a new `accumulator` object which is the result of running each of its own enumerable string keyed properties thru `iteratee`, with each invocation potentially mutating the `accumulator` object. If `accumulator` is not provided, a new object with the same `[[Prototype]]` will be used."},"description":"Using `_.transform()` really isn't any different from using the built-in `array.reduce()` method, except for a couple of minor things.\n\n1. If you're dealing with objects, you need to use `Object.entries(yourObject)` to turn it into an array of tuples first.\n2. With `array.reduce()`, you need to always return the accumulator\n\nWhat this looks like in practice, using an example from Lodash's website.\n\n```javascript\n_.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n  (result[value] || (result[value] = [])).push(key);\n}, {});\n// => { '1': ['a', 'c'], '2': ['b'] }\n\n// Note the use of `Object.entries()` (point 1) here.\nObject.entries({ 'a': 1, 'b': 2, 'c': 1 }).reduce((result, [key, value]) => {\n  (result[value] || (result[value] = [])).push(key);\n  return result; // Note how we return the accumulator (point 2) here.\n}, {});\n```\n\nA simple for loop will work just as well, if that's your preference.\n\n```javascript\nconst result = {};\nfor (const [key, value] of Object.entries({ 'a': 1, 'b': 2, 'c': 1 })) {\n  (result[value] || (result[value] = [])).push(key);\n}\n```","src":null,"test":""},{"name":"unset","manifest":{"fnSignature":"_.unset(object, path)","lodashLink":"https://lodash.com/docs/4.17.15#unset","summary":"Removes the property at `path` of `object`."},"description":"```javascript\nfunction unset(object, path) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str => str[0] === '\"' && str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x => x)\n      .map(x => !isNaN(Number(x)) ? Number(x) : x)\n      .map(x => typeof x === 'string' && isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    delete object[head];\n  } else if (head in object) {\n    unset(object[head], tail);\n  }\n\n  return object;\n}\n```\n\nOne of the primary reasons Lodash's `_.unset()` function was commonly used, was as a way to easily delete a nested property without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined.\n\nFor example, these two are the same:\n\n```javascript\n_.unset(obj, 'a.b');\n\ndelete obj?.a?.b;\n```\n\nNote that the support for string paths in the above `unset()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.unset()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"update","manifest":{"fnSignature":"_.set(object, path, value)","lodashLink":"https://lodash.com/docs/4.17.15#set","summary":"Sets the value at `path` of `object`. If a portion of `path` doesn't exist, it's created. Arrays are created for missing index properties while objects are created for all other missing properties."},"description":"```javascript\nfunction update(object, path, updater) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str => str[0] === '\"' && str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x => x)\n      .map(x => !isNaN(Number(x)) ? Number(x) : x)\n      .map(x => typeof x === 'string' && isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = updater();\n    return object;\n  }\n\n  if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  update(object[head], tail, updater);\n  return object;\n}\n```\n\nOne of the primary reasons Lodash's `_.update()` function was commonly used, was as a way to easily update a nested property without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined.\n\nFor example, these two accomplish the same objective:\n\n```javascript\n_.update(obj, 'a.b.c', () => new Something());\n\nif (obj?.a?.b) {\n  obj.a.b.c = new Something();\n}\n```\n\nNote that the support for string paths in the above `update()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.update()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"updateWith","manifest":{"fnSignature":"_.updateWith(object, path, updater, customizer?)","lodashLink":"https://lodash.com/docs/4.17.15#set","summary":"This method is like `_.update` except that it accepts `customizer` which is invoked to produce the objects of `path`. If `customizer` returns `undefined` path creation is handled by the method instead."},"description":"```javascript\nfunction updateWith(object, path, updater, customizer) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str => str[0] === '\"' && str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x => x)\n      .map(x => !isNaN(Number(x)) ? Number(x) : x)\n      .map(x => typeof x === 'string' && isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = updater();\n    return object;\n  }\n\n  let pathSegment = customizer(object[head], head, object);\n\n  if (pathSegment !== undefined) {\n    object[head] = pathSegment;\n  } else if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  updateWith(object[head], tail, updater, customizer);\n  return object;\n}\n```\n\nNote that the support for string paths in the above `updateWith()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.updateWith()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"values","manifest":{"fnSignature":"_.values(object)","lodashLink":"https://lodash.com/docs/4.17.15#values","summary":"Creates an array of the own enumerable string keyed property values of `object`."},"description":"```javascript\nObject.values(object);\n```\n","src":null,"test":""},{"name":"valuesIn","manifest":{"fnSignature":"_.valuesIn(object)","lodashLink":"https://lodash.com/docs/4.17.15#valuesIn","summary":"Creates an array of the own and inherited enumerable string keyed property values of `object`."},"description":"```javascript\nfunction valuesIn(object) {\n  const values = [];\n  for (let key in object) {\n    values.push(object[key]);\n  }\n\n  return values;\n}\n```\n\nIt's very likely that you don't actually need the above `valuesIn()` function. The only way this function is different from `_.values()` (or `Object.values()`), is that it'll also operate on non-enumerable inherited fields. But class syntax will automatically make all methods on the prototype chain non-enumerable, which means the `valuesIn()` function won't operate on them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n\nPerhaps there's some niche use-cases for this sort of function that arise from fairly abnormal and tricky uses of the JavaScript prototype, but, for day-to-day development, it's best to stay away from this function. If you just want to get an object's non-inherited property values, please look at `_.values()` instead.\n","src":null,"test":""}]},{"categoryHeading":"String","entries":[{"name":"escape","manifest":{"fnSignature":"_.escape(string)","lodashLink":"https://lodash.com/docs/4.17.15#escape","summary":"Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in string to their corresponding HTML entities."},"description":"```javascript\nfunction escapeHtmlChars(string) {\n  return string\n    .replaceAll('&', '&amp;')\n    .replaceAll('<', '&lt;')\n    .replaceAll('>', '&gt;')\n    .replaceAll('\"', '&quot;')\n    .replaceAll(\"'\", '&#39;');\n}\n```\n\nPlease be careful when using functions like this as improper usage can result in XSS vunerabilities. The following is a quick guideline on how this escapeHtmlChars() function should and should not be used.\n\n```javascript\n// ✓ - It is safe to use escaped user input between most HTML tags.\n// (Just don't put it inside something silly like the <script> tag).\n`<p>${escapeHtmlChars(untrustedUserInput)}</p>`\n\n// ✓ - It is generally safe to use escaped user input inside of HTML attributes.\n// (Just don't put it inside something silly like onclick=\"...\")\n`<div data-author=\"${escapeHtmlChars(untrustedUserInput)}\">...</div>`\n\n// ✕ - Attribute values should always be quoted when they are being populated\n// with user-supplied data.\n`<img data-author=${escapeHtmlChars(untrustedUserInput)}>`\n\n// ✕ - Using escapeHtmlChars() isn't enough if you want to place\n// the value where a URL is expected. This is because HTML\n// supports fake protocols like `javascript:` that, when used, will execute\n// arbitrary code.\n`<img src=\"${escapeHtmlChars(untrustedUserInput)}\">`\n```\n\nFor a deep dive on how to prevent XSS attacks, I would recommend [this guide on escaping characters for various different contexts](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n\n## Don't use escapeHtmlChars() unless you have to\n\nDo you _really_ need an `escape()` function? Or would an alternative, less-error-prone solution work instead? There are valid reasons to need a function like `_.escape()`, but there are also some coding styles that force you to use it much more often than necessary. For example, perhaps you like to build your webpages via string interpolation and `.innerHTML`, such as in the following:\n\n```javascript\ndocument.body.innerHTML = `<p>${_.escape(userSuppliedString)}</p>`;\n```\n\nThis has the appearance of being simple and concise, but managing when and how to use `_.escape()` can be error-prone. There are a number of alternative solutions out there that remove many of these pitfalls (but not all, so you still need to look out for XSS vunerabilities no matter how you code). For example, you can use the browser APIs to manually build up your HTML instead of using string manipulation + `.innerHTML`.\n\n```javascript\nconst paragraph = document.createElement('p');\n// .innerText will automatically escape HTML characters for you.\nparagraph.innerText = userSuppliedString;\ndocument.body.replaceWith(paragraph);\n```\n\nIf you find this APIs to be cumbersome to use, you may enjoy [a little helper function](#!/utils/el) to make using it more tolerable.\n\nOr you can define your HTML [in template tags](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_templates_and_slots) (The linked guied will additionally show you how to use tamplate tags in conjunction with custom HTML elements).\n\nOr maybe you really like the looks of building up your HTML as strings, in which case you might consider using a third-party templating system such as [Handlebars](https://handlebarsjs.com/guide/).\n\nAll of these options will provide ways to auto-escape user-input for you, allowing you to focus more on UI building and less on data sanitization.\n\n","src":null,"test":"function escapeHtmlChars(string) {\n  return string\n    .replaceAll('&', '&amp;')\n    .replaceAll('<', '&lt;')\n    .replaceAll('>', '&gt;')\n    .replaceAll('\"', '&quot;')\n    .replaceAll(\"'\", '&#39;');\n}\n\ndescribe('escapeHtmlChars()', () => {\n  it('escapes all characters', () => {\n    const res = escapeHtmlChars('&<>\"\\'');\n    expect(res).toEqual('&amp;&lt;&gt;&quot;&#39;');\n  });\n\n  it('escapes all instances', () => {\n    const res = escapeHtmlChars('&<&<&');\n    expect(res).toEqual('&amp;&lt;&amp;&lt;&amp;');\n  });\n\n  it(\"doesn't panic on the empty string\", () => {\n    expect(escapeHtmlChars('')).toEqual('');\n  });\n});\n"},{"name":"unescape","manifest":{"fnSignature":"_.unescape(string)","lodashLink":"https://lodash.com/docs/4.17.15#unescape","summary":"The inverse of _.escape; this method converts the HTML entities &amp;, &lt;, &gt;, &quot;, and &#39; in string to their corresponding characters."},"description":"If you wish to unescape all HTML-encoded characters and you're in a browser environment, you can use the following:\n\n```javascript\nfunction unescapeHtmlChars(string) {\n  const doc = new DOMParser().parseFromString(input, 'text/html');\n  return doc.documentElement.textContent;\n}\n```\n\nIf your JavaScript is not running in a browser, you can instead use a library such as [jsdom](https://www.npmjs.com/package/jsdom) to mimic the DOM and provide the same kind of API, or you can use a lighter-weight package that only provides this HTML-character-unescaping functionality and nothing else, such as [html-entities](https://www.npmjs.com/package/html-entities).\n\nLodash's `_.unescape()` function does not unescape all HTML characters, only those that get escaped when using `_.escape()`, which means using its implementation would be insufficient in most situations. Nevertheless, if you are wanting an implementation like Lodash's, you can use the following:\n\n```javascript\nfunction unescapeHtmlChars(string) {\n  // Unecoding \"&\" needs to be done last.\n  // If it is done first, something like \"&amp;lt;\" would incorrectly\n  // get unencoded to \"<\", when it should be \"&lt;\"\n  return string\n    .replaceAll('&lt;', '<')\n    .replaceAll('&gt;', '>')\n    .replaceAll('&quot;', '\"')\n    .replaceAll('&#39;', \"'\")\n    .replaceAll('&amp;', '&');\n}\n```\n\n## Don't use unescapeHtmlChars() unless you have to\n\nThe use of `unescapeHtmlChars()` may (or may not) indicate an issue with how you're storing and transfering data. Escaping HTML characters is an operation that is generally done the moment before you insert it into your page. If this pattern is followed, you will generally have an unescaped version of your string on-hand as well, which removes the need for using an `unescapeHtmlChars()` function. [Further information about when to escape your HTML characters](https://security.stackexchange.com/questions/32394/when-to-escape-user-input/32396#32396).\n","src":null,"test":"function unescapeHtmlChars(string) {\n  // Unecoding \"&\" needs to be done last.\n  // If it is done first, something like \"&amp;lt;\" would incorrectly\n  // get unencoded to \"<\", when it should be \"&lt;\"\n  return string\n    .replaceAll('&lt;', '<')\n    .replaceAll('&gt;', '>')\n    .replaceAll('&quot;', '\"')\n    .replaceAll('&#39;', \"'\")\n    .replaceAll('&amp;', '&');\n}\n\ndescribe('unescape()', () => {\n  it('unescapes all characters', () => {\n    const res = unescapeHtmlChars('&amp;&lt;&gt;&quot;&#39;');\n    expect(res).toEqual('&<>\"\\'');\n  });\n\n  it('unescapes all instances', () => {\n    const res = unescapeHtmlChars('&amp;&lt;&amp;&lt;&amp;');\n    expect(res).toEqual('&<&<&');\n  });\n\n  it(\"doesn't panic on the empty string\", () => {\n    expect(unescapeHtmlChars('')).toEqual('');\n  });\n\n  it('does not double-unescape characters', () => {\n    const res = unescapeHtmlChars('&amp;lt;');\n    // Should equal \"&lt;\", not \"<\"\n    expect(res).toEqual('&lt;');\n  });\n});\n"}]}]